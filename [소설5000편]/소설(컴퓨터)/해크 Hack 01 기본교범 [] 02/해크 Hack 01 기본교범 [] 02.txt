
안녕하세요.

두번째 강좌 시간입니다.

이번 시간에는 바이러스의 이론적인 나머지 부분에 대해서 알아 보기로
하겠습니다.

세번째 강좌부터는 하드웨어,어셈블리 에 대한 강좌가 될 것입니다.


----------------------------------------------------------------------


5. 컴퓨터 바이러스의 위험성
현대사회에서 컴퓨터  바이러스에 대한 위험성은  상당히높다. 점차 전세계가 네트워크에  묶이고
모든걸 컴퓨터에 의존해 처리해 나가는  때에 악성 바이러스때문에 입게되는 경제적 피해는 상당
하다. 그리고 교통, 운송 체계도  컴퓨터에 의해 관리되는 세상에서 바이러스가 통제 시스템에 침
투하여 고장을 낸다면 엄청난 결과를 가져올 것이기 때문이다.

1) 컴퓨터 바이러스의 영향
예를들어 甲이라는 사람이 乙을  무척 미워하여 골탕을 먹일려고 한다. 甲은 乙의  컴퓨터에 재미
있는 게임이라며 자신이 만든 컴퓨터 바이러스가 감염된 디스켓을  건네준다. 乙은 그것도 모르고
재미있게 게임을 하고 그 사이 乙의 컴퓨터는 바이러스의  공격으로 고장나버린다. 여기서 그치면
다행이지만 甲이 건네준 프로그램을 또 다른 사람이 사용한다면  그의 컴퓨터도 감염될것이다. 그
리고 최초의 바이러스 프로그램은 乙과  다른 사람들의 컴퓨터에서 살아남아 다른 정상적인 프로
그램을 감염시키며 지속적으로 전파될것이다.
만약 이것이 컴퓨터 통신망의 자료실에 등록된다면 무수한 다수의 피해자가 발생할것이며 기하급
수적으로 그 숫자는 증가할것이다. 甲은 자신의 목적을 이루었지만  애꿎은 선의의 피해자를 남겼
다.
바이러스의 속성상 일단 제작,  전파된 바이러스는 멸종(?) 되기 힘들다. 컴퓨터와  프로그램이 존
재하는 한 바이러스는 계속될 것이다.  물론 그런 바이러스를 잡기위한 안티-바이러스(백신)도 지
속적으로 개발될 것이다. 하지만 바이러스가 반드시 나쁜 것만은 아니다.

Cohen에 의해 최초로 언급된 압축  바이러스(Compression virus)가 그 예이다. Huffmann coding
을 이용한 데이타 압축과  같은 데이타 조작으로 시스템 내의 실행화일을 감염시켜  압축한다. 이
는 메모리 요구 용량을 감소시키는 긍정적 영향을 끼친다. 물론  요즘도 공개된 실행화일 압축 프
로그램이 있지만 압축 바이러스는 말  그대로 바이러스의 특징을 가지고 있기때문에 일반적인 유
틸리티라고 보기는 어렵다.

다음 도표로서 진행과정을 보기 바란다.



{{
      감염된 프로그램이 시작된다.
}}

{{

}}

                                 |
                                 |

{{
      감염 대상 화일을 찾는다.
}}

{{

}}

                                 |
                                 |

{{
    찾았는가?
}}

{{

}}

                       NO       |     YES
                    +------------+-------------+
                    |                          |
                    |                          |
                    |
{{
 그 프로그램을 감염시킨다.
}}

{{

}}

                    |                          |
                    |                          |
                    |
{{
감염된 프로그램을 압축한다.
}}

{{

}}

                    |                          |
                    |                          |
                    |
{{
감염된 프로그램을 저장한다.
}}

{{

}}

                    |                          |
                    |                          |
                    |                          |

{{
     압축된 프로그램을 환원 시킨다.
}}

{{

}}

                   |
                   |

{{
        환원된 프로그램을 시작한다.
}}

{{

}}



2) 컴퓨터 바이러스의 전염성
컴퓨터 바이러스는 제작  속성(?)상 전파성이라는 특징을 가진다.  바이러스의 목적이야 전파하여
자신을 과시하는것이 대부분이므로 가장 손쉽고 대량적으로 전파시킬수 있는 공간인 컴퓨터 통신
을 주로 이용한다. 인터넷에 올린자료라면 순식간에 전세계 구석구석  안 퍼진곳이 없을테니까 말
이다. 통신망에서 다운받거나  개인적으로 복제한 디스켓 등에서 전파된 바이러스가  퍼지는 속도
를 보면 다음과 같다.

A. 실행시 하나만 복제하는 경우

V   (1)
VV   (2)
VVVV  (4)
VVVVVVVV  (8)
VVVVVVVVVVVVVVVV  (16)
VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV  (32)

B. 실행시 네개를 복제하는 경우

V  (1)
VVVVV  (2)
VVVVVVVVVVVVVVVVVVVV  (25)
VVVVVVVVVVVVVVVVVVVVVVVV............................................VVVVV  (125)


위로서 감염속도가 얼마나 빠른고 위험한지 알았을 것이다. 그러나  사실상 위와같은 수학적인 공
식의 전파속도는 드물다. 실제 감염된 프로그램 모두가 곧 실행하는 것은 아니기 때문이다.


6. 컴퓨터 바이러스 제작자들
컴퓨터 바이러스를 제작하는 사람들은 어떤 사람일까? 자신의 실력을 뽐내기 위한 사람들이 대부
분이다. 그외 다른 생각으로 무조건적으로 악의에 차서 시스템과  화일의 파괴만을 목적으로 제작
하는 사람도 있을  것이다. 보통 사람들이 생각하기에  바이러스 제작자는 컴퓨터 해커쯤  된다고
생각하지만 결코 그렇지만은 않다. 몇몇 바이러스를 제외한 대부분의  바이러스는 원형을 약간 변
형한 것이 대부분이기 때문이다. 컴퓨터 바이러스는 '해커'들만이 만드는 것이 아니며, 바이러스를
제작했다고 그사람을 마치 대단한 사람으로 생각하는것은 옳지 않다.
예를들어 서울 바이러스  연합 이라는 것도 있다. 이들의  정체는 밝혀지지 않고있는데, 개인인지
어떤  단체인지  모르겠지만  여러가지   국산  바이러스를  계속  제작중에  있다.  89,  90년에
PC-SERVE(현 천리안), KETEL(현  하이텔)에 호스트를 파괴하겠다고 서울바이러스  연합이라고
칭하는 사람이있었다. 물론 단순협박사건으로 끝나긴 했지만 바이러스에  대한 공포를 유발하기에
충분했다.
91년도에 자신을 SVS-009라고 부르면서 빈대, 처단자, 서울, 667 바이러스를 만든 사람이 있었다.
이 두사람이 동일인인지  아니면 다른 사람인지 전혀 알수 없었다.(서울  바이러스의 문자열을 검
색하면 y가 빠진 Seoul Virus Societ라고 나옴)
최근에 자신을 SVS 라고 하는 사람(혹은 단체)가 있는데 이들이 만든 최초의 바이러스로 알려진
E.O.S. 바이러스 내부에 'Cheer up! SVS-009'라는 문자열이  있기 때문에 SVS-009는 아닌 또 다
른 사람일수도 있다. 서울  바이러스 연합이 드러내놓고 활동을 하는 것이 아니기  때문에 개인인
지 여러명인지 전혀 알길이 없다.

SVS의 바이러스 특징을 살펴보면, 우선 DEBUG로 고친 초기의 몇종을 빼고는 모두 빠른 속도로
감염이 진행된다. 안철수씨도 지적하셨듯이  한국산 바이러스 중에는 최초로  바이러스  분류상 3
세대인 은폐형 바이러스들이다.  넥스트의 경우는 암호화기법도 사용한다.  그외 감염방법도 보통
실행때 감염되지만 실행은 물론, DIR파일 열기, 이름 바꾸기,  지우기, 속성 변환때도 감염될 만큼
무차별적으로 감염된다.  '저주 C' 바이러스의 경우  군부대 전산소의 컴퓨터를  파괴했다고 한다.
일단 SVS의 바이러스들은 몇종을 빼고 하드를 인식못하게 하고 CMOS 데이터 까지 모두 파괴해
버린다. 국산 바이러스중 SVS가 만든 것으로 추정되는 바이러스는 많이 있다.

7. 컴퓨터 바이러스 발전단계
1세대, 원시형 바이러스(primitive  virus)는 간단한 구조의 바이러스이다. 2세대, 암호화  바이러스
(encryption virus)는 대부분을 암호화해서  저장한다. 하지만, 암호를 푸는 방법이 모두  동일하기
때문에 백신등에서 원시형 바이러스와 동일하게 진단된다. 3세대,  은폐형 바이러스(Stealth virus)
는 어떤 측면에서 보면  암호화 바이러스 보다 못하다고 볼수 있다. 보이지않는  폭격기 스텔스기
에서 이름을 따왔다고  한다. 일반적으로 은폐형 바이러스는  100 바이트 정도 밖에 안되는  짧은
명령어가 추가되면  만들수 있다. 하지만, 일반  사용자 측면에서는 발견하기가  더 어려운것이다.
그외 은폐형으로 만들기 위한 여러가지 방법이 더있다고 한다.
프로도(Frodo,일명 4096) 바이러스는 감염된 프로그램을 읽으려고  하면 감염된 흔적은 숨기고 원
래의 부분을 대신  보여 준다. 그외 국내에 없지만  TV(Turbo Vaccine)에서 치료 가능한 세이하
(Sayha)의 경우 DIR 로는 증가 길이를 볼수  있지만, 감염된 파일을 읽을 때 원래 부분을 보여준
다. 그외 인터럽트를 은폐하는 것도  있다. 이것으로는 역시 프로도가 있으며 93년 말에 대단했던
맥가이버(MacGyver,McGyver) 바이러스가 있다.
4세대, 갑옷형 바이러스(armour virus)는  암호화와 자체 수정 기법등을 사용한다고 한다.  3∼4세
대의 중간 단계로 다형성(polymorphic) 바이러스가  있다. 이것의 경우 암호화를 사용하기는 하지
만, 분석하기는  쉽다. 몰타 아메바(Maltese_Ameoba), 푸른  하늘(Blue_Sky) 등은 감염될  때마다
암호를 푸는 방법이 달라진다.
하지만, 다형성과 갑옷형은 따로  분류되어야 한다고 생각한다. 갑옷형 바이러스도 역시 암호화를
사용하지만 분석하기가 상당히 까다롭다. 국산으로는 'KOTHS_HWB.4771'가 있다. 이것은 램에서
도 암호화가 되어  있다. 특히 고래(Whale) 바이러스는 여러  전문가가 모여 분석을 겨우 했다고
한다. 바이러스길이도 약  9KB 로 엄청나다. 이 바이러스의  계통을 보면 프로도에서 발전했다고
짐작된다.(프로도→물고기→고래) 하지만, 이런 분류도 모호한 것이 많다. 세이하 바이러스의 경우
은폐형으로볼 때 대부분 은폐형 하면 길이증가를 숨기는 것인데  이것은 그것을 만족하지 못한다.
그리고, 암호화 바이러스도  일부만을 암호화 시키는 바이러스의 경우 암호화라고  보아야 하는지
도 논란의 여지가 있다.(Meihua의 경우 Int 1h을 가로채 조금씩 실행하면서 바이러스  중 일부 암
호화된 부분을 푼다.)

8. 컴퓨터 바이러스 침입에 따른 진단과 양상
컴퓨터 바이러스가 침입했는지의 여부를 알아낸다는  것은 어떤 면에서 이미 피해가 발생한 후에
침입 사실을 알아차리게 되는 것과 같다. 다음의 일반적인 증상으로 체크해보자




 * 정상적으로 작동하던 프로그램이 갑자기 실행이 안된다.
 * 평소 요구하지 않던 메모리를 요구한다.
 * 프로그램 실행 속도가 느려진다.
 * 이상한 에러 메시지가 나타난다.
 * 디스크의 남은 용량이 감소한다.
 * 화일의 작성 날짜가 변한다.
 * 갑자기 자주 디스크 엑세스를 한다.
 * 시스템이 이유도 없이 다운(DOWN) 된다.
 * 화일이 이유도 없이 사라지거나 늘어난다.
 * 디렉토리가 엉망으로 엉켜버린다.
 * 정상적이던 디스크에 불량 섹터가 속출한다.
 * 시스템 영역이 파괴되었는지 갑자기 부팅이 안된다.
 * 컴퓨터 사용시 이상한 음악이나 삑 소리등이 울린다.
 * 메모리 상주 프로그램이 에러가 생기거나 거부당한다.


대충 위와 같은 증상들이  바이러스의 대표적인 것이다. 이외에도 여러 증상이 나타날수  있을 것
이다. 다음의 여러 양상들을 자세히 살펴보기 바란다.

1) 컴퓨터 바이러스에 의한 시스템 정지
비행기를 보면 블랙박스  라는 것이있다. 이는 비행기  운항에 대한 전반적인 데이타를  안전하게
저장했다가 사고가 났을때 분석하기 위함이다. 이것은 컴퓨터에도 적용될 수 있는 이야기이다. 몇
몇 기종의 컴퓨터는 SYSLOG라는 화일에 이런 정보를 담고있다. 바이러스가 침입해 시스템을 망
가트렸다면 시스템 오퍼레이터는 이를 분석해 원인을 찾을것이다.
그러나 MS-DOS를 사요하는 일반적인  컴퓨터에는 기본적으로 이런 역할을 하는 화일이  존재하
지 않는다. 시스템이 파괴되는 원인(일반적으로 정지)으로는 첫째,  프로그램과 시스템간의 결함에
의한 다운(DOWN)이다. 둘째,  컴퓨터 바이러스 프로그램 자체내의  버그(오류)로 인한 발생이다.
마지막으로 가장 치명적인 것이 컴퓨터 바이러스의 고의적 시스템  정지이다. 이를 구체적인 증상
으로 살펴보면 키보드를 통한 입력이 정지당하는 것이나 모니터 출력의 변화 그리고 잡음 출력등
으로 들 수 있겠다. 이럴경우  부팅을 하거나 전원을 끊는수밖에 없다. 바이러스에 의한 것이라면
이런 현상은 지속적일  수 있어서 문제이다. 더우기  부팅을 했지만 CMOS 셋업이  풀려버렸거나
시스템 영역의 파괴로 컴퓨터가 정상적으로 작동하지 않는 경우는 복구에 많은 시간을 필요로 한
다.

2) 컴퓨터 바이러스에 의한 하드웨어 파괴가능성
소프트웨어적으로 하드웨어를 파괴한다면  믿지 못하는 사람들도 많다. 하지만 이것은  충분히 가
능한 일이다. 필자가 알고있는 어떤 분은 이런 프로그램을  만들어 모니터나 마더보드를 태워버릴
수 있다고 자랑하기까지  했으니 말이다. 대부분의 하드웨어는 이런 소프트웨어적인  잘못된 명령
에 대비하고 있으나 그렇지 않은 경우도 있다는 것을 알아두기 바란다.
일반적인 하드웨어 파괴의 예를  들면, 디스크에 명령을 주어 존재하지 않는 내부  트랙으로 이동
하라는 콘트롤러 명령을 준다면  헤드는 안쪽으로 꽉 끼어서 움직이지 않는  JAM 현상이 발생한
다. 이 경우  번거롭지만 손으로 직접 해결해야만 한다. 이와  유사한 방법으로 프린터에 "페이퍼
잼(종이 낌)"  현상을 유도할수도  있다. 그리고  하드 디스크의  마스터 부트 섹터(Master  Boot
Sector)를 지우는 바이러스이다. 이  경우 포맷을 한다해도 다시 사용할수는 없다.  이외에도 단지
config.sys에 변형을 가해 엄청난 수의 하드  디스크 억세스를 실행시켜 하드 마모를 가져오는 경
우도 있다.

3) 컴퓨터 바이러스에 의한 에러조작
정상적인 시스템과 운영환경임에도 불구하고 단지 에러인척 조작하는  바이러스도 있다. 사용자는
단지 화면에 뜨는 메시지와 스피커를  통해 나오는 잡음만으로 시스템에 이상이 생긴걸로 판단해
버리는 경우가 있다.

다음은 초기 시절 소프트웨어 제작사들이  무단복제를 막기위해 화면에 내보내는 메세지 증 하나
이다.

  Internal error number : 084 876 at position pc 586
  please notify the manufacturer

이럴경우 아무 이상이  없지만 불법복제 사용자의 경우는  지레 겁을 집어먹게된다. 이런  방법을
컴퓨터 바이러스 제작자들이 모를리가 없다. 그리하여 나온 것이 "Rush Hour" 바이러스이다.
"러쉬아워" 바이러스는 단지 키가 눌려질때마다  소리를 내어 사용자가 짜증을 내며 이상이 있는
것처럼 유도만 한다.  이 외에 하드디스크에 배드섹터가 있는것처럼 보이게  한다거나 특정회사가
이런 에러를 유발시켜 새로운 구매를 이끌어 내는 경우도 있다.


4) 컴퓨터 바이러스에 의한 데이타 조작
컴퓨터의 하드웨어를 파괴하는것은  물리적인 것이기에 다시 수리하거나 새로 구입하면  된다. 그
러나 소프트웨어적인 데이타를  파괴하거나 변경시켜 버린다면 그 피해는 상상하기  어렵다. 고객
명단이 수록된 데이타베이스에 바이러스가 침투하여 엉뚱하게 바꾸어 버리거나 수년간 막대한 연
구비를 투자하여 제작한 프로젝트가 순식간에 날아가버릴수도 있다.
데이타를 전부 삭제하는것보다도 부분적인 변형을  가한것이 더 찾기 힘들뿐만 아니라 오류를 지
닌채 출력을 하므로  더 악질적이다. 은행 시스템에  바이러스가 침투하여 그날 출금  자리숫자를
변형 시킨다면 엄청난 혼란이  초래될것이다. 일일이 찾아서 수정하기도 결코 쉽지가 않을것이다.
데이타 오류 추적에 투자되는 시간은 곧 돈이다.



5) 컴퓨터 바이러스에 의한 시스템 실행 시간 가로채기
컴퓨터 바이러스에 의한  문제점은 굉장히 다양하다. 그  중 컴퓨터 바이러스가 시스템에  침투해
일으키는 문제로서 시스템  수행 시간을 가로채는 것이있다. 바이러스는 컴퓨터의  주메모리에 침
투해 있다가 메모리로  들어와 처리되는 프로그램들의 시간을  가로채서 시스템을 느리게 만들고
능력을 저하시킨다.
이외에 부당한 시스템  엑세스를 요구하는 바이러스도 존재한다. 네트워크를 통해  메인 프레임에
침투한 바이러스는 제작자가  명령한 대로 자신을 복제하고 특정 시간이  될 경우 메인 프레임에
억세스할 권한을 바이러스 제작자에게 넘겨준다. 메인 프레임이 감염될  경우 부당한 사용자가 시
스템을 조종하여 파괴할수도 있고 접속해오는 사용자들에게 바이러스를 전파할수도 있다.


9. 오퍼레이팅 시스템(Operating System)와 컴퓨터 바이러스
컴퓨터는 운영체제에 의해  작동한다. 컴퓨터 바이러스의 대부분은 이런 운영체제를  교묘히 이용
한다.
컴퓨터 운영체제에는 인터럽트라는  아주 중요한것이 있다. 인터럽트란  하드웨어적인것과 소프트
웨어적인 것으로 구분하는데 하드웨어적인  것은 하드웨어에서 발생하는 각종 신호들을 가리키며
소프트웨어적인 것은  프로그램이 진행하면서 발생하는 신호를  말한다. CPU는 컴퓨터  작업도중
발생하는 신호들을 조화롭고  효율적으로 처리해주는 것이다. 이러한 인터럽트의 기능  호출은 컴
퓨터 바이러스에게 역으로 공격할 소지를  남겨준다. 적을 알고 나를 알면 승리한다했다. 가장 널
리 쓰는 MS-DOS의 인터럽트에 대해 알아보자.
MS-DOS는 단일 운영체제로서 세계 약 1억명의 사용자를 가지고있다. 그렇기에 바이러스의 수도
엄청나게 존재한다. MS-DOS의  시스템은 인터럽트를 통해 어셈블리에 접근한다. 이  인터럽트는
'INT'라는 어셈블리 명령어로 호출된다. 인터럽트 리스트와 그 기능에 대해 알아보자.

인터럽트 번호           작업

00                      Division
01                      Single step
02                      NMI
03                      Brakepoint
04                      Overflow

05                      Print screen
06                      사용 안함
07                      사용 안함

08                      Timer
09                      Keyboard
0A                     사용 안함
0B                      AUX port COM1
0C                      AUX port COM2
0D                     Hard Disk Controller
0E                      Floppy Disk Controller
0F                      Printer

10                      SCREEN
11                      HARDWARE CHECK
12                      GET MEMORY SIZE
13                      DISK READ/WRITE(SECTOR)
14                      AUX READ/WRITE
15                      CASSETTE
16                      KEYBOARD
17                      PRINTER
18                      BASIC ROM
19                      BOOT STRAP
1A                     TIME
1B                      KEYBOARD BREAK
1C                      TIMER
1D                     SCREEN INIT
1E                      DISK PARAMETER ADDRESS
1F                      ASCII SET ADDRESS

실제 시스템 인터럽트는 20H 부터이다.

20                      TERMINATE PROGRAM
21                      DOS FUNCTION CALL
22                      TERMINATE ADDRESS
23                      CTRL C HANDLER ADDRESS
24                      CRITICAL FAILURE ADDRESS
25                      ABSOLUTE DISK READ
26                      ABSOLUTE DISK WRITE
27                      TERMINATE/REMAIN RESIDENT
28                      DOS INTERNAL
-
3F
40                      RESERVED FOR EXPANSION
-
5F
60                      USER INTERRUPTS
-
7F
80                      BASIC INTERRUPTS
-
85
86                      BASIC INTERPRETER INTERRUPTS
-
F0
F1                      사용 안함
-
FF

시스템 인터럽트중 주목할것이 21H이다. 21H는 특별한 역할을 하는것으로서 이것을  사용하기 위
해서는 인터럽트 실행전 아래 값들  중에 하나를 AH에 넣어 주어야 한다. 그러면 다음의  펑션들
을 사용하게된다.


AH 번호                기능(function)

00                      TERMINATE PROGRAM
01                      READ KEYBOARD AND ECHO
02                      DISPLAY CHARACTER
03                      AUXILIARY INPUT
04                      AUXILIARY OUTPUT
05                      PRINT CHARACTER
06                      DIRECT CONSOLE I/O
07                      DIRECT CONSOLE INPUT
08                      READ KEYBOARD
09                      DISPLAY STRING
0A                     BUFFERED KEYBOARD INPUT
0B                      CHECK KEYBOARD STATUS
0C                      FLUSH BUFFERS/READ KEYBOARD
0D                     FLUSH BUFFERS/DISK RESET
0E                      SELECT DISK
0F                      OPEN FILE
10                      CLOSE FILE
11                      SEARCH FOR FIRST ENTRY
12                      SEARCH FOR NEXT ENTRY
13                      DELETE FILE
14                      SEQUENCIAL READ
15                      SEQUENCIAL WRITE
16                      CREATE FILE
17                      RENAME FILE
18                      MS-DOS INTERNAL
19                      GET CURRENT DISK
1A                     SET DISK TRANSFER ADDRESS
1B                      MS-DOS INTERNAL
1C                      MS-DOS INTERNAL
1D                     MS-DOS INTERNAL
1E                      MS-DOS INTERNAL
1F                      MS-DOS INTERNAL
20                      MS-DOS INTERNAL
21                      RANDOM READ
22                      RANDOM WRITE
23                      GET FILE SIZE
24                      SET RELATIVE RECORD
25                      SET INTERRUPT VECTOR
26                      CREATE NEW PROGRAM SEGMENT
27                      RANDOM BLOCK READ
28                      RANDOM BLOCK WRITE
29                      PARSE FILE NAME
2A                     GET DATE
2B                      GET TIME
2C                      SET TIME
2E                      SET/RESET VERIFY FLAG
2F                      GET DISK TRANSFER ADDRESS
30                      GET DOS VERSION NUMBER
31                      TERMINATE/REMAIN RESIDENT
32                      MS-DOS INTERNAL
33                      CTRL-C CHECK
34                      MS-DOS INTERNAL
35                      GET INTERRUPT VECTOR
36                      GET DISK FREE SPACE
37                      MS-DOS INTERNAL
38                      GET COUNTRY INFORMATION
39                      CREATE SUB-DIRECTORY
3A                     REMOVE DIRECTORY
3B                      CHANGE CURRENT DIRECTORY
3C                      CREATE FILE/HANDLE
3D                     OPEN FILE/HANDLE
3E                      CLOSE FILE/HANDLE
3F                      READ FROM FILE/DEVICE
40                      WRITE FROM FILE/DEVICE
41                      DELETE FILE
42                      MOVE READ/WRITE POINTER
43                      CHANGE ATTRIBUTES
44                      I/O CONTROL FOR DEVICE
45                      DUPLICATE FILE HANDLE
46                      I/O REDIRECTION
47                      GET CURRENT DIRECTORY
48                      ALLOCATE/LOCK MOMORY
49                      UNLOCK MEMORY
4A                     MODIFY ALLOCATE MEMORY
4B                      LOAD/EXECUTE PROGRAM
4C                      TERMINATE PROCESS (ERROR)
4D                     GET CHILD'S RETURN CODE
4E                      FIND MATCH FILE
4F                      FIND NEXT FILE
50                      MS-DOS INTERNAL
51                      MS-DOS INTERNAL
52                      MS-DOS INTERNAL
53                      MS-DOS INTERNAL
54                      RETURN VERIFY FLAG
56                      MOVE FILE (RENAME)
57                      GET/SET FILE TIME & DATE
58                      GET/SET ALLOCATION STATUS
59                      GET EXPAND ERROR CODE
5A                     GERNATE TEMPORARY FILE
5B                      CREATIVE FILE
5C                      OPEN/CLOSE FILE ACCESS ABILITY
5E                      GET INFORMATION OF DEVICE

위에서 소개한 것들은  컴퓨터 바이러스를 제작할 수  있는 모든 조건들을 제공해준다.  제작자는
단지 적절히 골라서 사용하기만 하면 된다.

10. 컴퓨터 바이러스의 종류와 특징
바이러스는 그 종류도 다향하고 양상도 각각이다. 컴퓨터 바이러스는  특별히 정의를 내리기도 어
려울 뿐더러 분류에도 어려움이 있다.

1) 보편적인 바이러스 분류

 A. Overwriting VIRUS
원래 화일을 파괴하기 위해 덮어쓰는 형태의 바이러스이다. 가장  간단한 형태지만 바이러스의 모
든 특성을 지니고있다. 일단 실행되면 디스크의 모든 화일들을 지운다. 그러므로 쉽게 눈에 띈다.

 B. Non-Overwriting VIRUS
이 바이러스는 화일의 원형을 그대로 보존하기에 발견이 쉽지 않을뿐더러 덮어쓰는 바이러스보다
더 위험하다. 이유는 덮어쓰는 형태의  바이러스는 쉽게 눈에 띄기 때문에 전파력이 약하다. 엄밀
히 말해 바이러스의 위험도는 파괴력보다 숨어있는것이 더 무섭기 때문이다.

 C. Memory 상주 VIRUS
메모리 상주형 바이러스는  전파속도와 감염도에서 가장 뛰어나다. 이 바이러스가  메모리에 침투
하면 메모리에서 상주하여 있으면서  메모리로부터 읽어들이는 모든 화일이나 디스켓등에 감염을
시킨다. 컴퓨터가 꺼지는 순간까지 이 바이러스는 살아있을 것이다.

 D. Calling VIRUS
위의 바이러스들은 모두 그 크기가  크다. 그렇기에 발견될 위험도도 그만큼 크다. 그래서 calling
형 바이러스는 화일의 속성변환  등을 통해 눈에 안띄게 되어 있다. 감염시에만  바이러스 프로그
램을 호출하는 명령어만을 화일에 써넣는다. 사용자들의 눈을 속여 쉽게 발견되기 어렵다.


2) 그외의 컴퓨터 바이러스 분류


A. 트로이 목마형 & 시한폭탄형 바이러스
트로이목마는 고대 희랍에서 유래된말로 상대의  맘에 들게 만들어 그것을 취하면 피해를 입히는
미끼라고 할수 있다. 즉, 트로이목마형 바이러스를 만들면 트로이목마 바이러스는 제작자가 의도
한 방향대로 작동할  것이다. 단, 프로그램이 생명이  있는것도 아닌데 그냥 움직일리  없다. 분명
상대방이 이것을 실행시켜야 한다. 그래서 트로이목마형 바이러스는 화려한 가면을 쓰고있다.
최신 게임에 묻어오거나 누구나 한번쯤 실행시켜볼 그런  프로그램들에 감염되어 전파되는것이다.
그 예로 미국의 한  사설비비에스에서 있었던 일이있다. 새로 자료가 등록되었는데,  이름하여 '마
돈나 뮤직비디오!'  사람들이 호기심에 무진장 받아갔다.  처음에 실행하니 진짜 마돈나가  나와서
춤추고 노래부른다. 좀 있다가 화면에 '마돈나를 PC에서 봅니까?'하는 메시지와 더불어 하드가 날
라갔다. 트로이목마형의 전형적인 유형이다.  하지만, 이런 방식을 쓰면 트로이 목마를  제작한 사
람을 알 수 있고 그 출처도 알 수 있다. 이렇게 되면 전파력이 떨어지고 꼬리가 밟히는것이다. 그
래서 좀더 새로운 기술을 원해서 탄생한게 시한폭탄형(일명 논리형) 바이러스이다.
자신이 프로그래밍시 입력한 날짜나 시간 혹은 조건이 맞는다면 바이러스가 작동을 하는것이다.
물론, 날짜나 시간, 분,  초 단위까지도 맞추어 놓을수 있으나 월단위로 맞추어 놓는게  가장 확실
할것이다. 날짜로 맞추면 그 날짜에  컴퓨터를 사용안하고 거르면 또 한달을 기다리고, 시간도 마
찬가지일것이다. 좀 소스가 길어지지만 아예 1월 1일,  3월23일 이런식으로 코딩할수도 있다. 이번
달이 2월이면 바이러스에는 한 4월에 작동하라구 타이머를 맞춰두면 어김없이 4월 한달내내 작동
한다. 물론 그때까지 걸리지않구 숨어있어야 하니까 화일 속성을 숨김으로 바꾸어 놓으면 된다.
이러한 트로이 목마형 바이러스는 일반적인 프로그램을 가장하고 그 안에는 고의적으로 사용자가
모르는 다른 기능을 포함하고 있으며 자기 복제 기능이 없는 것이 특징이다.
트로이 목마형 바이러스를 기존의 바이러스 영역에 넣어야 할것인지에  대해선 논란이 많았다. 몇
몇 공식같은 바이러스 특성에 맞추기는 힘들기 때문이다. 하지만  목적과 행동유형이 같으니 엄연
한 바이러스 범주에 들어가야 한다.


 B. 벌레 프로그램
컴퓨터 시스템에는 별다른 영향을 끼치지 않고 자신을 계속  복제하는 프로그램이다. 네트워크 상
의 크리스마스 바이러스가 대표적인 예이다.

11. 컴퓨터 바이러스의 제작
컴퓨터 바이러스가 실제 어떻게  작동되고 제작되는지에 대해서 알아보자. 프로그래밍 언어별, 바
이러스 종류별로 구현된 소스를 게재하여 이해를 돕도록 하겠다.
컴퓨터 바이러스는 대개  어셈블리어로 작동한다. 이유는 어셈블리어가 가장 컴퓨터  시스템에 근
접할 수 있는 언어이기 때문이다. 어셈블리어로 제작된 바이러스는  그 크기도 작을뿐더러 속도도
빠르다. 하드웨어 접근에 탁월하기에  컴퓨터 바이러스 제작에 주로 사용된다. 해커라면 어셈블리
어는 능숙하게 다룰줄 알아야 하는것은 기본이다.
그러나 어셈블리어만으로  바이러스를 만드는것은 아니다.  베이직, 파스칼, C  언어 더우기 배치
(BATCH)화일 로도 프로그래밍을 할 수가 있다. 이렇게  컴퓨터 바이러스 제작기법을 공개하는것
은 바이러스의 실체를 낱낱이 알아야  이에 대처할 수 있다는 생각 때문이다. '知彼知己면 百戰百
勝'이라는 명언을 생각해보자.



----------------------------------------------------------------------
