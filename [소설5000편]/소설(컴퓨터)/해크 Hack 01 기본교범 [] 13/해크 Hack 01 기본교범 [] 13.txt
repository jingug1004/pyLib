안녕하세요.

11번째 시간입니다.

이번시간에는 유닉스에 대해 알아보기로 하겠습니다.
다음시간부터 인터넷에 대한 강좌가 2회 게재 되겠습니다.


1-2-2 인터넷 사용자를 위한 유닉스 기본

  유닉스는 가장  훌륭한 운영체제이다. PC에서  동작하는 주요 OS로는  DOS, MS-WINDOWS,
OS/2 등을 들 수 있다. DOS의 시대는 이미 지났으며(MS-DOS 6.x 버젼이 DOS의 마지막 버젼),
MS-Windows나 NT는 수많은 소프트웨어군들을 가지고  있고, OS/2는 화려한 개체 지향 인터페
이스와 DOS나 MS-Windows와의   특유의 호환성을 지원하고 있다. 유닉스는 이러한  운영체제
들의  모범이  되어온 강력한  멀티태스킹과  멀티유저기능을  보유하고 있으며,  GUI  환경으로
는 X-Windows를 제공한다. 특히,   리눅스는 유닉스의 공개 버젼으로써  486 PC를 유닉스가 탑
재된 워크스테이션급의 성능과 맞먹는 기능을 제공하는 훌륭한 유닉스 시스템이다.

  근래들어, 많은 소프트웨어들이  사용자 인터페이스에 역점을 두어  개발되고 있다. 일반적으로
유닉스는 사용자 인터페이스가 좋지 않다고 알려져 있으며, 따라서 배우기 어렵다고 한다. 이것에
대한 필자의 생각은 이렇다.  아무리 쉽게 설계된 운영체제나  응용프로그램들도 그  기능을 충분
히 활용하려면 적지  않은  시간과 노력이 들기 마련이다.   DOS의 허약한 체력을 뒷바침해주는
것은  비정상적인 트릭과 하드웨어를 직접 제어하여  그 체력의 한계를 뛰어 넘는 훌륭한 응용프
로그램들이다. 실제로 스스로 부팅하여 동작하는 프로그램도 있었다.   결국, 사용자의 입장에서는
운영체제와 응용프로그램과의 어떠한   통일성이나 일관성을 찾아 보기 어려우며, 서로   다른 유
틸리티나  응용 프로그램을 각각  열심히 배워야 한다.  각각의 응용프로그램들이 고유의  인터페
이스를 가지고 있는  것은  수많은 프로그램을 이용해야하는 사용자에게는   결코 사용하기 편한
인터페이스는 아닐 것이다.
  훌륭한 사용자 인터페이스는 깔끔한 화면이나 쉽게 실행시킬 수 있는 구조를 가지고 있는 것보
다는 사용자가 원하는 최종 결과를 쉽게 얻을 수 있어야 한다.

  응용프로그램들이 방대해지고 있다. 이제는 응용프로그램 하나가 10MB 이상되는 것을 쉽게 찾
아 볼 수 있다. 통합적인 기능을 제공하기 위해서 수많은 루틴과 폰트들이 첨가되고, 사용자 인터
페이스를 위해서 적지   않은 코드들이 사용된다. 아무리 수많은 기능을   제공하는 응용프로그램
이
라 할지라도 모든 작업을 할 수 없는 것이 컴퓨터상의 작업이다. 따라서, 당연히 여러가지의 응용
프로그램을 사용하며, 그러인해 똑같은 루틴과 폰트 등이 여러개 존재하게 된다. 이것은 프로그래
머나 사용자에게 낭비가  아닐  수 없다. 유닉스는  라이브러리를 서로 공유하며, X상의   폰트들
을
함께 사용한다. 적은 용량이 아닌 유닉스는 실제로 최적화된 시스템인 것이다.

  OS/2나 NT는 모두 훌륭한   운영체제들이다. 하지만, 실제로 이들 운영체제를 사용하기   위해
서
는 최소한 각각  8MB와 12MB의 RAM용량을 가지고 있어야  하며, 이들 전용의 응용프로그램도
많지 않다. 대부분  DOS와의 호환성으로 그 응용프로그램들을 실행할 수  있으나, 큰 패키지같은
경우는 운영체제에 다소 무리가 따르며, 실행이 불가능한 것도 있다.

  리눅스는 전세계의 해커들에 의해 만들어진  80386 이상의 PC에서 운영할 수 있는  공개  유닉
스이며, FSF(Free Software Foundation)에서 GNU(Gnu's Not Unix) Project의 일환으로 계획 개
발된 것이다. FSF는 "소프트웨어는 소스를 포함하여  공개적으로  배포되어야 소프트웨어 자체를
비롯하여 사용자나 개발자에게 진정한  발전이  이루어진다"라는 주의를 펼치고자 설립된 비영리
재단이며, GNU는 그것을 실천으로 옮기고자하는 프로젝트이다.

  해커의  시대가 하드웨어에서   소프트웨어로 변화되었다.  이 시대  마지막 해커라고   불리우
는 Richard Stallman이   설립한 FSF는 진정한 해커주의를  실현하고 있는  재단이다.  해커라는
말이 사회적으로 나쁜 용어로 쓰이고  있는게 현실이지만,  이들은 반드시 범죄자와는 구분되어야
한다.
해커주의는 근본적으로 정보는 모든이에게  공유되어야 한다는 것이 주된 바탕이다. 따라서, 프로
텍트를 걸거나 소프트웨어를   판매하는 행위로 정보의 흐름을 막는 것을   거부한다. 소프트웨어
에 관한 지적 소유권이나 특허권에   위배된다고 볼 수 있으나, 이들 법률적 장치는   궁극적으로
소프트웨어를 발전시키는  것이 목적이지  쇠퇴시키는  것이 아니다. Richard  Stallman이 생각해
낸 것은 상업용이 되어버린 수많은 프로그램을  지적 소유권 침해없이 공개용 프로그램으로 만드
는 것이었다. 이것이 바로, 법에 위배되지 않으면서 소프트웨어를 마음대로 사용할  수 있게 하는
GNU 프로그램들이다. 결론적으로, 리눅스라는  훌륭한 공개 유닉스와 수많은 GNU 프로그램들이
개발되었다.

  현실적으로, 절대적인 기술  우위로 미국 주도인 소프트웨어  산업을  우리나라같은 후발주자들
이 따라잡기 위한 방법중의 하나가  GNU라고 생각한다. `한글화'라는  울타리에 언제까지나 안주
할 수는 없으며,  유니코드(UNICODE)는 그 울타리마저 허물어  버릴 것이다. 소수의 개발자팀에
의해 힘들게 쫓기 보다는 다수의 사용자와 개발자들 모두 서로 나누고 발전시키는 것이 유니코드
를 역이용할 수 있는 방법이 될 것이다.





인터넷 사용을 위한 기본적인 유닉스의 명령과 체계에 대한 글이다.


    ■ 로그인/로그아웃(login/logout)
    유닉스 시스템을 사용할 때 최초로 접속하는 것을 '로그인(login)'이라
하고 작업을 종료하고 빠져나오는 것을 '로그아웃(logout)'이라고 한다.
모뎀을 통해 접속하면 'login:'이 나타나면서 사용자번호(id)를 물어본다.
    이때 자신의 계정을 입력하면 시스템은 다시 그 id에 대한 암호를
'Password:'라고 묻는다. 암호를 입력하면 비로소 해당 시스템에 로그인이
된 것이다. gglim이라는 id를 가진 사용자가 로그인하는 예는 다음과 같다.
암호는 보안상 화면에 나타나지 않는다.

    login: gglim
    Password: ________

    유닉스 시스템을 끝낼 때는 'logout' 또는 'exit' 명령어 중 하나를
입력한다.
    한가지 주의할 것은 유닉스 시스템은 도스와는 달리 대문자와 소문자를
구분한다는 점이다. 대부분의 유닉스 명령어와 사용자 id는 소문자이므로
입력할 때 대문자로 입력하지 않도록 주의해야 한다.


    ■ 유닉스 셸

    유닉스 셸은 사용자와 운영체제 커널 사이에 위치하는 명령어
해석기다. 셸은 사용자의 입력을 받아 이를 해석한 후 상응하는 동작을
취해주는, 사용자와 시스템 사이의 인터페이스며 일반 프로그래밍 언어의
기능도 포함되어 있다. 유닉스 시스템에서 기본적인 셸은 'Bourn
Shell(/bin/sh)'과 'C Shell(/bin/csh)'이다. 일반적으로 로그인하면 csh이
로그인될 때 기본으로 작동되어 csh 상태에서 모든 명령을 수행하는
것이다. csh의 기본 프롬프트는 "%" 이다.


    ■ 명령어 문법 구조

    일반적인 유닉스의 명령어는

         command [-옵션] [파라메터]

    와 같은 형식을 취한다. 여기서 명령어란 셸 내부의 내장(built-in)
명령어이거나 실행가능한 파일로 따로 존재하는 외장 명령어다. '-옵션'은
명령어의 기본적인 동작을 바꾸기 위해 사용된다. 도스에서는 '/'를
사용하는데 여기서는 '-'를 사용한다는 점이 다르다. '파라메터'는 주로
파일명을 나타낼 때 사용하는데 명령어마다 파일명을 요구하는 것과
하지않는 것이 있다.
    그러면 도스의 dir에 해당하는, 파일 리스트 보기 'ls' 명령어을 통해
명령어에 대한 개념을 익혀보자. 다음은 "abc"란 파일의 정보를 자세히
보고자 한 경우다.

          % ls  -l  abc
         -+ -+- -+- -+-
          |  |   |   +-- 파라메터(파일명)
          |  |   +----- 옵션(l=long;자세한 정보)
          |  +-------- 명령어
          +----------- 프롬프트

    박스처리
    -------------
    한 번으로 여러 번을...
    - 메타문자 -

    유닉스 셸에서 메타문자들를 이용하면 한 번의 작업으로 다양한 파일을
지정할 수 있다. 도스의 와일드카드에 해당한다. 기본적인 메타문자와 그
의미를 아래에 정리했다.

    ----------------------
     *     0개 또는 그 이상의 모든 문자와 대응
     ?     정확하게 하나의 문자와 대응
     []    리스트 또는 명시한 범위 내의 모든 문자와 대응
     {}    명시한 리스트 항목으로 대치
     ~     사용자의 홈디렉토리
    -----------------------


    ■ 디렉토리 구조

    유닉스는 트리(Tree) 구조의 디렉토리에 파일들이 배치되어 있다.
도스의 디렉토리도 알고보면 유닉스에서 따온 개념이다. 디렉토리
경로(path)는 도스서는 '\'로 구별하지만 유닉스서는 반대로 '/'를 사용한다.
도스의 루트디렉토리인 "C:\" 는 유닉스에서는 "/"다.
    하지만 유닉스는 루트디렉토리와 각 사용자들의 홈디렉토리를
구별한다. 따라서 일반 사용자가 접속하면 루트디렉토리가 아니라 자신의
홈디렉토리로부터 시작한다. 그 이유는 유닉스가 기본적으로 여러 사람이
함께 사용하는 시스템이기 때문이다. 홈디렉토리서는 자신의 파일이나 서브
디렉토리를 만들고 작업을 할 수 있다. 예를 들어 soback.hana.nm.kr
호스트의 gglim이라는 계정의 홈디렉토리는 '/user2/staff/ggilm'인데 자신의
홈디렉토리를 $HOME이나 ~로 표현한다. 자신의 홈디렉토리로 바로
이동하려면 'cd(Changer Directory)' 명령을 이용해 다음 3가지 방법으로 쓸
수 있다.

        % cd  /user2/staff/gglim
        % cd  $HOME
        % cd  ~


    파일관련 유닉스명령어

    이번에는 유닉스 시스템에서 파일 조작과 관련된 주요 명령어들을 살펴
보자. 도스에서는 파일이름은 ????????.???로 길이와 형식이 지정되어
있으나 유닉스에서는 그러한 제약이 없다. 그러므로 파일이나 디렉토리
이름은 자신이 원하는 대로 만들 수 있다. 예를 들어
"i_am.LimGyooGun-입니다" 등의 파일이름이나 디렉토리 이름이 가능한
것이다. 하지만 인터네트서도 표준화된 확장자가 몇몇 있다. <표 1>에 주요
확장자를 정리해 두었다.

    -----------------------------------------------------------------
           확장자                     확장자 의미
    --------------------- -------------------------------------------
          love.doc              도큐먼트(텍스트) 문서
          love.tar              tar라는 형식으로 압축되어 있는 파일.
                                 ('tar -xvfp'로 푼다)
          love.Z                compress로 압축되어 있는 파일
                                 (uncompress로 푼다)
          love.txt              텍스트 파일
          love.ks               KS완성형 코드로 된 한글 파일
          love.gif              gif 포맷 그래픽 파일
          love.ps               포스트스크립트형식의 그림파일
          love.au               오디오 파일.
                                ('cat love.au > /dev/audio'로 듣는다)
      ---------------------------------------------------------------
     표 1. 유닉스 파일의 확장자와 그 의미


    ■ ls 명령어

    ls는 파일의 목록을 보는 명령어로 가장 많이 쓰인다. 도스의 d  에
해당하는 ls 명령어에는 40 여개가 넘는 옵션이 있다. 그 중 가장 많이 쓰는
중요한 옵션은 다음과 같다, 옵션은 '-lt' 식으로 조합해 사용할 수도 있다.

    ------------------------------------------------------------------
      -F  파일의 유형을 나타내는 기호를 파일명 끝에 표시(디렉토리의 경
          우 "/", 실행파일의 경우 "*", 심볼릭 링크파일의 경우 "@"를)
      -l  파일에 관한 더 상세한 정보를 출력
      -a  dot 파일(.cshrc 등)을 포함한 모든 파일을 리스트
      -t  파일이 생성된 시간별로 리스트
    ------------------------------------------------------------------

    ■ cat 명령어

    cat은 특정파일을 읽어서 화면에 출력하는 명령으로 도스의 TYPE
명령과 같지만 그외에도 다양한 용도가 있다.

          ◆ 파일의 화면 출력
             % cat 파일명

          ◆ 파일의 생성
             % cat > 새파일명
             ...
             파일의 내용을 입력
             ...
             ^D (입력종료:Ctrl+D키)
             %

          ◆ 복수개의 파일을 하나의 파일로 결합
             % cat 파일1 파일2 파일3 > 새파일명

          ◆ 한 파일에 다른 파일을 붙이기
             % cat 파일1 >> 파일2


    ■ mv 명령어

     mv는 파일이나 디렉토리의 위치를 옮기거나 이름을 바꾸는데
사용된다. 디렉토리를 mv시키면 그 디렉토리 밑의 서브디렉토리들과 파일
모두가 옮겨진다.

          ◆ 이름변경
             % mv 원래파일명 새파일명

          ◆ 파일의 위치 변경
             % mv 파일명 디렉토리명

          ◆ 디렉토리 위치 변경
             % mv 원래디렉토리명 새디렉토리명


    ■ cp 명령어

    파일을 복사하는 명령어로 도스의 copy와 같은 기능을 한다. '-r'
옵션을 붙이면 그 밑의 모든 서브 디렉토리의 내용까지 복사한다.


┌─────────────────────────────────┐
│% cp file.org file.cp       ; file.org를 파일 file.cp로 복사      │
│% cp file.org ../doc        ; doc이 디렉토리일 경우 ../doc 디렉토 │
│                              리에 file.org 란 이름으로 복사된다. │
│% cp file.org ../doc/file.cp ; ../doc 디렉토리에 file.cp 로 복사  │
│% cp -r /usrme/work         ; /usr 밑의 모든 파일과 디렉토리 구조 │
│                              가 /home/work 으로 copy 된다.       │
└─────────────────────────────────┘

    ■ rm 명령어

    rm은 파일을 삭제하는 명령어로 도스의 DEL에 해당한다.


┌─────────────────────────────────┐
│  % rm a.dat         ; a.dat 파일 삭제                            │
│  % rm -r ../doc     ; ../doc 디렉토리 밑을 모두 삭제 (recursive) │
│  % rm -i a.*        ; "a"로 시작하는 모든 파일을 일일이 삭제할   │
│                       것인지 확인하면서 삭제 (interactive)       │
└─────────────────────────────────┘

    ■ more/head/tail 명령어

    more 명령은 한 화면이 넘는 파일을 한 화면 단위로 보여준다.
스페이스바를 누르면 다음 화면으로 넘어가고 "q"를 누르면 출력을
중간에서 종료한다. 이 외에도 많은 more 의 내부 명령어가 있으며 이들에
관한 간략한 설명은 "h" 를 누르면 얻을 수 있다.
    head(tail) 명령은 파일 앞부분(뒷부분)을 출력해준다. "-" 다음에
파일의 앞(끝)에서부터 출력을 원하는만큼 행 수를 기입할 수 있다. 이
명령은 파일 내용을 간단히 살펴볼 필요가 있을때 사용한다.

    % head letter.doc      ; letter.doc의 앞의 몇줄을 출력
    % tail -100 letter.doc  ; letter.doc 파일의 마지막 100 행을 출력


    ■ chmod 명령어

    유닉스에서는 각 파일과 디렉토리마다 이용권한이 있는 사용자와 없는
사용자를 구분한다. 일종의 보안 유지 차원과 자원의 활용을 위해 구분하는
것이다. chmod 명령어는 사용자에 대한 파일의 접근을 제한하는데
사용된다. 유닉스에서 각 파일은 읽기(r, read), 쓰기(w, write), 실행(x,
executiuon)에 관한 권한을 소유자(u, user), 그룹멤버(g, group),
일반사용자(o, other)로 나누어 할당한다. <표 2>는 "love.doc" 파일에 대한
"ls -l" 명령을 수행해 그 파일의 상세정보를 보여 주고 있다.

┌──────────────────────────────┐
│  -rwxrwxrwx  gglim  staff  9633  Jan 12 10:15 love.doc     │
│   | || || |  -----  -----  ----  ------------ --------     │
│   +-++-++-+  소유자 그 룹  크기   마지막 갱신  파일명      │
│    u  g  o     u      g                                    │
└──────────────────────────────┘
    표 2. 유닉스 시스템에서는 파일과 디렉토리를 소유자(u), 그룹멤버(g),
일반사용자(o)로 나누어 이용권한을 부여한다.


    <표 2>에서 제일 처음의 "-"는 일반 파일을 의미하는 것이며
디렉토리일 경우에는 "d"로 표시된다.
    chmod 명령의 사용법은 다음과 같다.

      +--------------------------------------------------+
      |    chmod [augo][+-=][rwx] 파일명                 |
      |            -+--  -+-  -+-                        |
      |        +----+     |    ---------+               |
      |        | +-a all  |  +-+ add     | +-r read      |
      |        +-+ u user +--+ - remove  +-+ w write     |
      |          | g group   +-= set       +-x excute    |
      |          +-o other                               |
      +--------------------------------------------------+

    실제 사용 예를 보이면 다음과 같다.

       % chmod u+x love.doc ; love.doc 파일의 소유자에게 실행할
                              수 있는 권한을 부여
       % chmod go-rwx *     ; 모든 파일에 대해 그룹/일반 사용자
                              에게 모든 권한을 없앰


    ■ grep 명령어

    grep은 파일 내에서 특정 항목을 찾는데 이용되는 명령어으로 'grep
찾을내용 파일명'의 형식으로 사용된다. grep의 첫번째 파라메터는 찾고자
하는 내용에 대한 표현식이고 나머지 파라메터는 찾을 파일명들이다. 사용
예는 다음과 같다.
    % grep xterm *.doc ; '.doc' 으로 끝나는 모든 파일에서
                          'xterm'을 포함하는 모든 행을 출력









                                   GNU 선언문

Copyright (C) 1985 Richard M. Stallman  (Copying permission notice at the end.)

  GNU란 무엇인가? Gnu's Not Unix!

  GNU는 유닉스와 완벽하게 호환하는  소프트웨어 시스템이며 사용가능한  모든이가 무료로  사
용
하도록 작성한  것이다. 몇몇   다른 자원자들의  도움이 있었으며,  많은 시간적, 금전적  지원과
프
로그램과 장비가 절실히 필요한 상태이다.

  우리는 문서 형식기로  TeX를  사용할 것이며, nroff도  여전히 사용될 것이다. 또한,   X 윈도
우
시스템도 사용할 것이다. 이런 후에 Common Lisp, Empire, 스프레트시트 등과 수많은 다른 프로
그램을 온라인 문서를 포함하여 추가할  것이다. 우리는 결국, 일반적인 유닉스 시스템의 모든 기
능을 갖추게 될 것이다.

  지금까지 우리는 편집명령을  작성하기 위한 리스프를 갖춘  Emacs  문서 편집기,  소스수준의
디
버거, yacc호환 파서 생성기, 링커등 35개 가량의 유틸리티를 만들어 왔으며, 쉘(명령어 번역기)은
거의 완벽한 수준에 이르렀다. 최적화된 포터블 C 컴파일러가 새로이 제작되었으며 이번 해에 배
포될 것이다. 이미 처음의 커널이  있기는 하지만 유닉스를 구현  하기 위해서는 보다  많은 사양
들
이 추가되어야 할  것이다. 커널과 컴파일러가 완성되면 프로그램  개발에 적합한 GNU 시스템을
배포할 수 있을 것이다.

  GNU는 유닉스 프로그램들을  사용할 수 있게 해주지만 유닉스와  동일한 것은 아니다. 우리는
다른 운영체제에서의 경험을 살려 가능한 사용하기 편리하도록 향상을 꾀했다. 특히, 긴 파일명을
쓸수 있게 하고, 파일   버전넘버를 달고, 견고한 파일시스템을 구축하고, 터미널   비의존적인 디
스
플레이 장치를 만들 계획이며 최종적으로 몇개의 리스프 프로그램과 일반적인 유닉스 프로그램이
한 화면을 나누어  쓸  수 있는 리스프 기반의  윈도우 시스템을 만들 것이다. 시스템   프로그래
밍
언어로 C와 리스프 두가지를 다 사용할 수 있을 것이다. UUCP, MIT Chaosnet, 인터넷 프로토콜
을 지원할 것이다.

  GNU 는 본래 가상메모리를 가진  68000/16000 계열의 컴퓨터를 겨냥하고 제작되었다. 그 까닭
은 그 기계들에서 GNU를 가장 쉽게 작동시킬  수 있기 때문이다. 보다 작은 컴퓨터에서 작동 시
키기 위해서는 사용하고자 하는 사람이 특별한 노력을 기울여야 할 것이다.

  심각한 혼돈을 야기할 수 있기 때문에 'GNU'가 이 프로젝트를 지칭 할 때는 반드시  'G'를 발
음해주기 바란다.


  나는 누구인가?

  나는 리처드 스톨맨이란 사람이며 Emacs 에디터의 고안자이다. 나는 컴파일러, 에디터, 디버거,
명령어 해석기,  시분할체제와  리스프머신 운영체제에  관해 광범위한 작업을 해왔으며,   ITS에
서
터미널 비의존적인 출력장치를   개발했다. 그런 다음 리스프기계를 위한 견고한(crashproof)   파
일
시스템 하나와 두개의 윈도우 시스템을 구현했고, 지금은 세번째 윈도우 시스템을 구상했으며, 이
것은 GNU는 물론 다른 많은 시스템에 이식될 것이다.


  왜 GNU를 작성해야만 했는가?

  어떤 프로그램을 좋아 한다면 당연히 그것을 좋아하는 사람들과 함께 나누는 것이 황금률(대우
받고자 하는 데로 대하라.-성서)이라고  생각한다.  소프트웨어를 판매하는 사람들은 사용자를 각
각 구분하고, 그들위에  군림하고,  사용자 서로가  프로그램을 공유하는 것을 막고자한다.   나는
이
런 식으로 사용자간의  결속이  깨지는 것을 거부한다.  나는 올바른 양심으로 비공개   협정이나
소
프트웨어 라이선스 협약에  서명할 수 없다. 여러해동안  인공지능  연구소에서 일하면서  그러한
경
향과 다른 박정한  일들에  저항해 보았지만 결국에는  그들의 승리로 끝나고 말았다.   내의지에
역
행하는 그런 일들이 일어나는 연구소에 나는 더이상 머무를 수가 없었다.

  내가 계속해서  명예를  손상시키지않고  컴퓨터를 사용하기위해, 공개되지않은   소프트웨어를
더
이상 사용하지 않고도 작업을 해나갈 수  있는 충분한 공개 소프트웨어의 본체를 만들 결심을 했
다.


  유닉스와 호환성을 가지는 이유

  유닉스가 이상적인 체제라고  생각하지는 않지만 제법 쓸만하다고  할  수 있다.  유닉스체제의
골
자는 훌륭한 것이며 나는 유닉스의 장점을  해치지 않고도 부족한 점을 메꿀 수 있으리라 생각했
다. 그리고 유닉스와 호환을 가지면 다른 많은 사람들이 적응하기에도 편리할 것이라 생각했다.





  GNU를 사용하는 방법

  GNU를 사용하는데 지역적인 제한을 받는 것은 아니다. 누구나 GNU를 수정하고 배포할 수 있
지만 어떤이도 GNU가   보다 널리 배포되는  것을 제한할  수  없다. 즉, 변경한 내용을  독점할
수
없다는 것이다. 나는 모든 버전의 GNU가 공개된채로 남아있기를 보장 받고 싶은 것이다.


  많은 다른 프로그래머들의 동참을 바라는 이유

  나는 그동안,  GNU에   흥미를 느끼고 돕고자 하는 많은 프로그래머들을 찾을 수   있었다. 많
은
프로그래머들은 시스템 소프트웨어가   상용화된 것을 불쾌하게  생각한다. 이렇게 함으로   해서
보
다 더 많은  돈을 벌 수는 있겠지만 일반적으로 이런  상황에서는 프로그래머들이 서로를 동지로
느끼기 보다는 투쟁해야할  대상으로 느끼게 된다. 프로그래머들  사이의  우정을 나타내는  가장
기
본적인 행동은  프로그램을 나누는   것이다.  이제는 전형적인 핵심으로  여기는 마케팅  협정은
프
로그래머들이 친구로서 다른   프로그래머를 대하는 것을 금하고 있다. 소프트웨어를   구입한 자
는
우정과 준법중 하나를  선택해야만 한다. 물론 자연적으로 많은  이들이 우정을 보다 중요시한다.
그러나 법의 존재가치를 인정하는 사람들은  어떤 결정을 내리든 편한  마음을 가질 수  없다. 그
들
은 냉소적이 되어 프로그래밍은 단지 돈을 버는 수단이라고 생각 하게된다.

  그러나 독점적인 프로그램들 대신 GNU를 사용하게되면, 우리는 모든이에게 온정을 가질 수 있
으며 법도 준수하게 된다. 게다가 GNU는 영감을 주는 예와 다른이가 우리와 나누는 일에 동참하
도록 고무하는 깃발  노릇도  한다. 이는 우리가 상용프로그램을  쓸 때는 느낄 수 없는   조화로
운
느낌을 갖게한다. 나와 대화한 프로그래머들 중 거의 반정도는, 이것은 돈이 대신할 수 없는 중요
한 행복이라는데 공감했다.


  당신이 기여할 수 있는 방법

  나는 제조업자들에게는 기계와   돈을, 개인들에게는 프로그램과 노동을 지원해 줄   것을 요청
한
다.
  컴퓨터를 기증해서 기대할 수 있는  중요한 점은 GNU가 머지않아 그 기계에서  작동 할  것이
란
점이다. 기증된 컴퓨터는 완전해 질 것이며, 따라서 시스템을 사용할 준비를 모두 갖추게 되어 파
워와 효율을 과대 포장할 필요가 없을 것이다.

  나는 GNU를 위해 시간제로 일하기를 갈망하는 많은 프로그래머들을 찾을 수 있었다. 대부분의
프로젝트에서 그러한 시간제로   배치된 작업을 통합하고 조정하는 일은 매우   어려웠다. 독립적
으
로 쓰여진 부분들은 함께  동작하지 않았다. 그러나 특정한  작업인 유닉스를  대치하는 과정에서
는
그러한 문제가 생기지 않았다.  완전한 유닉스 시스템은 개별적인  설명이 포함된  백여개의 유틸
리
티를 포함한다.

  대부분의 인터페이스 사양은   유닉스에 호환되도록 맞추어  진다. 만약 각각의   프로그래머가
유
닉스 유틸리티 한개를 유닉스에 호환하도록 재구현하고 본래의 유닉스 시스템에서 충분히 작동하
게 할 수 있으면, 이것들은 함께 묶어 놓아도 올바르게 작동할 것이다.  만일 누군가가 예기치 못
했던 문제를  야기시킨다 해도, 전체적인  구성요소들을 통합하는 작업은  충분히 가능할 것이다.
(커널을 만드는 작업은  세밀한  대화가 필요할 것이며,  소수의 호흡이 잘  맞는  집단이 적당할
것
이다.)

  만일 내가 금전적인  지원을 얻는다면, 약간의 인원을 전시간  또는  시간제로 고용할 수  있을
것
이다. 일반적인 프로그래머  수준의 높은 봉급을 줄 수는 없겠지만,  돈이 가지는 것 만큼 공동체
의식을 정립하는 일도 중요한 의미를 가진다고 생각하는 사람들을 찾아 볼것이다.


  모든 컴퓨터 사용자가 이득을 얻게되는 이유

  일단 GNU가  작성되니까,  마치 공기처럼, 모든  사람들이 훌륭한 시스템 소프트웨어를   무료
로
얻을 수 있게 되었다.   이것은 단지 모든 이에게 유닉스 저작권에  대한 비용을 덜어  주는 것보
다
훨씬 더 많은 의미를   가진다. 이는 시스템 프로그래밍에 드는 노력이 불필요하게   중복되는 것
을
피할 수 있음을 의미한다. 대신, 절약된 노력은 기술 수준을 향상시키는데 사용 될 것이다.

  완벽한 시스템 소스가 모든 사람들에게 제공될 것이다. 결과적으로, 시스템에 변화를 주고자 한
다면 언제든지 스스로 자유롭게   수정할 수 있을 것이다. 혹은 적당한 프로그래머나   업체에 의
뢰
할 수도 있을  것이다.  사용자들은 더이상 프로그램  소스를 가진 프로그래머나 회사에   의존하
지
않아도 될 것이며 독자적으로 수정을 가할 수 있을 것이다.

  학교는 모든 학생들이 시스템 코드를  배우고 향상시키도록 장려함으로써 보다 나은 교육 환경
을 조성할 수  있을 것이다. 하버드 컴퓨터 연구소에서는  어떤  프로그램이든지 그 소스가  공개
전
시 되지 않으면  시스템에 설치하지 못하게 하는 정책을  쓰곤  했다. 실제로 어떤  프로그램들을
설
치하지 못하게 함으로써 이 정책을 고수 했다. 나는 이것에서 커다란 영감을 받게 되었다.

  결국에는, 누가 시스템 소프트웨어를  소유하고 있으며 누구에게 사용할  수 있는  자격을 부여
할
것인지 아닌지를 고려하는 제비용은 상승하게 될 것이다.

  복사 라이센스를 포함하여 프로그램 사용에 대한 지불을 준비할때는 언제나 개인이 지불해야할
돈이 얼마인가를 알아내야  하는 필요성을 통하여 사회에 많은  비용을 야기시킨다. 그리고, 오직
경찰 당국 만이  모든 사람이  그것을 따르게 하도록 힘을  행사할 수 있다.  막대한   비용을 들
여
공기를 생산하는 우주정거장을  생각해보자. 이런 경우 각각의  개인은  자신이 호흡하는  공기에
대
해 리터단위로 요금을  지불 하는 것이 합당할 것이다.  그렇다고는  해도 호흡하는 공기의  양을
계
측하기위해 메터기가 달린 방독면을 밤낮으로 쓰고 있어야 한다면 그런 방식은 타당한 것이 아니
다. 그리고 TV 카메라는 당신이   마스크를 벗는 불법을 행하는지 어디서나 지켜 보아야 할   것
이
며 따라서, 이것 보다는   사람수에 따라 일정한 세금을 부과하고 마스크를 벗어던지는   것이 현
명
하다.

  프로그램의 일부 혹은 전체를 복사하는 행위는 프로그래머에게 있어서는 숨을 쉬는 것만큼이나
자연스러운 일이며 생산적이다. 따라서, 프로그램은 마땅히 공개되어야 한다.


  몇가지 GNU의 목표에 대한 반대 의견

  "무료라면 아무도 그것을  쓰지 않을 것이다. 왜냐하면  무료라는  것은 어떠한  지원도 기대할
수
없다는 것을 의미하기 때문이다."
  "당신은 그 프로그램에 대한 지원과  도움을 제공하는 댓가로 이에 관한 비용을 부과해야만 한
다."

  만약 사람들이 돈을 지불하고서  GNU에대한 서비스를 받기를 희망한다면, GNU를  무료로  얻
은
사람들에 그런 서비스를 제공하는 회사도 이익을 얻을 수 있을 것이다.

  우리는 반드시 실제 프로그래밍   작업과 단순 관리 작업은 구별해야 한다. 전자는   때때로 소
프
트웨어 판매 회사에게  의존할 수가 없다. 만일 당신의  문제가  충분한 사람에 의해  나누어지지
않
는다면, 회사는 잊어버리라고 말할 것이다.

  만일 당신의 사업이 지원에   대한 의존이 필요하다면, 가능한 필요한 모든 소스와   도구를 갖
아
야할 것이다. 그러면, 당신은 당신의  문제를 해결해 줄 수  있는 사람을 고용할  수 있으며, 이것
은
다른 어떤 사람의 자비를 받는  것은 아니다. 유닉스상에서, 소스의 가격은 대부분 고려되지 않으
며, GNU는 더 쉬울 것이다. 이것은 여전히  유능한 사람이 필요 없을 수는 있으나, 이 문제는 배
포에 따른 비난을  할 수  없다. GNU는 모든  세계의 문제를 제거하는 것은 아니며, 단지   그중
하
나이다.

  한편, 컴퓨터에 대해 전혀 모르는  사용자들은 여전히 단순한 관리 서비스를 필요로 한다. 이러
한 일은 사용자 스스로 능히 처리할 수 있는 종류의 일이지만 그러한 방법을 모르기 때문이다.

  이런 서비스들은 단순한 수작업이나  복구 서비스를 지원하는 회사들이  제공할 수  있다. 사용
자
들이 제품을 사고 그에   대한 서비스를 받는 방식을 받아들인다면, 제품을 무료로   받고 서비스
에
대한 비용을 지불하는 방식에도  기꺼이 동의할 것이다. 서비스를  제공하는 회사들은  가격과 질
적
인 면에서 모두 완벽을 기할 수 있을 것이며 사용자들은 어떤 특정한 업체에 얽매일 필요는 없을
것이다. 또한, 그러한 서비스가 필요하지  않은 사람들은 서비스에 대한 비용을 들이지 않고도 프
로그램들을 쓸 수 있을 것이다.


  "광고를 하지 않고는 많은  사람들에게 알릴 수 없을  것이며, 그러기  위해서는 필히 프로그램
에
가격을 매겨야 한다.
  "무료로 제공되는 프로그램을 광고하는 것은 무의미하다."

   GNU 같은 프로그램을  많은 컴퓨터 사용자들에게 알릴 수  있는 방법에는, 무료,  혹은  극히
적
은 비용으로 사용할 수 있는  다양한 공공 정보 전파 방식이 있다.  그러나 광고를 하는  것이 보
다
많은 마이크로 컴퓨터 사용자에게 알릴  수 있는 방법일지도 모른다.  만일 실제로 이런  것이 사
실
이라면, 복사와 배포를  하는데  돈을 받음으로써 능히  광고와 그외의 부수적인 비용을   감당할
수
있을 것이다. 이런 방식에서는, 광고를 보고 배포본을 구입해서 이익을 얻을 수 있는 사용자가 광
고 비용을 부담하게 되는 것이다.

  반면, 많은  사람들이  GNU를 그  친구들을 통해서   구한다면, 이런 종류의 회사들은  성공할
수
없을 것이다. 이는    GNU를 보급하는데 광고가  필요한 것은 아님을 보여준다. 그렇다고   한다
면
무료로 보급되고 있다는 사실이 무료로 알려지는 것을 바라지 않을만한 이유가 있겠는가?


   "나의 회사는 경쟁사들에 대한 우위를 차지하기 위해 독점적인(고유의) 운영체제가 필요하다."

   GNU는 시스템 소프트웨어 경쟁이라는 범주에서 제외될 것이다. 당신의 회사가 우위를 차지할
수 없는 것처럼, 당신의 경쟁사들도 그점에 있어서는 마찬가지일 것이다. 당신과 당신의 경쟁사들
모두 이 분야에서는  별반 이득을  볼 수 없겠지만,  다른 분야에서 서로 경쟁하는 것은   가능할
것
이다. 당신의 사업이 운영체제를 판매하는 것이라면, GNU가 마땅치 않게 생각 될 것이다. 당신의
사업이 이런 종류가 아니라면, GNU는 시스템  소프트웨어에 관련된 막대한 비용을 절감해 줄 것
이다.

  나는 제작자와 사용자들이 GNU의  발전에 기여해 나감으로써 서로의 비용을  절감할 수  있기
를
희망한다.


  "프로그래머는 그의 창의력에 대한 보상을 받을 자격이 있지 않은가?"

  보상받을 만한 일이란 사회적   공헌을 말한다. 창의성이란 그 결과물을 사회가 댓가   없이 사
용
할 수 있을 때 사회적   공헌이 되는 것이다. 어떤 혁신적인 프로그램을 제작한 사람이   그에 대
해
보상을 받아야만 한다면,    같은 맥락에서 그것을 자유롭게 사용하지 못하게 한다면   그때는 제
재
를 받아야 할 것이다.


   "프로그래머는 그의 창의력에 대한 보상을 요구할 수 없는가?"

  유해한 수단을 사용하지  않는다면,  노동에 대한 보수와  자신의 소득이 극대화 되기를   바라
는
것은 아무 문제가 없다.   그러나 지금 까지 소프트웨어 산업에서 보편화된 수단은   유해한 방법
이
다.

  프로그램을 사용하는 것에 제한을 둠으로써 돈을 벌어들이는 행위는 프로그램이 사용되는 범위
와 방식을 제한하기 때문에   유해한 것이다. 이는 인간들이 프로그램으로부터 얻을 수   있는 전
체
적인 풍요로움을 감소시키는 것이다.

  선량한 시민이라면 자신이 보다 부유해지기위해  그런 수단을 쓰지 않는다. 그 까닭은, 만일 모
든 사람들이 그렇게  한다면 상호간의 유해한 행위로 인해 결과적으로  우리 모두는 보다 빈곤해
질 것이기 때문이다.  이것은 칸트의 윤리학이나 황금율같은 분명한  것이다. 나는 모든 사람들이
자기만의 정보를 축적해나가는 것은  바람직하다고 여기지 않기 때문에,  누군가 그런  일을 한다
면
나는 그것이 잘못된 일이라고 생각할 필요를 느끼게 되었다. 특히, 한 개인의 창의성을 보장 받고
자하는 욕구가 일반적으로 전체의 창의성이나  혹은 그 일부분을 저하시키는 행위를 정당화 시키
지는 않는다.


  "프로그래머들의 밥줄이 끊기지 않을까?"

  나는 모든 사람이 프로그래머가   될 필요는 없다고 답하고 싶다. 아마 우리들   대부분은 거리
에
나가 인상을 써서 간신히 약간의 돈을 벌어 살아갈 수는 없을 것이다. 그러나 결과적으로, 우리는
거리에 나가 인상 써서 돈을 번다고  비난 받을 필요도 없고, 또한 빈궁해질 필요도 없을 것이다.
우리는 그와는 다른일을 할 수 있을 것이다.

  그러나 이것은, 프로그래머는 소프트웨어를  소유하지 않으면는 단 한푼도  벌수 없다  라는 질
문
하는 사람의 독단적인  가정을 받아 들였다는 점에서 오답이라 할  수 있다. 아마도, 이런 생각은
극단적일 것이다.

  프로그래머가 생계에 지장을 받지   않을 것에 대한 진정한 이유는, 지금과 같은   정도는 아니
겠
지만 여전히 프로그래밍으로 돈을 벌 방법들이 있기 때문이다.

  프로그램 복사를 제한하는  것이  소프트웨어 사업의 유일한  기본 방침은 아니다. 이런   방침
이
보편화된 것은 이렇게 함으로써   가장 돈을 많이 벌 수 있기  때문이다. 고객들에 의해  이런 방
식
이 거부되거나 금지된다고   해도, 소프트웨어 사업은 지금까지 흔하지는 않았던   새로운 조직체
계
로 전환해 나갈  길을 모색할  수 있을 것이다.  여러가지 사업을 한데 묶어 조직화하는   방법은
무
궁 무진한 것이다.

  아마 새로운 기반하에서의  프로그래밍은 지금처럼 수익성이 높은  일은  아닐 것이다.  하지만
이
것이 변화의 쟁점은 아니다.   지금의 판매 사원들이 그들의 봉급을 버는 방식이   불합리한 것이
라
고 생각하지는 않는다.   프로그래머들이 그와같은 방법으로  소득을 올린다해도 하등   정당하지
못
할 이유가 없다. (실제적으로 프로그래머들은 여전히 그들보다 월등히 많은 소득을 올리고 있다.)


  "누구든 그들의 창의력이 사용되는 방법을 지배할 수 있지 않은가?"

  "인간 생각의 쓰임새를 지배하는 것"은 실제적으로는 그의 인생을  지배하는 것이다. 이는 자신
의 인생을 보다 어렵게 만들곤 한다.

  지적 소유권에 관해 상세하게   공부한 사람들(변호사 등)은 그 자체로서 완벽한   지적 소유물
을
없다고 말한다. 정부가 인정하는  추상적인 지적소유권들은 특정 목적을  위한 특정  법률 조항으
로
부터 발생한 것이다.

  예를 들어, 특허제도는   발명가가 그의 고안품의 세부사항을 공개하는 것을   장려하고자 설립
된
것이다. 그 목적은   발명한 사람을 돕기보다는 사회를  돕기  위한 것이다. 시간의  측면에서 보
면,
특허가 갖는 17년간의 유효기간은  기술이 발전하는 비율과 비교해  볼때 짧다.  특허권은 생산업
자
들 사이의 문제이고, 생산을 향상  시키는 것과 비교해서 특허권  계약에 드는 비용과  노력은 작
다
고 보기 때문에, 특허권은   일반적으로 그다지 해악하게 작용 하지는 않는다. 또한,    그것은 대
부
분의 개인들이 특허 받은 제품을 사용하는 것을 제한하지는 않는다.

  고대에는 저작권이라는 것이 존재하지 않았으며  그 시대에 작가들은 빈번하게 다른 이의 작품
상당량을 실제의 (허구가  아닌)  작품에 복제하기도 했다.   이런 작업들은 유용한   것이었으며,
비
록 그 일부분이기는  하지만 많은 사람들의 작품이  게속해서 전수  되는(존재해 나가는)  유일한
방
법이었다. 저작권 제도는 작가의식을 고취 시키고자 급진적으로 만들어진 것이다. 이것이 처음 만
들어 질 때 주로 염두에  두었던 책의 범주에서 보면,  책은 실용적인 측면에서  인쇄기를 사용해
서
만이 복사가 가능 하기 때문에 저작권은 그다지 해롭지는 않았다. 또한,  대다수의 사람들이 책을
읽는 것을 제한하지도 않았다.

  모든 지적 소유권은,   그것들이 어떻던지 그를 허용함으로써 사회전체에 이득이   된다고 여겨
져
서, 사회가 허용할 때만 정당하게 되는  것이다. 그러나 어떤 특정 상황에서든 우리는 "그런 인가
를 내주는 것이 정말로 우리에게 유익한가? 어떤 종류의 인가를 내줄 것인가?" 하는 질문을 해보
야만 한다.

  오늘날의 프로그램들의 경우는   백여년전의 책의 경우와  크게 다르다. 프로그램이   이웃간에
손
쉽게 복사될 수 있다는  사실,  소스 코드와 목적 코드로  구분된다는 점,  읽기위한 것이 아니라
즐기기 위한 것이라는 사실들이  묶여져서, 저작권을 강요하는 사람들이 전체사회에 정신적, 물질
적으로 해를 끼치는 상황을 만들고 있다.


  "경쟁 함으로써 보다 나은 결과를 얻을 수 있는가?"

  모범적인 경쟁 방식은 경주(race)  이며, 승자에게 상을 줌으로써 주자들이 더욱 빨리 달리도록
장려할 수 있는 것이다. 만약 자본주의가 실제로 이런 방식을 따른다면 이는 바람직한 것이다. 그
러나 자본주의 옹호론자들은  실제로 항상 이런 방식으로  움직인다고  단정짖는 잘못을  범한다.
만
일, 주자들이 상이  주어지는 이유를 망각한채 승리에만 집착한다면,  말할것도 없이 그들은 다른
주자를 공격한다든지하는 색다른 전략은 찾게 될 것이다.  주자들이 먼저 싸우기 부터 한다면, 그
들은 결국 모두 늦어질 수 밖에 없는 것이다.


  독점적이고 비밀에 싸인 소프트웨어는,  도덕적으로 먼저 싸우기 부터하는 주자들과 동일 하다.
슬픈 일이지만, 우리의 유일한 심판은 그다지  공정해 보이지 않으며, "매 10 야드마다 한번씩 상
대방을 가격할 수 있다."   는 규정을 적용하는 정도일 것이다.  그러한 싸움이   있을 때는, 그들
을
떼어놓고 벌칙을 주어야하는데도 말이다.


  "금전적인 장려가 없다면 아무도 프로그래밍을 하지 않을 것이다."

  실제적으로, 많은 사람들이 분명한  금전적인 장려가 없이도 프로그래밍을 할 것이다. 프로그래
밍은 어떤 사람들에게는 저항할 수 없는 매력인 것이며 보통 프로그래밍에 능숙한 사람에게 더욱
그렇다. 비록 생활의  기반이  될 가망이 없더라도  꾸준히 계속해가는 직업적인 음악인들이   많
이
있다.

  그러나 실제로 질문은, 비록   일반적으로 많이 제기 되지만, 상황에 적합하지   못하다. 프로그
래
머들의 소득원이 없어 지는 것이  아니라 단지 수입이 줄어드는  것일 뿐이다. 따라서  올바른 질
문
은 "금전적인 보상이 줄어들더라도  사람들이 프로그래밍을 하게될까?" 일 것이다. 내  경험에 의
하면 그렇게 할 것이다.

  십년 이상 동안, 세계 정상급 프로그래머들이 인공지능 연구소에서 일했었지만, 그들이 받은 보
수는 다른 어떤 곳에서 기대할   수 있는 것보다 훨씬 적은 것이었다. 그들은 명성이나   감사 같
은
다양한 종류의 비금전적인  보상을  받았다. 그리고 창의력은  그 자체 안에 보상이라는   개념을
가
지고 있다는 점에서 흥미로운 것이다.

  그 후, 그들  대부분은 이전의 작업처럼 그들이 흥미롭게  생각하는  일을 높은 보수를  받으며
할
수 있는 기회가 주어지자 연구소를 떠났다.

  이 사실에서 알  수 있는 것은 사람들은 부유해지기 보다는  어떤 까닭을 위해서 프로그래밍을
한다는 것이며 그런 조건위에  상당한 보수까지 받을 기회가  주어진다면, 그를  예상하고 요구하
게
되는 것이다. 보수가  낮은 조직은 높은 보수를 받는 조직과의  경쟁에서 뒤지 겠지만, 만일 높은
보수를 받는 조직과는 상호이동이 없는  완전히 개별적인 집단이라면 그들 나름대로 훌륭하게 활
동할 것이다.


  "우리는 프로그래머가 절대적으로  필요하다. 만일 그들이 우리의  이웃을  돕지말라 하면 우리
는
따를 수 밖에 없다."

  당신들은  결코 그런 종류의 요구에 복종해야할 만큼 절박하지 않다. 명심하라. 열 장정이 도둑
하나를 막지 못하는 법이다.


  "프로그래머들도 어떤식으로든 그들의 생계를 꾸려 나가야 하지 않은가?"

  요컨데 이것은 진실이다. 그러나  프로그램의 사용에 대한 권리를  파는 것이외에도  생계를 꾸
릴
수 있는 수많은  방법들이  있다. 현재 사용에 대한  권리를 파는 것이 보편적으로 받아   들여지
는
것은 그런 방식으로 프로그래머나 사업자들이  보다 많은 돈을 벌  수 있기 때문이지,  결코 이것
이
생계를 유지하는 유일한  방법이기  때문은 아니다. 다른  방법을 찾고자 한다면 얼마든지   가능
할
것이다. 여기 여러가지 예들이 있다.

  새로운 컴퓨터를 내놓는  제조업자는 새 기계에 운영체제를  이식하기위한 비용을 지불하게 된
다.
  교육, 단순 관리 작업, 지속적인 서비스들을 제공하는 회사에서도 역시 프로그래머는 필요한 것
이다.

  사용자의 마음에  흡족하다면  그에 대한  보수를 지불해달라고 요구하는, 프리웨어라는   새로
운
아이디어로 프로그램들을 배포하는  사람들도 있다. 혹은 단순  관리  서비스를 제공하고  보수를
받
는 사람들도 있다. 나는 이미 이런 방식으로 성공한 사람들을 만났다.

  도움이 필요한 사용자들은  사용자  그룹을 결성하고 회비를  조성할 수 있을 것이다.   그룹은
프
로그래밍 회사와 계약을 맺고 회원들이 원하는 프로그램을 주문 제작할 수 있을 것이다.

  모든 종류의 발전에 필요한 기금은 소프트웨어 세로 조성할 수 있을 것이다.

  만약, 컴퓨터를 구입하는  모든 사람들이 가격의 x 퍼센트를  소프트웨어 세금으로 지불한다면,
정부는 그 돈을 소프트웨어 발전에 쓰여 지도록 NSF 같은 단체에 지원할 수 있을 것이다.

  그러나 컴퓨터 구입자가  개별적으로 소프트웨어 발전에 공헌을  한바가  있다면, 그는  세금을
면
제 받게 될 것이다. 그는 스스로  어느 프로젝트에 기부할 것인지를 결정할 수 있을 것이며, 때론
그 결과를 쓸 수 있을   것이란 기대를 품고 결정을 내리게 될 것이다. 얼마를   기부하든 지불해
야
할 세금 전액을 대신할 수 있을 것이다.
   세금의 전체적인 세율은 납세자들이  투표를 해서 결정할 수  있을 것이며, 지불할  액수에 따
라
차등 조정될 것이다.

  결론:
   * 컴퓨터 사용자 공동체는 소프트웨어 발전을 지원한다.
   *  어느 수준의 지원을 할 것인가는 이 공동체가 결정한다.
   * 자신의 몫이  어떤 프로젝트에 쓰일 것인가에 관심있는 사용자들은  이를 스스로 결정할 수
있을 것이다.

  결국에는, 프로그램을 무료로  보급하는  것은 더이상 단지  생계를 위해 고되게 일할   필요가
없
는 풍요로운  세계로  가는 한  단계인 것이다. 사람들은   프로그래밍 같은 자신이 흥미를  가질
수
있는 일에 자신을 몰입할 수   있는 자유를 갖게될 것이다. 법률이 규정하는 주당 열   시간 정도
의
시간을 마친 후엔, 가족들과  담소 한다든지, 로보트를 수리  한다든지, 천체를 관측하는  일 따위
를
하게 될 것이다.
  더이상 프로그래밍을 생계의 수단으로 삼을 필요가 없게 될 것이다.

  우리는 이미, 실제적인 생산성을  향상 시키기위해 전체 사회가  부담해야할 작업의  분량을 많
이
감소 시켰다.  이중 매우 적은 부분는 단지 프로그래머들의 유희를 위해서 작성되었다. 그 까닭은
비생산적인 활동은 생산적인  활동을  하기위해 필요한 것이기  때문이다. 이런 일을 하게된   주
된
이유는 경쟁을 대신할 수 있는  관료 정책이며 그와 동일한  부피를 갖는 몸부림인  것이다. 프리
소
프트웨어는 소프트웨어 생산 분야에서   생산력이 낭비되는 것을 크게 감소  시킬 수  있을 것이
다.
우리는 이러한 작업을 해나가야 하며, 생산성을 위한 기술 습득은 적은 노력으로 가능할 것이다.

  Copyright (C) 1985 Richard M. Stallman






