안녕하세요.

16번째 시간입니다.


우선 간단한 섹터 조작법을 소개합니다.

섹터를 조작함으로써 프로그램 내부를 뜯어보고 고칠수가 있다.
단순히 게임의 암호깨기나 레벨 올리기에 에 적용할수도 있다.
섹터 조작이야 말로 해킹의 기본이라고 할 것이다.

섹터

 섹터(sector)란?
     -파일을 나누는 단위가 되는 것으로,512개의 아스키 코드들이 조합된 단위이다.


섹터를 조작할수 있는 프로그램
  -Debug,Norton Disk Edit,PC-Tools등이 있는데 이 중에서 PC-Tools가 가장 많이 쓰여지고
   있다.
   PC-TOOLS 는 대부분 가지고 있을것이다.

섹터 조작전 이론 습득

컴퓨터의 내부를 보면 아스키코드와 헥스 코드로 나누어진다.
학교 다닐때 진수변환이란것에 대해 수학시간에 배웠을 것이다.
바로 그 진수를 제대로 알아야 에디트를 할수있다.

<< 10 진수 , 16 진수 >>

10진수는 사람이 사용하는 숫자이다
16,8,2진수는 보통 컴퓨터가 사용하는 숫자이다.
그러나 섹터는 알다시피 모두 16진수로 이루어져 있다.
먼저 10진수와 16진수의 개념을 설명 하겠다.
10진수 ??????????-->10개 16진수 ????????????????-->16개
10진수는 사람들이 보통 사용하는 숫자 이다.
10진수는 0,1,2,3,4,5,6,7,8,9 의 10개의 숫자로 이루어져 있다.
16진수는 16개의 숫자로 이루어져있다.
이렇게 "0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F" 말이다.
F 가 16진수에서는 가장 큰 수 이다.
비교 해보면..

   -------------------------------------------
         10 진수      |      16 진수
   -------------------------------------------
           0          |         0
           1          |         1
           2          |         2
           3          |         3
           4          |         4
           5          |         5
           6          |         6
           7          |         7
           8          |         8
           9          |         9
          10          |         A
          11          |         B
          12          |         C
          13          |         D
          14          |         E
          15          |         F
   -------------------------------------------
          16          |        10
          17          |        11
          18          |        12
          .           |        .
          .           |        .
          .           |        .
          .           |        .
          .           |        .
                      |

섹터 조작의 실제 적용

섹터조작의 가장 간단한 방법인 게임을 이용해보자.

게임에서 돈을 늘리거나 롤플레잉 같은경우는 방어력 공격력 같은것을
에디터 할수가 있다.
만약 게임에서(롤플레잉)방어력이 10이고 공격력이 18이라고 하자.
이때 방어력과 공격력을 최대로 높일려고 한다.

  방어력 : 10
  공격력 : 18


첫째, 에디터할 대상의 숫자를 16진수로 고쳐라!
방어력 10 ---> A   공격력 18 ---> 12
둘째,이제 위의 상태처럼 PCTOOLS.EXE 을 실행 시키고 세이브 화일에서 'F'키를 누른
상태에서, 방어력의 숫자와 공격력의 숫자를 찾는다. 지금의 상태에서 'F1'을
한번더 누르면,커서가 아래쪽으로 넘어 간다.
16진수를 치고 엔터를 친다.


그럼 아마 화일중에서 지금 입력한 16진수를 찾는데 다음 두개의 명령이 보일것이다.
E:찾은 번지를 에디터 하는 것이고, G:다음 번지를 더 찾는 것이다.
만약 찾으면 E 를 눌러 그 번지의 섹터를 FF 로 고친다.
그다음 F5를 누르고 저장 하고 나온 다음 게임을 하면 된다.

섹터 에디트에서 유의할게 있다.
만약 02 b4 라는게 있다고 치면,
이게 프로그램에 저장될때는 반대로 b4 02 이렇게 뒤집어 진다는 것이다.

어떤 게임에서 각각의 개인별 레벨,돈등이  나타난다.
이걸 고쳐보자.
일단 자신이 정한 인물의 현재 수치값을 적어서 진수변환(10진수->16진수)
을 한다.
그러면 100은 60으로 10000은 2710이라고 답이 나올것이다.
대체로 능력치등의 값은 한곳에 몰려서 저장된다.
자 그럼 여기서 나온 16진수 값을 PC-TOOLS등의 에디트에서 연속적으로 나열
되어 있는곳을 찾으면 바로 여기가 그 값이 저장되어 있는곳이다.
이곳을 찾아서 자신이 원하는 값으로 고치면 되는것이다.

우선 기본적인 게임 섹터 조작을 선보였다.
응용하면 기존 프로그램의 암호등을 패치시킬수도 있을 것이다.
꾸준한 연습이 왕도이다.








쉐어웨어 크랙.
 요즈음 쉐어웨어라는 것으로 특히 통신망의 발달로 인해 많이 정착된 제도가 있다.
쉐어웨어라는 것은 프로그래머가 개발한 프로그램에서 어느정도의 제약을 두어 통신망
등을 통해 프로그램을 공개하고 사용자가 그 프로그램이 마음에 들면 프로그램에 첨부
된 등록서와 돈을 제작자에게 부치면 제작자는 해당 프로그램의 제약이 없어진 등록된
프로그램을 사용자에게 제공해주는 방식으로 중계자가 없어 가격이 싼 편이어서 요즈
음 굉장히 많이 쓰이는 제도이다.
 쉐어웨어의 등록 방식에 크게 두가지가 있는데 첫째는 등록버전과 비등록버전을 따로
두어서 사용자가 등록을 하면 제작자가 등록버전을 보내주는 방식과 비등록버전에서
등록신청을 하면 제작자가 패스워드를 보내주고 그 패스워드를 비등록버전 등록메뉴에
서 입력하여 등록버전이 되는 것이다. 그런데 해커들은 후자의 경우 프로그램을 해킹
하여 등록버전을 만드는 경우가 많이 있다. 어떻게 그렇게 할 수 있으며 그를 막을 수
있는 법을 알아보자. 여기서는 간단히 패스워드를 입력하여 등록시키는 경우에 대해서
만 설명을 해본다.

입력부분 찾기
 우선 패스워드를 입력하는 부분을 찾아야 하는데 대개는 바이오스의 키보드 인터럽트
를 사용하므로 Interrupt 16h의 호출을 추적하면 된다. 이 경우 어느 정도 수준의 디
버거나 디스어셈블러 정도만 있으면 쉽게 찾을 수 있다. 좋은 디버거인 경우 패스워드
를 입력하는 부분에서 핫 키를 누르면 바로 나올 수도 있다.

비교부분 찾기
 입력 부분에서 Enter키를 검사하는 부분을 찾아 쫓아가보면 입력받은 암호와 실제 암
호를 비교하는 루틴이 나온다. 암호가 맞는지를 검사하는 부분은 크게 두 가지로 나눌
수 있는데 첫째는 문자열을 가지고 계산을 하여 나온 결과를 가지고 비교하는 것과 문
자열 자체를 암호와 비교하는 것이 있는데 전자의 경우 대부분 숫자만으로 이루어진
암호에 속하며 후자의 경우 영문 또는 숫자가 들어간 코드 등이 대부분이다.
 후자의 경우는 CMPS 의 어셈블리어 코드를 발견하면 십중 팔구 맞으나 전자의 경우는
CMP를 찾아야 하는데 연산 중간과정에서도 CMP가 상당수 나올 수 있다. CMP를 발견하
기는 커녕 연산을 하여 결과를 어디에 저장하는지 조차 알기 힘들 때가 있다.
 우선 비교하는 부분을 찾으면 문제는 굉장히 쉬워진다. 비교한 결과만 조금 바꾸어주
면 되기 때문이다.

고치기
 비교하는 부분은 대부분 CMPS 또는 CMP 를 하나만 쓴 부분일 것이다. 그리고 그 아래
에는 비교결과가 같으면 분기하는 JZ(또는 ZE) 이나 틀리면 분기하는 JNZ(또는 JNE)의
어셈블리어 코드가 있을 것이다. JZ를 JMP로 고치거나 JNZ를 NOP로 고치면 무조건 맞
은 것으로 간주하게 된다. 디버깅 상태라면 CMP 또는 CMPS연산 수행 후에 Zero Flag를
세트해줘도 된다.
 문자열을 암호로 하되 검사를 한 자 한 자씩 하는 경우도 드물지만 있으나, 그 경우
에는 한 자 한 자 각각의 검사 루틴을 위와 같이 처리하면 된다.

쉐어웨어의 변형방지
 쉐어웨어 제작자들은 위와 같은 변형을 막기 위해 여러 가지 방법을 쓴다. 대부분 실
행화일을 못 고치게 따로 변형시키는 방법이다. 위와 같은 추적은 실행화일에 제대로
된 기계어 코드가 들어 있어야 가능하기 때문이다. 그러한 제작자들의 몇가지 변형방
법과 실례를 들어보겠다.

보통 변형
 이 방법은 제작자가 직접 프로그램의 실행 코드를 변형시키는 방법으로, 많이 쓰이지
는 않는 방법이다. 이 방법을 사용한 대표적인 프로그램에는 PCXDUMP 가 있다. 이 프
로그램은 프로그램 본 코드에 전부 1을 더하여 저장을 해 놓았다. 즉 5인 경우는 6으
로, 0인 경우는 1로, 255인 경우는 0으로... 그리고 처음 실행되는 부분에 그 부분에
서 다시 1을 빼어 실행하는 루틴을 붙여 놓았다. 그렇게 때문에 이런 프로그램의 경우
디스어셈블을 할 때 전혀 엉뚱한 결과가 나오게 되는 것이다. PCXDUMP의 경우는 간단
한 경우라서 실행화일을 보다가 "QDYEVNQ"라는 낱말을 보고 혹은 그 외에 알 수 없는
"Uijt!qsphsbn!jt!tibsfxbsf"등의 영문의 섞인 규칙적인 내용을 보고 대충 짐작할 수
가 있다. 앞의 경우는 "PCXDUMP"에 각각 1을 더한 경우이고 뒤의 것은 "This program
is shareware"라는 문장에 1을 더한 경우이다. 보통 이런 식으로 변형이 된 부분은 위
와 같이 내용이 규칙적일 수 있는 데이타 부분을 가지고 추정을 할 수 있다. 대부분의
실행화일은 데이타 부분이 화일 뒷쪽에 있으므로 병형된 코드의 뒷쪽을 유심히 보면
이 변형공식을 추정해 낼 수 있다.
 이를 변형하는 방법 중 가장 많이 쓰이는 방법이 비트 연산 중 하나인 XOR 연산을 쓰
는 것이다. A를 B로 XOR한 값 C는 A와 별로 관계가 없어 보이지만 C를 B로 다시 XOR하
면 A가 나오기 때문에 가장 많이 쓰이게 되는 방법이다. 이럴 때는 뒷부분의 문자열
데이타가 있을 만한 부분에서 " ", 즉 주기적으로 나오는 공백을 찾아서 역으로 원래
코드인 32와 XOR을 해보면 키가 나오게 된다.

실행 압축
 이 방법이 가장 많이 쓰이는 것으로 실행 화일을 압축하여 전혀 다른 코드로 만들어
버리는 방식이다. LZEXE나 PKLITE와 같은 유틸리티들은 EXE 등을 압축할 수 있는데,
이런 유틸리티로 자신의 실행화일을 압축시켜 놓으면 전혀 엉뚱한 코드가 되고 역으로
풀기가 굉장히 난해하여진다. 그러나 UNLZEXE나 PKLITE -x로 화일을 다시 풀 수 있기
때문에 제작자는 이렇게 압축되어진 화일의 헤더 중 고치더라도 별 손상이 없는 부분
을 고쳐서 UNLZEXE나 PKLITE 가 압축되어진 화일로 인식하지 못하게 한다. 이러한 방
법은 쉐어웨어 프로그램 등에서 많이 찾아 볼 수 있다. PKLITE의 경우는 등록버젼인
경우 -e옵션으로 풀리지 않게 압축하는 경우도 있다.
 이런 경우에 해결책은 헤더를 변경시킨 경우 다시 그 유틸리티가 인식을 할 수 있게
헤더부분을 되돌려 주는 방법 또는 PKLITE -e로 압축한 경우는 그것을 풀어줄 수 있는
dislite라는 유틸리티 등을 사용하면 된다. 정 안될 경우 코드 트레이서 등으로 해당
프로그램의 압축을 풀어 로딩하는 곳까지 추적한 후에 로딩된 프로그램을 저장하는 방
식을 생각해 볼 수 있으나, 그리 쉽지는 않은 방법이다.

어떻게 막을 수 있나
 제작자의 입장에서 어떻게 막을 수 있나를 생각해 보면, 이러한 자신의 프로그램의
변형을 방지할 수 있는 방법은 상당히 많으나 끝까지 막기는 상당히 어렵다고 볼 수
있다. 즉 웬만한 조치에도 성능이 좋은 코드 트레이서 등은 조치를 취하는 과정마저도
해커들에게 보여지기 때문에 완벽히 막는것은 정말 어렵다고 할 수밖에 없다.
 보통 디스어셈블링을 피하기 위해서 위와 같은 방법을 쓰되, 코드 트레이서나 디버거
를 피하기 위해서 다른 방법을 쓸 수 있다. 그중 첫번째 방법은 Interrupt 3을 프로그
램 안에서 고의로 일어나게 하는 것으로 대부분의 코드 트레이서나 디버거는 브레이크
포인터 등에 Interrupt 3을 쓰므로 추적시 충돌을 고의로 일으킬 수 있다. 또 다른 방
법은 타이머 등을 체크하여 원래 실행해야 할 시간보다 실행과정동안 경과한 시간이
더 지났는가를 검사하는 방식이다. 추적을 막는 방법에는 그 외 여러가지가 있으나 그
막는 과정도 프로그램화 되므로 완벽히 막기란 불가능하다고도 볼 수 있다.
 그러나 막는 루틴을 작성하는 것보다 해당 루틴을 해채하는 것이 몇배에서 수백배까
지도 어려워 질 수 있으니 최선의 방법은 각종 방법을 섞어서 쓰는 것이라고 할 수 있
겠다.

복제방지에 관한 간단한 설명
 이 것은 우리나라 소프트웨어에서 주종을 이루는 정품 소프트웨어들의 불법 복제 방
지를 위해 사용되는 것으로 많이 사용하는 만큼 굉장히 많은 종류가 있다.

복제방지의 종류와 설명
 복제방지 루틴은 크게 비표준 디스크 포멧, 고의적인 베드 섹터 내기, 설치/역설치
방법, 암호 입력방법등이 있고 그 방법마다 또 작은 갈래로 나누어져 있을 정도로 많
은 종류가 있다. 복제방지의 대부분의 방법은 실행시에 정품에 딸려오는 물건을 꼭 필
요로 하는 방법이다.
 또한 다른 관점에서 봤을 때, 키 디스크를 사용하여 소프트웨어를 실행할 때마다 키
디스크를 넣어야 실행이 되는 것, 설치 된 시스템에서만 실행이 가능하고 다른 곳으로
복사하면 실행이 안되는 것, 하드웨어적으로 장치를 해놓아 그 하드웨어의 유무를 체
크하는 방법, 암호를 입력받는 법, 아예 복사가 안되는 것 등으로도 나눌 수 있다.

비표준 디스크 포멧
 복제방지 방법 중 하나는 디스크를 처음 포멧할 당시 비표준으로 포멧하여 호환성문
제를 일으키는 방법이 있다.
 키디스크를 사용하는 예를 들자면 포멧 당시 40이나 80트랙인 트랙 수를 1~2트랙정도
늘려서 포멧해도 디스크에 물리적 손상이 가지 않게 되는대 이 때 1정도 트랙 수를 늘
려서 포멧한 후 늘어난 공간에 어떠한 마킹을 해 놓는 것이다. 그리고 프로그램 실행
시 키 디스크를 체크할때 그 마킹한 부분을 확인하는 것이다. 비표준 포멧으로 추가된
부분은 표준 영역이 아니기 때문에 디스크 카피로도 카피되지 않는다.
 아예 복사가 안되게도 할 수 있는데, 섹터 수를 조정하여 포멧하는 경우 디스크 카피
를 할때 전혀 엉뚱하게 카피되게 할 수도 있다. 화일 복사로도 복사가 되겠지만 화일
복사로는 디스크 전체의 내용으로 봤을 때 똑같이 카피되지를 않기 때문에 다른 사항
으로 검사할 수 있다.
 이런 식의 방식을 사용하는 프로그램은 아래아 한글 2.1 수검용 등이 있다. (아래아
한글 수검용은 디스크 카피가 불가능하다. 그러나 화일 카피로 카피할 경우 별 문제없
이 되기 때문에 문제가 있다고 할 수 있다.)

고의적인 베드 섹터 내기
 많은 정품 프로그램이 키 디스크 검사시 혹은 설치시 사용하는 방법으로 물리적으로
디스크의 일정한 곳에 손상을 주어 배드 섹터를 만든 후에 검사할 때 그곳을 읽어서
물리적 에러가 나는 지 검사하는 방식이다. 키 디스크를 사용하는 거의 모든 정품은
이 방법을 사용할 것이다. "이스" 같은 게임이 이 방법을 쓴다.

설치와 역설치
 설치 횟수가 정해져 있어서 2번 정도만 설치가 된다던가, 하드에 설치를 해 놓으면
역설치 프로그램으로 하드의 자료를 지울 때까지 다음의 설치가 불가능하게 하는 등의
방법으로, "웅진 터미네이터" 등의 프로그램에서 쓴다. 이 경우 설치할 때 시스템의
사항을 저장시켜놓았다가 실행할때 검사한 시스템의 사항이 저장된 사항과 맞지 않으
면 불법 복제로 간주하고 실행을 중지하는 루틴이 포함되어야 한다.

암호입력
 예전에 많은 프로그램이 이 방법을 썼고 지금도 KOEI사나 지관(유) 사에서 나온 소프
트웨어들이 이 방법을 많이 쓰는데 실행시에 암호를 입력하는 방법이다. 물론 암호는
정품에 포함시킨다. 이 암호를 입력하는 방법에도 KOEI사의 소프트웨어들 처럼 어떤
키에 해당하는 수를 넣으면 되는 것과 "요절복통기계"나 "탄생" 처럼 그림의 순서를
맞추어 고르는 방법, "이야기 6,1","페르시아의 왕자 I"처럼 메뉴얼 상의 단어를 묻는
경우 등 매우 다양하다.

대표적인 예를 들어보겠다.
 KOEI 사의 락은 섹터 체크방식의 키디스크 락인데 같은 루틴을 계속 사용하고 있다.
디스크인터럽트인 13h의 04h를 이용해서 AH에 리턴되는 값에 따라 판별여부를 가린다.
리턴되는 값을 al에 옮기고 ah는 클리어한다음 ax값을  스택에 PUSH 한다... 그후 나중에 cx레지
스터에 POP한뒤 jcxz명령을 이용해서 점프시킨다.
이쯤되면 리턴값이 0이면 정상적으로 게임이 된다는 것을 잘 아실 수 있을 것이다.
인터럽트 13H을 훅한뒤 0을 돌려주게 만들면 간단히 없어진다.
그런데 문제는 다른데 있는데 바로 라벨화일을 체크하는 것이다.
1번 디스크인지 아닌지  라벨화일 체크한답시고  도스펑션 3dh를  이용해 오픈했다가 그냥 Close
한다.
그래서 삼국지 3 같은거 하다보면 처음에 드라이브 A 에서 드르륵 읽는 소리가 나는 것이다.
문제는 이 3dh펑션입니다..  그냥 라벨화일을 오픈하기위한 펑션이아니고  화일의 offset을 바꿔서
쓰는 일종의 프로시져 형식으로 되어있다.
그래서 다른화일도 오픈하기때문에 이펑션을 없앨수도 없고, 참 골치가 아픈부분이다.
그래서 생각해낸것이 화일내에서 화일이름을 찾아 그걸 바꾸는 방법인데,
C:\에 있는 IO.SYS로 이렇게 고쳤더니 역시 생각대로 플로피디스크는 넣을 필요없이,
또 A드라이브도 체크않하게 완전히 되었다.



복제방법 깨기
 앞의 쉐어웨어 에디팅에서 말했듯이 프로그램을 못 고치게 하는데도 소프트웨어적으
로는 한계가 있다. 그러므로 위와 같은 경우도 쉐어웨어와 마찬가지로 깨지기가 어렵
다 하더라도 깨질 수는 있는 것이다. 그러나 쉐어웨어에서와는 달리 물리적인 방법이
많은 편인 이 방법들은 유독 프로그램만 고치는 방법이 있는 것이 아니다. 프로그램에
서 사용하는 시스템 루틴을 고칠 수도 있고 프로그램 안에 포함된 암호 데이타를 찾아
내어 하나로 바꾸어버릴 수도 있는 것이다.

인터럽트 가로채기
 이 방법이 시스템 루틴을 고치는 방법으로 고의적으로 베드섹터를 내었을 때 주로 사
용하는데 이 방법은 프로그래밍을 하는 사람이면 간단한 램상주 프로그램을 짜므로써
복제방지를 무력화 시킬 수 있다.
 프로그램들은 디스크를 읽어서 배드 섹터를 검사하는데 Interrupt 13h를 호출한다.
AH=2(디스크에서 섹터단위 읽기)나 AH=4(디스크에서의 데이타와 메모리를 비교)의 서
비스를 가로챈다. Interrupt 13h에서 돌아오는 결과 중 CF(Carry Flag)이 세트될 경우
에러를 리턴하는 경우이므로 2나 4번 서비스가 들어왔을 때 무조건 혹은 해당 디스크
의 베드 섹터가 있는 곳을 가리켜서 호출됐을 때 CF와 AH에 베드 섹터가 났음을 표시
해주면 되는 것이다.
 예를 들어 디스크의 25트랙 3섹터 0면에 베드 섹터가 나 있다고 칠 경우 Interrupt 1
3h를 가로채서 트랙 25, 섹터 3, 면 0을 읽으려 하면 읽지 않고 결과를 무조건 베드
섹터가 검출된 것으로 (CF set, AH=4)를 되돌리게 하는 것이다.

프로그램 고치기
 이 방법은 전에 다뤘던 쉐어웨어의 에디팅과 크게 다를 바가 없다. 모든 불법복제를
깨는 경우에 사용될 수 있으나 어려운 편이고, 쉐어웨어처럼 실행 화일을 못 고치게
변형시키는 경우도 있다. 그러나 변형 방지를 위해 조치를 취한 경우도 쉐어웨어 때
설명처럼 그것들을 무력화시키면서 에디팅을 하면 할 수 있다.

데이타 고치기
 이 방법은 암호를 입력받아 실행하는 방식에만 적용 될 수 있는 것으로 그리 많은 경
우가 적용되는 것은 아니나 적용될 경우 상당히 쉬운 방법으로 고칠 수가 있다.
 암호를 입력받는 것 중에서 몇 번째 페이지의 몇 번제 단어라던가 캐릭터의 어떠한
특성, 게임 배경을 묻는 것 등은 그 자료가 대부분 들어 있기 마련이다. 게임의 경우
실행시에 이것을 묻는 경우가 많고 일반 프로그램은 설치시 나타나는 경우가 많은데
이 경우가 적용되는 경우는 거의가 게임이며, 이 자료도 변형을 시켜 놓아 알 수 없게
만드는 경우가 많다. 몇 가지 예를 들면 "A-TRAIN 4"의 경우 뒷부분 자료 중 1024Byte
s만큼 불규칙한 데이타가 잠깐 이어지는데, 이것을 실제 암호표와 대조를 해보면 암호
표의 글자를 XOR시켰음을 알 수 있다. 모두 A나 1등의 글자를 같은 키로 XOR시켜 고쳐
버리면 다음부터는 "A"나 "1"만을 입력하여 암호를 통과할 수 있는 식의 것이다. 이런
방법은 옛날에 주로 사용되던 것으로 요즈음에는 많이는 사용되고 있지 않다. 무작위
인 문자열이나 수인 경우 주어진 조건을 가지고 이런 저런 계산을 해서 암호를 만들어
내는 경우가 많기 때문에 이 방법이 적용되지 않을 때가 많다.



다음은 흔히 쓰이는 용어 설명입니다.
다음 시간부터 설명되는 내용에 꼭 필요한 것들이죠.
상식적으로 알아두시기 바랍니다.
자세한건 차차 하겠습니다.


카피락(lock)이란 프로그램의 복제를 방지하기위한 프로그램을 말합니다.

다음은 간단한 게임등에서 쓰일수 있는 베이직으로된 메뉴얼 락 예제입니다.
참조만 하세요.

예)

 DIM PW$(10,10)

 FOR A=1 TO 10
   FOR B=1 TO 10

     READ PW$(A,B)
   NEXT B
 NEXT A

 DATA "HELLO? MY "
 DATA "NAME IS KU"
 DATA "S. THIS GA"
 DATA "ME IS MADE"
 DATA "BY ME. I U"
 DATA "SED BASIC "
 DATA "DURING PRO"
 DATA "GRAMMING. "
 .
 .
 .

 이렇게 100개의 데이터를 만들죠. 데이터 길이는 10자도 좋고 20자도 좋으나 칸이 맞
아들어야 합니다. 이렇게 되면 1페이지당 10줄이 있는 10페이지의 메뉴얼이 완성됩니다.


 데이터의 내용은 게임 진행방법, 제작일자 등등의 잡다한 내용을 넣습니다.
 이렇게 하고나서 PASSWORD.TXT화일을 만듭니다.

 여기에는 위의 data 화일 내용등을 써넣으세요.

 이렇게 하면 PASSWORD.TXT화일안에 암호 내용이 들어가죠.

 암호를 물을때는

 PAGE X , COL Y , ROW Z

 라고 물으면 되요.

 PAGE 1 , COL 3 , ROW 5
 하면 1페이지의 3째줄 5번째칸이니깐 H가 되겠죠?
 그럼 암호를 입력하죠. 암호가 맞으면 C=C+1 틀리면 그냥 놔둬요
 그런식으로 세번 실시한뒤 C가 3이면 넘어가고 3이 아니면 세개중 한개가 틀린거죠.

 암호를 분석하는법은 다음과 같습니다.
 아니 암호를 묻는것은 다음과 같이 합니다.
 X=INT(RND(1)*10)+1
 Y=INT(RND(1)*10)+1
 Z=INT(RND(1)*10)+1
 P$=MID$(PW$(X,Y),Z,1)
 PRINT"PAGE:";X;"COL:";Y;"ROW:";Z
 INPUT"PASSWORD";PASS$
 IF PASS$=P$ THEN C=C+1
 GOTO ...



크랙(crack) 이란 카피락을 무력하게 만드는 것을 뜻하며 이런 의미에서 크랙커(cracker)는
그런 일을 하는 사람을 칭합니다. 하지만 cracker는 usenet에서는 hacker성격과
반대되는 나쁜 사람들을 칭하는 의미로써 쓰이기도 합니다.

패치(patch)란 근원적인 뜻은 소프트웨어를 만든 회사에서 임시적으로 버그같은 것을
수정할 목적으로 실행화일을 직접고치는 일 또는 알고리즘의 변화없이
임시로 소스래벨에서 버그를 막는 일.. 등을 말합니다.
이런 이유에서 락의 있어서 패치란 실행화일을 고쳐버리는 일을 뜻합니다.

크랙을 만드는 과정은 일괄적이지 않으며 개인마다 쓰는 방법은 모두 틀릴것입니다.
변경되지 않는 처리라면 오직 "분석해서 수정"하다는 것뿐이 없다고 생각합니다.

크랙은 프로그램의 락이 걸린 실행화일 자체를 분석/추적/수정해야만
가능합니다. 분석과 추적작업은 역어셈블리된 소스를 대상으로 행해지는
것이기때문에 어셈블러 프로그래밍을 할수 있거나 혹은 어셈블리코드들을
이해하는 사람들만이 제작능력이 있는 사람이라고 말할수 있습니다.

어떤 언어를 배운분이라면 그언어의 소스를 본다면 그것이 무엇을 하는
프로그램의 소스이며 또 어떻게 고치면 자신이 원하는 일을 할수 있게 하는지
알수 있을것입니다.
어셈블러는 기계코드와 1:1대응이 되기때문에 실행화일을 어셈블러의 소스에
가까운 것으로 바꿀수 있습니다.
위의 말을 종합한다면 어셈블러 프로그래머는 실행화일만으로도 그 프로그램을
고칠수 있다는 말이 되겠지요. 결국 분석한다는 것은 어셈블러프로그래머의
입장에서는 소스래벨 디버깅과 크게 다르지 않습니다.

크랙 자체를 만드는 것은 하위접근이 가능한 씨나 파스칼 어셈블러 등등의
어떤 언어로도 만들수 있습니다. 다만 크랙을 만들기위해서 하는 락의 분석
작업은 역어셈블리된 소스를 대상으로 행해지기때문에 크랙자체를 만드는
언어와는 상관없이 어셈블러는 알아야합니다

실행화일로 된것은 어떤이유에서인가 락이 걸린화일을 직접적으로
수정하지 못하여 실행시에 메모리에서 수정해야만 할때 쓰는 방식이며 프로그램
자체가 크랙된것은 그런 현상이 없는 프로그램에서 단순히 직접적으로 디스크의
화일자체를 고친것입니다

크랙을 만드는 제일 유명한 단체는 험블(humble)입니다.
그 밖에도 단체인지 개인인지는 모르지만 많은 사람들이 있는 것은 확실합니다.


pctools 로 크랙 만들기는 "분석작업을 한뒤에 패치를 pctools로 한다" 입니다.
크랙에 있어서 중요한것은 락의 분석작업입니다. 사실상 분석작업이
크랙의 100%라고 말을 해도 과언이 아닐것입니다. 하지만 일반적으로 겉으로
나타나는것은 패치작업이죠. 크랙킹작업을 옆에서 지켜보면 계속해서 코드만을
보다가 한~~~참후에 패치가 가능한것이면 pctools로 패치를 해서 락을 제거
합니다. 그리고 누군가 어떤 프로그램의 크랙방법을 알려달라고 묻게되면
pctools로 패치하는 방법을 알려주게 되는거죠.
이런 이유로 겉으로 나타나는 패치작업이 크랙의 전부인것으로 알고 있는 분들이
많이 있습니다. 크랙자체를 만드는 것은 분명히 pctools로 하는 경우도 있는것은
틀림이 없습니다. 하지만 크랙이라는 것이 프로그램의 수정이기때문에 분석이
없을수가 없습니다. 좀더 다른 관점에서 봤을때 pctools의 작업은 기록작업
이외에는 아무 의미가 없습니다.
또한 자체압축같은 것이 되어 있는 프로그램에서는 pctools의 패치작업은
사용하지 못하며 부수적인 프로그램을 만들어서 디스크가 아닌 램에서 프로그램을
수정하게 만들어야합니다. 다시말해서 모든 락의 크랙제작 pctools를 항상
사용가능한것은 아닙니다.

인터럽트를 훅해서 메모리에서 수정한다는 말은  프로그램이 압축이 되어 있거나 또는 다른 이유
에 의해서 패치를 하지 못할때에는 추가적으로 디스크에서 메모리로 프로그램이 올라온후 실행을
위해서 원형의 모습을 갖추었을때 프로그램의 코드를 고치는 작업을  말합니다. 보다 자세한 설명
은 80개열의 CPU의 인터럽트의 메카니즘상의 문제이므로 이정도로 줄이겠습니다.

역어셈블리 소스를 만들어주는 프로그램은 많습니다. 소서라는 프로그램이 그
대표적인 것입니다. 그렇지 않으면 반어셈블러(?)정도의 소스라면 일반적인
모든 디버그에서 제공하고 있습니다. 크랙은 추적작업이 병행되어야 편하기때문에
많은 크랙커들은 전적인 역어셈블러보다는 디버거의 사용을 선호하고 있습니다.

디버거는 프로그램의 버그(오류)의 발견을 위해서 그 프로그램을 부분적으로
실행하면서 역어셈블리된 코드를 보여주거나 CPU의 래지스터 상태를 보여주는
프로그램을 칭합니다.

소프트아이스(Soft-Ice)란 많은 종류의 디버거중에 하나이며 강력합니다.
SI는 많은 기능을  가지고 있으며 구할수 있는  디버거중에 가장 편리(?)하고 막강한  디버거라고
생각합니다.

이외에도 많은 디버거들이 있습니다.
그것들에 대한 강의 시간에 함께 제공하겠습니다.





그리고 암호화 기법에 대한 몇몇 소스도 포함했습니다!!


















