안녕하세요.

17회 강좌입니다.

이번 강좌부터는 크랙등 실용적인 실제 적용을 하겠습니다.
나머지 바이러스 소스/샘플프로그램 과 크랙등에 사용될 각종 프로그램들을
함께 보냅니다.
정말 많은 양입니다.
제가 힘들여 수집한 것들입니다.
여기에는 각종 유명 툴도 많죠.
많은 도움이 되시길...............

크랙을 만드는 이와 하는 이와의 싸움은 점점 치열해집니다.
바이러스 제작자와 백신 제작자와의 싸움이 그러하듯 말이죠.

우선 해킹할수 있는 프로그램에 대해서 먼저 이야기 해보죠.
우리가 소프트웨어에서 암호등을 깰수 있는 크랙 프로그램은 많이 존재합니다.
어느것이 더 편한게 목적을 이루는데 도움이 되느냐가 중요한 것이죠.
그것들중에는 초보,중급,고급용등 다양하게 존재합니다.
전에 말한 리스트중에서 몇가지 추가된것이 있습니다.
여러분이 전혀 모르겠을 유틸들의 간단한 사용등은 질문하시면 알려드리죠.
어셈,디버그를 알아야 하는것이 있는반면 하나도 몰라도 쉽게 할 수 있는것들도 있습니다.
차근차근 해보죠.

근데 크랙이란게 무조건 특정 프로그램 가지고 두드리고 부수고만 하는건 아닙니다.
어떤 프로그램들은 특정 화일을 지우기만 해도 암호가 없어지는 것들도 있습니다.
아래 예를 보면 이런 방법도 있구나 하는걸 아실겁니다.

DCF 5.0을 가지고 해보기로 합시다
DCF(Disk Copy Fast)는 등록판이라는 허가를 얻기위한  방법으로 암호화된 dcf의 일부화일이 필
요합니다
그것은 config.dcf 라는것으로 이것이 dcf.exe의 실행화일이 실행될때 등록판인가 아닌가를 확인해
주는 dcf의 환경 file 입니다
그러나 이 화일은 여러분들이 다운받은 쉐어버전에는 없습니다.
이 암호화된 등록 file를 만들어  봅시다 이것은 일반 텍스트 화일이므로 일반 에디터 프로그램으
로 작성하시면 됩니다.
즉 dos의 edit나 edlin또는 dos의 con 또는 Q등 기타 등등 아무것이나 좋습니다
가장 간단한 DOS의 CON을 가지고 만들어 보죠.

그럼 DOS의 PROMPT에서
copy con config.dcf
rem 이것은 dcf의 등록획득을 위한 config.dcf의 defalt rem 값입니다.
rem 중요한것은 달러($)표시와 register의 rem 사이에 공백이 있어서는 안됩니다.
$register
rem 이름을 입력하고 바로 11자리의 문자를 임의로 입력하십시요.
kim tae bong 1234567890A
$nomsg
^z

이것으로 등록화일 만들기용 text file이 완성된것 입니다
rem 은 주석입니다. 실제 작성시 빼셔도 됩니다.

이로서 완성되었습니다.

본격적인 크랙으로 들어가죠.

1. 게임 위자드 프로

"게임 위자드 프로"를 아시나요?
게임을 보다 쉽게 할 수 있는 프로그램입니다.
세이브 안되는 곳에서 세이브/로드 하고 암호 깨고 등등 초보자들이 써도 막강히 활용할 수
있는 도구입니다.
우선 게임에서의 간단한 크랙을 봅시다.

"대항해 시대2"를 가지고 해보겠습니다.


사용 1. 게임 위자드 프로 를 실행한다. 그럼 램상주 됩니다.
     2. 게임등 해당 프로그램을 실행한다.
     3. 고치고자 하는 화면등에서      `   키를 누른다.
     4. ` 를 누르면 게임위자드 프로 화면이 호출됩니다.

가장 중요한 요소인 돈을 고쳐볼까요?
  `   를 눌러 위자드 를 부른 화면에서  G  를 눌러보십시요.
그리고 4000:258A 를 입력하면 돈이 기록되어 있는 해당 번지로 갈겁니다.
거기서 E 를 누르면 입력이 가능합니다.
80 4A 5D 05 라고 입력해 보세요.
그럼 돈이 엄청나게 늘어날겁니다.

이게 가장 간단한 예입니다.

다른걸 하나 더 볼까요?

옛날 농구 게임인 NBA 를 가지고 해봅시다.
점수를 올려보죠.
위자드를 램 상주 시키고서 NBA 를 시작하면 0점 일겁니다.
여기서  Memory Address Search 를 선택하세요.
이게 M 을 누르면 됩니다.
그럼 옵션을 물어볼때 no 를 치고 입력 요구시 0을 입력합니다.
엔터를 치고 슛을 한번 넣어면 2점이 올라가겠죠?
위자드를 호출하고  M 를 누르면 곧장 다시 입력하게 될때 2 를 입력합니다.
에디트 화면으로 바뀌면 커서 위치에서 숫자를 입력합니다.
ff 를 누르고 세이브를 시킵니다.
점수가 엄청나게 늡니다.

이런식으로 게임을 무지 막지하게 조작할 수 있습니다!!!
응용하기 나름입니다.
여기부터는 여러분의 창조적인 두뇌에 맞기겠습니다.


이번에는 "게임 위자드 프로"를 이용한 암호 크랙에 적극적으로 나서보겠습니다.

Mdir-III 아시죠? 통신상에서는 쉐어웨어로 되어있습니다.
등록하면 정식버전을 사용할 수 있게 되어 있습니다.
여러분께 가장 쉬운 암호 크랙 기술을 알려주는데 이보다 더 좋은 학습 예제는 없다고
보기에 부득이하게 M(이하 Mdir-iii )을 크랙하겠습니다.
이 방법만 습득하면 웬만한 크랙은 다 깰수 있을 겁니다.
국산 프로그램은 가급적 정식 등록해서 쓰시는게 좋습니다. 특히 M 같은거는요.~~좋습니다.
저도 프로그래머의 한 사람으로서 몇몇 S/W를 라이센스로 판매하고 있는데,
여러분이 정식 사용해 주시는게 더 좋은 프로그램이 나오고 공개용 판도 많이 나와
여러분께 훨씬 이득입니다.

자, 그럼 시작하겠습니다.

우선  " 게임 위자드 프로"를 설치하고  램상주 시킵니다.
그냥 간단히 GW.EXE 를 실행하면 설치가 되죠.

그다음,  통신에서 받은 M 을 하드에 설치하십시요.
처음에 받은 M 은 기능이 제약되어 있습니다.
정식 등록번호를 입력해야만 합니다.
자신을 정식등록자로 등록해보죠.

게임 위자드 프로는  추적방식이 해당 화면에서 호출해서 추적/에디트하는게 근간입니다.
어찌보면 상당히 쉽고 효율적인 방법이죠.
물론 단점도 있겠지만..........

M이 설치되어 있는 디렉토리를 보면 MAKE-REG.EXE 가 있습니다.
이것을 실행시켜보죠.
그럼 한글의 자기이름과 등록번호 비밀번호를 차례로 입력하라고 나옵니다.
먼저 한글로 이름을 입력하라고 나오면 자기 이름을 씀니다
그다음 영어로 이름을 입력하라고 나오면 그대로 하십시요.

* 여기부터 중요한데 등록번호를 입력하라고 나옵니다
  그럼 여기서 COMPUTER 이라고 대문자로 보기 쉬운 문자를 임의로
  입력합니다.

그다음 비밀번호를 입력하라고 나옵니다 그러면 00000000을 입력하세요.

이렇게 하는 이유는 쉽게 알아보기 위한 것입니다.
물론 이렇게 안하고 다른 문자,숫자들을 이용할 수 도 있습니다.


모든 상황을 다 입력하면 우리가 입력한 등록번호가 진짜가 아니므로 다시입력하라는
메세지가 뜹니다.

바로 이때!!!!     `   를 눌러 위자드를 부릅니다.

그러면 위자드의 메인 메뉴가 보일겁니다.
여기서 4번의 edit memory contents로 들어가시면 마치 pctool의 edit 와 같은 메뉴가 보입니다.
여기서 S(SEARCH)를 누릅니다.
그러면 두개의 칸이 아래에 보입니다.
여기서 TAB을 눌러 ASCII에서 처음의 가짜 등록번호인 COMPUTER을 입력합니다.
이렇케하는 이유는 전에 HWP 암호 크랙에서 말했듯이 처음 입력한 가짜 등록번호와
진짜 등록번호와의 비교루틴을 찾는과정 입니다
결국 비교할려면 내가 입력한 가짜 등록번호의 주위에 진짜 등록번호가 있어야 된다는얘기입니다

그러므로  이상태에서 PAGE UP/DOWN 키를 이용해서 살펴보면 진짜 등록번호가 똑똑히
보입니다.
그럼 그걸 잽싸게 적습니다.
그다음 빠져나와서 make-reg.exe 실행후 이름.등록번호.비번을 입력하여 정식등록자처럼 사용이 가
능합니다
여기서 우리는 M이 어떤 원리로 등록번호를 만들어 내는지 알수 있을겁니다.
우리가 등록한 이름,등록번호,암호 등을 이용하여 어떤 일정한 순서에 입각하여 암호화된
실제 등록번호를 만들어 내는것이죠.

지금 말한 M 크랙은 아주 쉽고 응용 가능성이 많습니다.

다른걸 한번 볼까요?

다음은 위자드를 이용해 "푸른물"을  해킹하는 법입니다.
M가 방법은 똑같습니다.

등록번호 입력시 허위로 아무거나 찾기 쉬운걸 입력하면 틀렸다고 나옵니다.

거기서 ` 를 눌러 호출하고 S로 처음 가짜 등록번호를 추적하면 6자리 숫자로
등록번호가 나옵니다.

이걸 적은후 빠져나와 정식 등록번호를 입력하면 됩니다.

제가 위자드를 이용해 본 결과   무모하게 되나 안되나 봤던 HWP는 역시 안되더군요.
HWP는 암호화 기법으로 암호를 감추어서 그렇습니다.
하지만 보통 S/W는 이런 식으로 어렵게 만들지 않으니 다 깨집니다.
제가 제작한 프로그램의 암호도 이걸로 처참히 깨지더군요.
다른것도 마찬가지 입니다.
암호화기법을 사용하지 않을경우 여기에 거의 다 걸립니다.
암튼 게임 위자드 프로는 크랙에 아무것도 모르는 초보자도 쉽게 쓸 수 있고 막강합니다.
부지런히 연습하세요.

다음 시간부터 다룰 디버거,소프트 아이스를 위해서 어셈에 대해 좀더 언급하겠습니다.
여기 수록된 내용은 제가 판단컨데 정말 아주 쉽습니다!!
초보자들은 반드시 보셔야 할겁니다.


팁. 어셈블리 보충.

 어셈블리의 필요성

   1.컴퓨터를 보다 깊게 이해하고 보다 잘 사용하기 위해
   2.고속 연산 루틴을 작성하기 위해
   3.다른 언어를 깊이 알기 위해
   4.고급언어에서 할 수 없는 조작을 하기 위해

기계어: 수치로 기술된 명령
      (CPU 는 수치로 기술된 명령밖에 이해 할 수 없다)

어셈블리 언어: 기게어 대신에 인간에게 알기 쉬운 표기법을
             사용하여 표현한 언어
    (수치에 의한 명령과 1:1 로 대응하고 있다.)

어셈블: 어셈블리 언어로 작성된 문자열을 기계어로 변환하는 작업

어셈블러:어셈블을 자동적으로 수행하기 위해 만들어진 프로그램.

의사명령:직접 기계어로 번역되지는 않지만 번역할 때 참조되는 명령

어셈블의 기본 순서

   1. 프로그램의 설계
   2. EDLIN 등의 에디터에 의한 편집
       ( 소스화일의 작성: SAMPLE.ASM )
   3.MASM 에 의한 어셈블
       (오브젝트 화일   : SAMPLE.OBJ )
   4.LINK에 의한 링크
       (실행화일        :SAMPLE.EXE  )


링커의 역할

   ---프로그램의 모듈별 개발을 가능하게 하기 위하여
      (하나의 프로그램을 개발할 때 몇 부분으로 나누어 개발한후
       이것을 각각 어셈블 한후브젝트 화일을 하나의 라이브러리로 정리해둘 수 있다
.
     3.라이브러리에 오브젝트 화일을 추가, 발췌,삭제 할 수 있다.

디버거의 역할

     프로그램에 버그가 있는 경우  프로그램을 조금씩 실행시키면서
    레지스터나 메모리의 내용을 살피며 bug 를 잡을 때 이용


어셈블리의 일반적인유형

    LI:       MOV          AX,                   BX   ;COMMENT

    라벨 : OP코드     제1오퍼렌드 ,       제2오퍼렌드 ;설명문

                         ______________________

                             <-- 조작의 방향

라벨

   명령행 중 제일 처음에 놓인다.
   필요에 따라 붙이는 것으로 안 붙여도 상관 없다.
   라벨의 다음에 작동 코드가 올때  : 을 사용해 구별한다.
   위의 LI 가 이에 해당 한다.

OP 코드
   OP 코드 ---명령의 종류
   오퍼랜드--- OP코드에 따
 조작  대상
   제 2 오퍼랜드로부터 제1 오퍼랜드의 방향으로 조작이 이루어 진다.
   위에서 BX 레지스터의 내용이 AX 레지스터에 전송 ( MOV ) 된다.

설명문

    필요에 따라 붙이며 오퍼렌드와의 사이에 세미콜론(;)을 둔다.

* 라벨과 설명문을 각각 다른 행에 써도 된다.

     LI:
                MOV  AX, BX
      ;COMMENT

* 어셈블리의 사용법

   다음의 예제를 에디터로 똑 같이 작성 한 후 MOV1.ASM 으로 세이브 시키자



MAIN    SEGMENT
        ASSUME  CS:MAIN
;
        MOV     DL,41H
        MOV     AH,2
        INT     21H
     LENAME  [    .ASM]: MOV1    리턴
OBJECT FILENAME  [MOV1.OBJ]:   리턴
SOURCE LISTING   [NUL.LST]: MOV1 리턴
CROSS  REFERENCE [NUL.CRF]: MOV1 리턴

C: MASM >

오브젝트 화일

    어셈블의 결과 출력되는 기계어의 중간 형태

소스 리스팅

    소스화일과 어셈블의 결과 출력된 기게어를 대응시킨 리스트 화일
  변수이름등의 번지에 대한 일람표나  에러가 있다면 에러메시지도
  포함하여 기록한다.

크로스 리퍼런스

     라벨이나 변수이름이 어디서 정의 되어 어디에서 참조되고
 있는가를 리스트 하는 화일 입니다. 이화일은 그대로 볼 수없고
 CREF를 이용해 화일을 변환시킨 후 본다.




                        MOV 명령과 문자 출력

 전송 명령의 3가지 형

     1.레지스터에 수치를 대입한다.
     2.레지스터와 레지스터 사이에서 데이터를 전송한다.
     3.레지스터와 메모리 사이에서 데이터를 전송한다.

  우선 레지스터와 수치를 대입하는 방법과 레지스터간의 메모리
전송에 관해서 설명합니다.

* 화면에 AB를 표시하는 프로그램

1:
2:   MAIN    SEGMENT
3:        ASSUME  CS:MAIN
4:    ;
5:         MOV     DL,41H
6:         MOV     AH,2
7:         INT     21H
8:         MOV     DL,'B'
9:         MOV     BL,2
10:        MOV     AH,BL
11:        INT     21H
12:   ;
13:        MOV     AH,4CH
14:        INT     21H
15:   ;
16:  MAIN    ENDS
17:        END
18:

소스 리스트(SOURCE LIST)의 형식(FORMAT)

MAIN SEGMENT

   이것은 "MAIN"이라는 이름의 세그먼트가 할당되는 프로그램의 시작
이다 라는 선언문입니다.
   이 의사명령은 16번째 줄의

MAIN ENDS

와 짝이 되고 있어서 이 두문장 안에 들어간 부분이 "MAIN"이라는 세않습니다.)

3 번째 줄의 의사명령

    ASSUME    CS:MAIN

은  어셈블러가 어셈블을 할 때 "코드 세그먼트(CS:)을 참조하는 명령이
있다면 ,MAIN 이라는 이름의 세그먼트를 참조하라"는 선언을 하는 문장입
니다. 따라서 ASSUME 문장은 4개 세그먼트 (CS,DS,SS,ES)와 세그먼트
이름을 대응시키는 선언문입니다.
  코드 세그㎱ 세그먼트와 대응하고 있는가를 표시해야할
필요가 있읍니다.

17 번째 줄의  의사명령

  END

  는  어셈블러 소스 리스트의 끝을 나타내며 프로 그램의 끝에  END
            본문

   [MAIN]   ENDS
            END




MOV 명령의 사용법

  - MOV는 MOVE 의 약자입니다.
  - MOV DL,41H   ; DL 레지스터에 16진수 41H를 대입하라는 명령입니다.
    * 특별히 표시하지 않는 한 수치는 10진수로 취급됩니다.
      16진수임을 나타낼 때에는 숫자 뒤에 "H"를 붙여 표시합니다.
  -수치가 알파벳으로 시작될때는 선두에 "0"을 붙이도록 약속하고
   있읍니다.
       16진수 4A   -->   4AH
       16진수 C7   -->  0C7H

 시스템 호출과 입출력

      INT       21H

  인터럽트 명령: 강제 적으로 CPU 가 하던 일을 중지 시키고 끼어들기
               (인터럽트)를 발생시키는 것입니다. 시스템 호출의 목적으로
                사용되고 있읍니다.
  시스템 호출 :OS 내에 미리 준비하여 만들어 놓아둔 입출력등을 위한
              서브루틴을 호출하는 것입니다.

   21H번의 인터럽트는 MS-DOS 에 의한  입출력 등의 시스템 호출에
 사용되고 있읍니다.

  -키보드로 부터 한문자를 입력하라는 명령은
        MOV      AH,1
        INT      21H
  -디스플레이에 1문자를 표시하라는 명령은
        MOV     AH,2
        INT     21H

 인터럽트 명령의 갯수에 한정이 있기 때문에  여러종류의 입출력에 하나
하나 입출력을 할당할 수는 없읍니다.
 그래서 MS-DOS 에서는 INT 21H 를 주로 입출력으로 사용하기로 하고  그
중 서브 커멘드를 AH 레지스터에 넣어 시스템을 호출 하는 방법을 쓰고
있읍니다.
  이프로그램의 경우 1문자 표시 루틴을 호출한 것인데 표시해야 할
데이터는 미리 DL 레지스터에 넣어 두어야 합니다. 이 프로그램에서는 DL
레지스터에 41H 가 대입되어 있으므로 1문자 표시 루틴에서는 아스키 코드
 41H에 대응하는 문자 "A"가 화면에 표시 됩니다.

  MOV DL,  'B'

이와 같이 문자를 인용부호로 애워싼 것은 그믄자에 상응하는 아스키 코드
가 쓰여진 것으로 간주 합니다.

  MOV DL, '1'

  DL 레지스터에 "1"이라는 문자에 상응 하는 아스키 코드 31H 가 대입됩니다

MOV BL,2
MOV AH,BH

에 의해 BL 레지스터에 2가 대입되고 그 내용이 AH레지스터에 전송되므로
두레지스터의 내용은 2가지정됩니다.
레지스터 간의 전송은 두레지스터의 크기가 같아야 합니다.

   MOV  AH ,BX    ; BX는 16비트 레지스터 AH는 8비트 레지스터
                    그러므로 틀린 예입니다.

프로그램을 끝마치는 방법

  MOV  AH,4CH
  INT 21H

이 명령에 의해 MS-DOS  의 시스템 호출(SYSTEM CALL)인 4CH 번째의 루틴을
호출되는데 ,실은 이것은 특수한 명령어로서 실행중의 프로그램을 끝마치고
OS 레벨로 되돌아 가기 위한 명령입니다.

아주 간단하고 기초적인 부분의 어셈 내용입니다.
참조하십시요.







