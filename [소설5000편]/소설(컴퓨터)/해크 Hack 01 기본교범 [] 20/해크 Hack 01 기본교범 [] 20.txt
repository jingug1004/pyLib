18회 강좌입니다.

이번 강좌 시간에는 무척 유명하고 중용한  소프트아이스 를 다룹니다.
내용이 좀 깁니다.
2회로 나누어도 될 분량입니다.

소-아는 위자드보다 물론 훨씬 더 어렵지요.
이것만 마스터하면 여러분은 진짜 달인이 되는것입니다.
어셈을 전혀 모르는 초보자들이 보시기에 다로 어려울지 모르니
어셈 기초서적 한권쯤 꺼내놓고 찾아보시는것도 좋을듯 싶습니다.
소-아는 도스용과 윈도우 용이 있죠. 윈도우 용이 쓰기엔 더 좋습니다.
이 둘다 제가 제공했습니다. 설치하시고 써보시기 바랍니다.
우선 소프트 아이스에서 실제 행한 사례중 일부는 깨끗이 정리된게 있어서
인용하였습니다.

2.  소프트아이스

１) 설치
이것은 386SX이상에서만 사용하지만, 기능이 아주 좋다.
Protected Mode에서 동작하며, DOS를 virtual mode로 사용하며,
사용되는 기능은 DOS나 BIOS를 사용하지 않으므로 Real mode를
사용하는 모든 OS의 debug가 가능합니다.  예를 들면 DOS의 boot
과정의 debug, device driver의 debug등 입니다.  그리고 다양한 break
point 설정등으로 기존의 debug, symdeb, codeview등을 이용하는
것보다 편리하며, 이들의 보조 debug로도 사용가능하다..  특히
이들을 사용하다 PC가 다운되는 경우에도 사용가능하다..
만일 extended memory가 있고, soft ICE를 device driver로 install한 경우 source
level의 debug도 가능하고, DOS에서 command로 올린경우 extended memory가  있으면 640KB의
메인메모리를 단 1byte도 사용하지 않고 ram 상주로 사용가능하다.

그런데,
소프트 아이스를 램 상주시키게 되면 기본메모리가 대부분 500K 대로 떨어지게 되죠?

다음과 같이 하시면 간단히 해결됩니다.
config.sys
에서
himem.sys 를 로드 시키기 전에
소아를 로드 시키세요
그러면,
기본메모리 620K 정도에서 소아를 상주시켜 놓고
작업을 할 수 있습니다.

1. device driver로 설치할경우 config.sys에 device=s-ice.exe 만 넣고, source level debug가 필요
한 경우 device=s-ice.exe /sym 512 와 같이하면 extended memory 512KB를 source와 symbol을
위한 영역영으로 확보하라는 의미이다.
s-ice 화면에서 '?'를 하면 help가 표시되므로 참조 바란다.

 s-ice.exe와 s-ice.dat는 같은 directory에 있어야 하고, 'path=...'에 등록되어 있으면 편리하다.
그리고 's-ice/?<return>을 하면 몇개의 option을 볼수 있고,
hotkey는 'Control-D'이나 s-ice의 'altkey'명령으로 변경가능하다.


２) 창에 관한 명령들

처음 소프트아이스가 실행이 되면 "초기명령"에 따라서 창이 떠있다.
그 창들을 켜고 끄고 또는 줄이는 명령에 관한 것들이다.
창을 줄이고 늘리고 하는 명령어도 있지만  그런 사소한것은 별로 사용을 하지 않는 것이니 그냥
넘어가겠다.

    wc ------ 코드윈도 토글
    wd ------ 데이터윈도 토글
    wr ------ 래지스터윈도 토글
 ------------------------------------------------------------------------------

    ec ------ 코드윈도와 명령윈도의 커서 스위칭
    rs ------ 현재의 실행 화면과 디버그화면의 스위칭

３) 트레이싱에 사용되는 명령들

    T ------- 싱글스텝 트레이싱
        터버디버그에서 F7과 같다.
        도스의 디버그에서도 T는 싱글스텝 트레이싱이었다.
        소프트아이스도 마찬가지이다.

    P ------- 스텝 트레이싱
        터버디버그에서 F8과 같다
        도스의 디버그에서도 P는 스텝 트레이싱 명령이었다.

 ------------------------------------------------------------------------------

    HERE ---- 커서위치까지 트레이싱
        터버디버그에서 F4과 같다.

    G,X ----- 실행
        터버디버그의 F9와 같다
        도스의 디버그에서도 G는 실행이었다.


４) 브레이크 포인터
    bpx ----- int03h를 이용한 브레이크포인트
        터버디버그의 F2와 같은 기능하다.
 ------------------------------------------------------------------------------

        현재의 커서 위지체 int03h를 삽입해서 브레이크하는 명령이다.

    bpmw ---- 메모리 브레이크포인터
        메모리의 읽기/쓰기/실행시에 브레이크하는 명령이다.

         ex> bpmt 1234:5678 rw
            1234:5678의 메모리가 읽기나 쓰기가 이루어지면 브레이크된다.

    bpint --- 인터럽트 브레이크포인터
        선택된 인터럽트가 걸릴경우 브레이크한다.

        ex> bpint 21 ax=3d00
            int21h의 3d00h가 발생하면 브레이크가 된다.
 ------------------------------------------------------------------------------

５) 브레이크 포인터 제어명령
    bl ------ 브레이크 포인터 리스트
        현재설정되어 잇는 브레이크포인터를 보여준다.
    bc ------ 브레이크 포인터 클리어
        설정된 브레이크 포인터를 지운다.

        ex> bc *
            모든 브레이크 포인터를 지운다.

    bd ------ 브레이크 포인터 불가능
        설정되어 있는 브레이크포인터를 잠시 불가능하게 한다.

        ex> bd 1
 ------------------------------------------------------------------------------

            1번 브레이크 포인터를 불가능하게함

    be ------ 브레이크 포인터 가능
        bd로 불가능하게 된 브레이크 포인터를 가능하게 한다.

        ex> be *
            모든 브레이크 포인터를 가능하게한다.

６) 기능키설정
    소프트아이스에서는 평션키를 자신의 취향(?)대로 설정할수 있는
    아주 편리한 기능을 제공한다.
    s-ice.dat라는 화일에 그 키들을 설정할수 있다.
    형식은 [키이름 = "^명령어;...;...;"]으로 하면 된다.
 ------------------------------------------------------------------------------

    만약 F2키를 bpx로 설정한다면
        F2 = "^bpx;"이라고 하면 된다.

    아래는 터버디버그와 비슷한 키들로 설정한 예이다.

    F1 = "?;"
    F2 = "^BPX;"
    F3 = "^TRACE *;"
    F4 = "^HERE;"
    F5 = "^RS;"
    F6 = "^EC;"
    F7 = "^T;"
    F8 = "^P;"
 ------------------------------------------------------------------------------
    F9 = "^G;"
    F10 = ""
    F11 = ""
    F12 = ""
    Init ="WIN;WC 20;WD;WR;WATCHV ON;EC;X;"

    마지막의 Init는 소프트아이스가 실행되자마자 실행되는 명령어이다.
    이것역시 자신이 원하는대로 하면 된다.

７) 소프트아이스의 로드 유틸리티

    소프트아이스는 램상주 프로그램이기때문에 핫키인 ctrl-d를
    누르기전에는 실행되지 않습니다

------------------------------------------------------------------------------
    그래서 프로그램의 로드와 동시에 ctrl-d를 누르거나 아니면
    int 21h/4bh를 추적해서 프로그램의 처음을 찾거나 하는
    방법이 있겠지만 이 두가지 방법 모두 좋은 방법이 아니다.
    그래서 소프트 아이스에서는 ldr.exe라는 유틸이 있다.
    이 프로그램은 화일을 메모리에 적제하고 엔트리포인트에서
    자동으로 멈추게 해주는 아주 좋은 유틸이다.

８) 소프트아이스의 장단점
    소프트아이스는 어떤한 디버그 보다 막강하고 강력하고
    편리한 기능을 제공한다.
    그리고 메모리확보차원에서도 어떤 디버그보다 유리하다.
 ------------------------------------------------------------------------------
    하지만 이런 소프트아이스도 단점이 있다.
    UMB,HMB를 사용못한다는 점이 그것이다
    안타깝지만 소프트아이스로 msdos6.0에서 최대로 확보 할 수 있는
    기본메모리는 580kb이다.
   여기서 expand메모리의 사용을 위해서 emm을 띄운다면 더 작아져서 510kb정도로 줄어들어버
   리게 된다.

    게임이나 다른 도스 프로그램의 실행을 위해서 이정도면
    충분하다고 생각하지만 간혹.. 기본메모리부족으로 프로그램의
    실행이 안되는 경우도 있다.
 ------------------------------------------------------------------------------

A. 소프트 아이스의 활용
１.한글윈도 3.1 의 win.com을 패치하자.
한글윈도를 쓰면서 영문도스를 사용하는 사용자라면 늘 귀찮은 메세지를 볼것이다.

그것은 win.com이 실행될때 [주의]메세지이다.

Warning: For correct execution of DOS Box in Hangeul Windows 3.1,
You should use Hangeul Windows 3.1 standard HBIOS.
Warning: Your DOS is not compatible with Hangeul MS-DOS. You may have
some problems when you use Hangeul Windows 3.1.

Press any key to continue...

이 메세지후에 늘 키를 눌러야 했다.

소프트아이스를 이용해서 패치해보자.
Win.com가 키를 받아들일때 어떤 도스인터럽트를 사용할까?

위 메세지가 나온후에 키를 치면 그 키는 보이지 않는다.

그럼 도스의 인터럽트중에 echo되지 않는 키입력일것이다.

그리고 더해서 위 메세지전에 키를 눌러도 소용이 없다.

그럼 flush기능도 있는 인터럽트일것이다.


int 21h/0ch를 이용해서 int 21h/08h를 실행하는것이다.

소프트아이스로 추적을 해보면,


우선 ldr로 win.com화일을 적재한다.


커맨드 라인에 bpint 21 ax=0c08이라고 친다.


그리고 g로 실행하면 메세지가 나온뒤에 바로 정지한다.

그 인터럽트의 위치를 파악해서 diskedit나 다른 섹터에디터로

고치면된다.


이제는 win.com의 메세지는 볼수있겠지만 적어도 키를 누르지 않고 바로 자동(?)으로 지나가게

되었다.

이런것은 단순히 소프트아이스의 bpint라는 브레이크 포인터를 이용해서 간단히 끝내버린 경우다.

하지만 중요한것은 보통의 게임 프로그램은 이렇게 diskedit로 고칠수 없다는 점이다.


왜냐하면 게임들은 어마어마한 용량때문에 자체압축을 사용하기 때문이다.







B. 인터럽트를 이용한 메모리수정


간단한 메모리 수정소스 이다.

이 소스에서는 exec평션과 인터럽트훅 뿐 든것이 없다.



EQU로 선언된 HOOKINT,SUBINT,INT_CS,INT_IP,LOCK_CS,LOCK_IP들과

데이터로 선언된 old_codes와 new_codes만 변형한다면

게속해서 범용으로 사용하실수 있는 소스이다.




                .MODEL  TINY



HOOKINT         EQU     21h

SUBINT          EQU     3fh



INT_CS          EQU     204dh

INT_IP          EQU     1290h

LOCK_CS         EQU     1663h

LOCK_IP         EQU     0fcch



STSIZE          EQU     4*1024

SIZEPARA        EQU     (Tail-Start+STSIZE+0100h)/16+1

ENVIRON         EQU     2ch

FCB1            EQU     5ch

FCB2            EQU     6ch

CMD             EQU     80h



                .CODE

                ORG     100h

Start:

                jmp     Begin



NewInt          proc    near



                push    bp

                mov     bp,sp

                push    ax

                push    bx

                push    cx

                push    dx

                push    si

                push    di

                push    Ds

                push    Es



                cmp     ah,SUBINT

                jnz     NewIntOut



                mov     ax,Cs

                mov     Ds,ax



                mov     bx,word ptr Ss:[bp+2]

                cmp     bx,INT_IP

                jnz     NewIntOut



                mov     bx,Word ptr Ss:[bp+4]

                add     bx,LOCK_CS-INT_CS

                mov     Es,bx

                mov     si,offset old_codes

                mov     di,LOCK_IP

                mov     cx,old_codes_end-old_codes

                cld

                repe    cmpsb

                jnz     NewIntOut



                mov     di,LOCK_IP

                mov     si,offset new_codes

                mov     cx,new_codes_end-new_codes

                rep     movsb



                mov     ax,Cs

                mov     Es,ax

                                     si,offset Jumper

                mov     di,offset NewInt

                mov     cx,JumperEnd-Jumper

                cli

                rep     movsb

                sti

NewIntOut:

                pop     Es

                pop     Ds

                pop     di

                pop     si

                pop     dx

                pop     cx

                pop     bx

                pop     ax

                pop     bp

Jumper:

                jmp     Cs:oldint

JumperEnd       label   byte



NewInt          endp





Begin:

                mov     sp,offset Tail+STSIZE



                mov     ah,4ah

                mov     bx,SIZEPARA

                int     21h



                mov     ax,3500h+HOOKINT

                int     21h



                mov     Word ptr oldint[0],bx

                mov     Word ptr oldint[2],Es



                mov     ax,2500h+HOOKINT

                mov     dx,offset NewInt

                int     21h



                mov     Word ptr oldstack[0],sp

                mov     Word ptr oldstack[2],Ss



                mov     ax,Ds:[ENVIRON]

                mov     execpara_envir,ax

                mov     ax,Cs

                mov     Word ptr execpara_cmd[0],ax

                mov     Word ptr execpara_cmd[2],cmd

                mov     Word ptr execpara_fcb1[0],ax

                mov     Word ptr execpara_fcb1[2],fcb1

                mov     Word ptr execpara_fcb2[0],ax

                mov     Word ptr execpara_fcb2[2],fcb2

                mov     ax,Cs

                mov     Es,ax

                mov     bx,offset execpara

                mov     dx,offset filename

                mov     ax,4b00h

                int     21h



                mov     ax,Cs

                mov     Ds,ax



                cli

                mov     sp,Word ptr oldstack[0]

                mov     Ss,Word ptr oldstack[2]

                sti



                lds     dx,oldint

                mov     ax,2500h+HOOKINT

                int     21h



                mov     ax,4c00h

                int     21h





execpara        label   byte

execpara_envir  dw      0

execpara_cmd    dd      0

execpara_fcb1   dd      0

execpara_fcb2   dd      0



oldint          dd      0

oldstack        dd      0

filename        db      'install.exe',0



old_codes       DB      0e8h,0afh,14h

                DB      59h

                DB      0ah,0c0h

                DB      74h,0eh

old_codes_end   label   byte



new_codes       DB      0e8h,0afh,14h

                DB      59h

                DB      0ah,0c0h

                DB      0ebh,0eh

new_codes_end   label   byte



Tail            label   byte



                END     Start



메모리수정작업


다음은 게임 프로그램인테 이름은 "SpeedBall II" 이다.

아뭏튼 상관없이 "메모리수정"으로 크랙을 하겠다.

프로그램을 실행하면 로고화면이  지나고 "PLEASE ENTER PASSWORD"라는

메세지와 함께 그래픽화면에 만들어진 커서가 깜빡깜빡하고 있다.

그럼 여기서부터 소프트아이스로 들어가겠다.



핫키(CTRL-D)를 누르면,

핫키를 어느시점에서 눌렀는가에 따라서 언제나 소프트아이스가

뜨는 CS:IP는 다르다.


아래는 크랙을 하는데 트레이싱을 해서 경유한 루틴을 하나도

빠짐없이 나열한것이다.

앞부분에 키보드입력 루틴을 찾는것은 생략했다.



세그먼트는 램환경에 따라 다를것이니 XXXX로 모두 대치한다.



㈀

XXXX:029B   JZ      027E

            XOR     AX

            INT     16H

            CMP     AL,0D

            JZ      02ED       >컋컋컋컋컋컋컋컋껦

            .

            .

            .



㈁

XXXX:02ED   .

            .

            ADD     AX,[091E]

            .

            .

            RET



㈂

XXXX:023F   MOV     BX,AX

            .

            .

            .

XXXX:02ED   ADD     SI,AX

            CMP     BX,[SI+041C]

            JNZ     01FD

            CALL    [92BA]

            RET

㈃

XXXX:0153   CALL    01EB

            MOV     WORD PTR [93F6],0

            .

            .

            .





여기서 ㈀루틴에서 ㈁루틴으로 넘오는 경로인 ⑴번 점프는

INT 16H/00H호출후 CMP AL,0D로 작동하는 것이니 내부루프가 없는

키입력으로 ENTER를 입력받는 것을 알것이다.

F8을 이용한 트레이싱만으로는 ㈀루틴을 반복할뿐이다.



㈁루틴으로 가서 F4를 누릅니다. 이렇게 해야지만 트레이싱당하는

프로그램쪽으로 키입력을 할수 있다.

그렇게해서 ENTER를 누르면 지정한 곳에 소프트아이스가 다시 뜨게된다.



㈁루틴에서는 벌써 RET이 아래에 보일것이다.

이것으로 이 루틴이 끝인것을 알수 있다.

RET앞쪽에는 ENTER를 누르기전에 입력된 루틴들의 값들이

어떻게 처리되었나를 볼수 있다.

C언어로 짜여졌으니 리턴값은 AX래지스터로 전달된다.



㈁루틴의 리턴으로 ㈂루틴에 오게되었다.

오자마자 리턴값이 저장된 AX를 BX에 저장을 하고 어떤 연산과정을

거친다음에 SI래지스터에 전달하여 BX값과 비교를 하게된다.

리턴값으로 작업을 하는것으로도 암호비교루틴을 가능성이 높고

또 암호를 입력한후에 첫 비교문이라는 것도 암호비교루틴일

가능성을 더욱 높혀준다.

그럼 JNZ 1FD명령을 불가능하게 해보도록하자.

NOP로 채우던지 75XX라는 7500으로 고쳐도 된다.


그 바로 아래루틴은 화면을 사라지게 (정확히 말하면 파렛트값을

조정하는 것이지만) 하는 루틴이다.



즉! 암호를 맞춘것과 같다는 것이 된다.



여기서 우린 트레이싱을 멈추고 그 루틴을 고치는 메모리수정

프로그램을 만들어도 된다.

하지만 이곳을 고치게되면 크랙을 만들어도 암호를 묻는 화면을

늘 보야하고 ENTER도 늘 쳐야한다.


㈂루틴의 RET으로 ㈃루틴으로 왔다.

소프트아이스로 한칸위의 CALL 01EB라는 루틴이 있다.

우린 지금가지 이 루틴속을 게속 트레이싱하고 있던것이다.

다시 말해서 CALL 01EB만 없어진다면 우린 암호를 묻는것 그자체도

없앨수 있다는 말이되는것이다.

이젠 우린 암호를 입력하는 루틴의 주소를 알았다.

그럼 CALL 01EB의 코드와 세그멘트와 업셋값을 준비한 적어놓는다.

락의 위치를 찾은 우리가 해야할일은 이제 메모리수정에 쓸 인터럽트를

찾는일이다.

제일 좋고 괜찮은 인터럽트는 INT 21H/3DH 이다.(오픈 인터럽트)

그럼 다시 컴퓨터를 부팅해서 아까와 100%똑같은 메모리환경으로

SB2.EXE화일의 트레이싱에 들어가기전에 SOFT-ICE에서 블레이크포인터를

BPINT 21 AH=3D라고 설정한다.

그런후에 SB2.EXE를 실행한다.


여기서 걸릴것이다.



XXXX:9F19   INT     21

XXXX:9F1B   .

            .




9F19H에서 브레이크하자.

이것이 자체압축프로그램으로 각각의 루틴들을 따로

로드한다면 실제로 지금 정지한 시간에서 뒤쪽 암호루틴이

존재하지 않을 가능성이 있다.

그럴경우는 이 작업을 반복한다.

하지만 UXXXX:0153한다면 CALL 01EB라는 루틴이 존재한다.

아마도 이 게임은 자체압축을 쓰지 않거나 암호루틴을 빨리

메모리에 풀어서 올려놓거나 하는 둘중에 하나일것이다.


메모리에 암호루틴이 존재하는 것이 확인된다면 또 하나 적을 것이 있다.

그것은 INT 21H가 발생한 후의 주소값이다.

XXXX:9F1B가 되는거죠. 세그먼트값도  적어야한다.


아래와 같이 적혀 있을것이다.



(1) XXXX:0153

(2) EB 95 00

(3) yyyy:9F1B



아래에 보여졌던  "메모리수정" 소스에


INT_CS      EQU     xxxxh

INT_IP      EQU     0153h



LOCK_CS     EQU     yyyyh

LOCK_IP     EQU     9f1bh



old_code    DB      0ebh,95h,0



new_code    DB      90h,90h,90h



filename    DB      "sb2.exe",0



소스의 부분을 위와같이 고치게 된다면 크랙이 완성이 된것이다.

new_code               ALL루틴에 대치될 값들이다.



압축기법이나 암호화 기법을 사용하는 일부 락들은 MCB와 PSP 그리고

환경블럭순으로 자신의 모프로세서를 확인하므로써 자신이

COMMAND.COM이후에 1차프로세서가 아닐경우 락부분을 성공적으로

크랙을 해도 불가능한 경우가 있다.

이 경우는 그 부분까지 메모리수정으로 패치를 해버리던지 아니면

실제적으로 그 락을 COMMAND.COM이후의 1차프로세서로 하는

방법이 있다.

전자의 경우는 아래의 범용크랙소스에 추가 작업을 하면 해결될것이다.

하지만 이렇게 추가작업을 할경우 범용으로써의 기능이 없어지게되는 점이 불편하다.

결국 그런 락들의 크랙은 두부분의 패치를 위해서 작지만 새로운 루틴이

크랙에 매번 포함되어야 하는 불편합이 생긴다.

그렇지 않으면 이것을 모두 프로그램함으로써 범용 크랙을 만들수

있겠지만 더 간편한 방법이 있다.

후자의 경우인데, 원시적인 방법을 사용하는것이다.

락이 걸린 프로그램을 2차프로세서로 호출하는것이 아니라

크랙을 램에 상주시켜버리는 것이다.

충돌의 위험이 많지만 비교코드를 많이 둠으로써 완전히는 아니만

거의 비할수 있을것으로 생각된다.

램에 상주될경우 락이 결린 프로그램은 COMMAND.COM이 실행을하게되고

결국은 락이 걸린 프로그램의 모프로세서는 COMMAND.COM이 되어버린다.



아래는 소스이다. 비상주부분과 ISR은 똑같다. 그리고 TSR을 사용하니 더욱 간단해 졌다.

한번 실행하면 램에 상주하고 다시 실행하면 램에서 제거가된다.

자신의 램상주확인을 비교코드로 구분하기때문에 비교코드가 같은 크랙은 동시에 상주가 안될

가능성도 있다.

뿐만 아니라 해제루틴을 간단히 했기때문에 여러게의 크랙을 상주시킬경우

해제는 상주의 역순이라야 한다.






                .MODEL  TINY



HOOKINT         EQU     21h

SUBINT          EQU     3dh



INT_CS          EQU     24aah

INT_IP          EQU     3f9dh



LOCK_CS         EQU     2b54h

LOCK_IP         EQU     00aah



                .CODE

                ORG     100h

Start:

                jmp     Begin



old_codes       DB      75h,05h,0b8h

old_codes_end   LABEL   BYTE



new_codes       DB      75h,0

new_codes_end   LABEL   BYTE



oldint          DD      0



NewInt          PROC    NEAR



                push    bp

                mov     bp,sp

                push    ax

                push    bx

                push    cx

                push    dx

                push    si

                push    di

                push    Ds

                push    Es



                cmp     ah,SUBINT

                jnz     NewIntOut



                mov     ax,Cs

                mov     Ds,ax



                mov     bx,WORD PTR Ss:[bp+2]

                cmp     bx,INT_IP

                jnz     NewIntOut



                mov     bx,WORD PTR Ss:[bp+4]

                add     bx,LOCK_CS-INT_CS

                mov     Es,bx

                mov     si,OFFSET old_codes

                mov     di,LOCK_IP

                mov     cx,old_codes_end-old_codes

                cld

                repe    cmpsb

                jnz     NewIntOut



                mov     di,LOCK_IP

                mov     si,OFFSET new_codes

                mov     cx,new_codes_end-new_codes

                rep     movsb



                mov     ax,Cs

                mov     Es,ax

                mov     si,OFFSET Jumper

                mov     di,OFFSET NewInt

                mov     cx,JumperEnd-Jumper

                cli

                rep     movsb

                             sti

NewIntOut:

                pop     Es

                pop     Ds

                pop     di

                pop     si

                pop     dx

                pop     cx

                pop     bx

                pop     ax

                pop     bp

Jumper:

                jmp     Cs:oldint

JumperEnd       LABEL   BYTE



NewInt          ENDP



resident_tail   LABEL   BYTE





ENVIRADD        EQU     2ch



Begin:

                mov     dx,OFFSET crack_name

                mov     ah,9

                int     21h



                mov     ax,Ds:[ENVIRADD]

                mov     Es,ax

                mov     ah,49h

                int     21h



                mov     ax,3500h+HOOKINT

                int     21h



                mov     WORD PTR oldint[0],bx

                mov     WORD PTR oldint[2],Es



                cmp     bx,OFFSET NewInt

                jnz     Reside



                mov     ax,WORD PTR Es:[Start]

                cmp     ax,WORD PTR Ds:[Start]

                jnz     Reside



                mov     ax,WORD PTR Es:old_codes

                cmp     ax,WORD PTR Ds:old_codes

                jnz     Reside



                lds     dx,DWORD PTR Es:oldint

                mov     ax,2500h+HOOKINT

                int     21h



                mov     ah,49h

                int     21h



                push    Cs

                pop     Ds



                mov     dx,OFFSET remove_msg

                mov     ah,9

                int     21h



                mov     ax,4c01h

                int     21h



Reside:

                mov     ax,2500h+HOOKINT

                mov     dx,OFFSET NewInt

                int     21h



                mov     dx,OFFSET install_msg

                mov     ah,9

                int     21h



                mov     dx,OFFSET resident_tail

                int     27h



LF              EQU     0ah

CR              EQU     0dh



crack_name      DB      CR,LF,"Iyagi6.1 crack TSR version by [HWB]",CR,LF,CR,LF

,"Action: $"



remove_msg      DB      "Remove crack from memory",CR,LF,"$"

install_msg     DB      "TSR crack into memory",CR,LF,"$"



                DB      1024 DUP(0)



                END     Start




C) 소프트 아이스를 이용한 CSHOW 패치하기

cshow를 실행 시키면 15초를 기다려야 프로그램이 실행이 된다.
때론 무척 귀찮고 짜증나는 메세지이다.
왜냐면, 우리가 통신망에서 구할  수 있는것은 정식 등록판이 아닌 쉐어웨어 이기때문에  이런 제
약을 두는 것이다.
이런 불편을 없애고자 소트트 아이스를 이용해 패치를 해보자.

사용된 버전은 CSHOW Standard Version 8.44a [03-12-1992] 이다.

참, cshow 는 실행화일 압축을 이용한다.
실행화일 압축을 푼 후에 소프트 아이스를 실행시켜야 한다.
이유는 압축이 된 화일은  메모리에 있는 코드와 달리 실제에는   존재하지 않을 수 있기 때문이
다.
통신망에 공개되어 있는 ux 를 이용해서 압축을 풀면 될 것이다.


소프트 아이스는 프로그램을 크랙할 수 있는 우수한 도구중의 하나이다.
도스 버전과 윈도우 버전의 두 종류가 있다.
우선 소프트 아이스를 실행시킨다.
그럼 소프트 아이스는 램 상주 될것이다.


그 다음 cshow를 실행시킨다.

그러면 시작하자 마자 "띡띡띡띡" 하면서15 초를 기다리라는 대화상자가 나올것이다.

자 그러면 거기서 소프트 아이스의 핫키인 Ctrl+D 를 누른다.

그러면 소아의 화면이 뜨게 될 것이다.

자, 실제로 들어가보자.

====================================================================
             이곳에  xxxx:02be 의 어드레스의 내용이 표시된다.
 --------------------------------------------------------------------
 XXXX:000002BB       RETF   0002
 XXXX:000002BE       CMP    AL,ES:[DI]
 XXXX:000002C1       JNZ    02C5
 XXXX:000002C3       LOOP   02BE
       .              .      .
       .              .      .
       .              .      .

--------------------------------------------------------------------

 :d XXXX:02be

====================================================================

 여기서 보는 바와 같이 d XXXX:02be 명령을 한다.

 d(DUMP) 를 한다음 보면은

====================================================================
  XXXX:000002BE  26 3A 05 75 02 E2 F9 C3- .................

--------------------------------------------------------------------
 XXXX:000002BB ....................................
       .
=====================================================================

이렇게 된다.


여기서 26 3A 05 75 02 E2 F9 C3 을 적는다.

그중 코드 부분만을 보면은

RETF 0002
CMP AL,ES:[DI]
JNZ 02C5
LOOP 02BE

커서는 CMP 에 멈춰 있다.

직관적으로 볼때 계속 루프를 돌고 있음을 알 수 있을것이다.

이게 바로 15초동안 아무것도 못하게 하는 것임을 알 수 있다.

그래서 JNZ 02C5 를 없애 버린다.

NOP 으로 대체하는 것이다.

A 명령 (라인 어셈블) 을 쓰면
:A XXXX:02C1 ←
  XXXX:02C1 NOP ←
  XXXX:02C2 ←
:G ←

여기서 NOP 의 코드는 90(16진수) 이다.

A 명령을 쓴다음 다시 G 명령을 쓰면 곧바로 15초 세는 걸 중지하고 다음 화면이 나온다.

바로 "아무 키나 누르세요" 라는 메시지이다.

이제 패치가 된 것이다.
그런데 소프트 아이스는 저장이 안되니 다시 섹터 에디트로 고쳐야 한다.

많이들 쓰는 PC TOOLS 을 이용해 보겠다.

위에서 메모한  코드를 PC4 를 이용해서 F (FIND) 로 섹터를 찾는다.

그다음 그 코드중 JNZ 코드인 75를 90 으로 고친다.

75가 JNZ 인 줄은 소아에서 NOP 을 대입했을 때 75가 90 으로 변한다.

고친후 F5 를 눌러 UPDATE (SAVE) 하고서 PC4 를 나가서 CSHOW 를

실행시킨더.

곧바로 "아무키나 누르세요" 가 나올것이다.

참고로 실행화일 압축을 풀었으니 화일이 커져있을 것이다.

그러니 다시 실행화일 압축기로 압축을 하기 바란다.

좀더 응용해보면 "아무키나 누르세요"라는 메세지도 패치 시킬 수가 있을것이다.


D) Mdir-III  크랙하기
게임 위자드 프로 말고 소프트 아이스로 크랙하는 방법입니다.
MdirIII 을 예로 해서 한번 크랙을 해보죠.
여러분!! 단지 공부할 목적으로 크랙하시기 바랍니다.
국내 S/W 만큼은 돈내고 사쓰시기 바랍니다.
특히~  M 같은거~~~~~~~~~

먼저 크랙을 하기 위해서는 실행화일의 압축을 풀어내야 합니다.
실행화일을 풀어주는 유틸리티인 UNP,UX를 써서 압축을 풀어 냅니다.
이것들은 제가 제공했을겁니다.
여기서 압축을 풀어 주는것은 디버거로 작업을 할때 자체압축때문에 추적코드가 메모리상에서
보는것과 헥사에디터로 보는것과 틀려지기 때문입니다.
크랙한것을 헥사에디터로 기록 하기위해서 자체압축을 풀어내는 겁니다.

make-reg.exe는 다음과 같은 사항이 표시됩니다.

한글 이름 , 영문 이름 , 등록 번호 ,  비밀 번호    이렇게 말입니다.

소프트 아이스 WIN 을 이용하셔서 하시기 바랍니다.

먼저 WINICE.EXE를 실행하면 윈도우가 뜹니다.
그다음 MS도스쉘로 빠져  나오시기 바랍니다.
그럼 메모리 탑재 유틸리티인 wldr.exe로 make-reg.exe를 메모리에 탑재 합니다.
탑재 하는 방법은 c:\>wldr make-reg.exe 를 실행하시면 됩니다.

<중요 옵션 옵션>
여기서는 트레이싱  하는데 가장 많이 쓰이는 기능만 설명합니다.
F1부터 F10까지 있습니다.

 F4 : HERE  = 현제의 커서위치까지 트레이싱
 F5 : RS    = 현재까지 트래이싱 된 프로그램의 화면을 보여줍니다.
 F7 : T     = 싱글스텝 트레이싱
 F8 : P     = 스텝 트레이싱
 F9 : G     = 프로그램의 실행

F8키를 눌러서 스텝 트레이싱을 합니다. 그럼 얼마안가서 이러한 코드가 나올 겁니다.

   .         .
   .         .
   .         .

 ↓(XXXX세그먼트는 각자의 램환경이 다르므로 XXXX로 대체하였습니다.)

 XXXX:1041 CALL 0B28:426A <- ①
           CALL 06BB      <- ②

 ①코드를 F8키로 트레이싱하면 화면이 갈라집니다.
 ②코드를 F8키로 트레이싱하면 그냥 실행이 되버립니다.
 그러므로 F7키로 트레이싱해야 합니다.

 ②코드를 F7키로 트레이싱하고 나면 코드가 또 나옵니다.
 그럼 다시 F8키로 트레이싱합니다. 트레이싱 중간중간에 F5번을 누르면
 프로그램이 어디까지 진행이 되었나 보입니다. 확인을 자주 하십시요.

 계속 트레이싱하다보면 화면이 점점더 보이게 됩니다. 좀더 트레이싱
 하다보면 화면에 글자가 다 나오고 이젠 입력루틴이 나올차례가 되죠.

    .        .
    .        .
    .        .
  XXXX:09F9 CALL 0149 <- ①

  ①코드를 F8키로 트레이싱하면 프로그램에서 입력을 받는 입력루틴입니다.

  MdirIII에서는 이러한 코드가 4번이나 계속됩니다. 아까도 말했지만
  4번까지 입력받고 체크를 한다고 했죠? 그럼 이름을 입력하고 엔터를
  칩니다. 그럼 또 다시 소아환경으로 되돌아 오게 됩니다.
  계속 트레이싱하다보면 위와 같은 코드가 3번이나 더 나옵니다.

    .         .
    .         .
  XXXX:0A6B CALL 0149
    .         .
    .         .
  XXXX:0ADD CALL 0149
    .         .
    .         .
  XXXX:0B5A CALL 0149 <- 여기까지 비밀번호 입력루틴입니다.

  여기까지가 F8키로 실행하면 위와 똑같이 영문이름,등록번호,비밀번호
  입력받고 엔터치면 소아환경 으로 되돌아 오게 됩니다.

  F8키로 계속 트레이싱 하다보면 다음과 같은 코드가 나옵니다.

    .         .
    .         .
  XXXX:0C01 JZ  0C06 <- ①
  XXXX:0C03 JMP 0CDD <- ②

  ①를 보면 Zero플래그가 Zero일때 점프를 한다는 뜻입니다.
  하지만 임의적으로 추적을 했기 때문에 점프를 하지 않습니다.
  그러므로 e xxxx:0c01하셔서 74를 75로 봐꿔 주시면 JNZ 0C06으로 변합니다.
  그러면 Zero가 아닐때 점프를 하겠죠? 만약 고치지 않고 점프를 해봅시다.

  그리고 F8키를 눌러서 트레이싱하면 어떻게 나오죠? '입력사항에 이상이
  있다'고 나올겁니다. 고로 이부분이 첫번째 체크부분이죠. ①을 고쳐서
  점프를 해서 계속 트레이싱합니다.

    .         .
    .         .
  XXXX:0CC1 JNZ 0CDD   <- ①
  XXXX:0CC3 MOV DI,0543
    .         .
    .         .
    .         .
  XXXX:0CC9 CALL 00AB
              .
              .
            JMP 1022 <- ②

  위와는 반대 상황입니다. ①코드를 계속진행 하다보면 밑에 JMP 1022부분이
  나옵니다. JMP부분은 '입력사항에 이상이 있으니 다시 입력하라'는 코드로
  진입하게 되는 코드입니다. 그러니 e xxxx:0cc1 하셔서 75부분을 74로
  고치면 JZ 0CDD로 됩니다.
  ②부분은 무조건 분기하라는 명령이죠. 그러니 이 코드로 점프되는 코드는
  피해야 합니다. 물론 맨 마지막 종료될때는 반드시 지나야 합니다.

  그럼 JNZ 0CDD부분에서 JZ로 고쳐서 점프를 해서 다시 진행을 해봅시다.

  XXXX:0CDD CMP BYTE PTR [BP+FE22],00
  XXXX:0CE2 JNZ 0CE7 <- ①
  XXXX:0CE4 JMP 0FC3 <- ②
      .        .
      .        .
  XXXX:0CE7    .
      .        .

  ①번 코드를 보면 점프를 하지 않습니다. 그럼 점프를 하지 않으면
  ②번 코드로 가게 되겠죠? ②번코드가 어떻게 이어 지는지 u명령으로
  확인을 해봅시다. u xxxx:0fc3 ←하시면 보이죠.

      .        .
      .        .
  XXXX:0FC3    .
      .        .
  XXXX:0FCF CALL 0B28:0000
      .        .
      .        .
  XXXX:0FD9 JNZ 0FE6
      .        .
      .        .
      .     JMP 1001 <- ①
      .        .

  이런 코드가 보이게 될껍니다. ①번코드는 바로 '입력사항이 틀리다'
  코드로 가게 됩니다. 그러니 앞에서 본것과 같이 JNZ 0CE7코드를
  e xxxx:0ce2 의 75를 74로 봐꾸어서 다시 점프를 합니다.

  계속 F8번으로 트레이싱하게 되면 다음과 같은 주소에 마주치게 됩니다.

      .       .
      .       .
  XXXX:0DF4 JNZ 0DF9 <- ①
  XXXX:0DF6 JMP 0FA0
      .       .
      .       .
      .       .

  ①코드는 또 점프를 안합니다. 그러니 또 위와 같은 방법으로 고쳐서
  점프를 합니다. 계속 트레이싱하게 되면 아래와 같은 코드가 나옵니다.

  XXXX:0F1A JZ  0F2C       <- ①
      .     MOV WORD .....
      .     SUB WORD .....
      .     SUB WORD .....
  XXXX:0F2C LEA DI,[BP+FE78]
      .       .
      .       .

  ①코드는 MdirIII의 가장 핵심적인 루틴입니다. 여기서 최종적으로
  등록된번호인지 아닌지를 구분하게 됩니다. 여기서 점프를 하지 않으면
  이때까지 제대로 크랙을 하였다 하더라도 비등록판이 되니 꼭 점프를
  하드록 메모리 수정을 해야 합니다. JZ를 JNZ로 바꾸어 주면 점프를
  하게 되겠죠.

      .       .
      .       .
      .       .
  XXXX:100F JNZ 1022 <- ①
      .       .
      .     JNZ 1022 <- ②
      .       .
      .     JZ  1022 <- ③
      .     JMP 09CB <- ④
      .     MOV SP,BP
      .     POP BP
      .     RET      <- ⑤

  이제 RET가 나오는걸 보면 루틴의 끝인걸 알수 있습니다. 아까
  싱글스텝트레이싱을 했으니 당연하게 코드의 끝은 RET가 나와서 아까
  싱글스텝트레이싱을 했던 바로 다음주소로 이동을 하게 됩니다.
  쉽게 생각하십시요.

  ①,②,③에서 점프를 하지 않으면 ④에서 점프를 하게 됩니다.
  ④은 다시 입력을 받는 루틴으로 가게 되므로 ①,②,③에서 점프를
  하게 만들어 줘야 합니다. 그럼 점프를 하고 RET로 복귀를 하게 되죠.

  XXXX:1041 CALL 0B28:426A
      .     CALL 06BB <- ①
      .         .     <- ②
      .         .

  ①은 아까 F7을 눌러서 싱글스텝트레이스 한자리죠? 그러니 RET에서
  복귀를 하면 ②으로 오게 되는것입니다. 그럼 이제 F9를 눌러서
  프로그램을 완전히 실행하면 크랙은 끝이 납니다.

  그리고 자기혼자만 사용할것이라면 그냥 이렇게 메모리 수정을 통한
  크랙을 하면 되지만 다른사람이 쓸수 있게 크랙이 도는것은 위에서
  메모리 수정을 한 주소의 값을 앞,뒤를 메모지에 적어서 헥사에디터로
  수정을 하고 저장하면 됩니다.

  여기서 앞뒤로 적는다는 말은 코드가 같은게 상당히 많기 때문에
  정확성을 기하기 위해서 앞뒤의 값까지 적게되면 그만큼 정확성이
  높기 때문이니다.

초보자들이 보기에는 상당히 어려울겁니다.
어셈을 꾸준히 공부하시기 바랍니다.



