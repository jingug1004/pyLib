19회 강좌입니다.

나머지 해킹 유틸에 대해서 이야기 하겠습니다.



2-1-2 PC 헤커의 필수품 map.com

메모리멥을 보는 프로그램이나 인터럽트 벡터를 보여주거나 하는 기능을 하는 프로그램은
참 많다.
추적을 하는 프로그램도 그렇다.
그러나 램상주시켜놓고 필요할때마다 팝업해서 메모리상태를 보고,그걸 8086코드로 보여주고
원한다면 아스키로도 보여주고,어떤  인터럽트가 어떤 프로그램에 의해서 사용되고 있는지  그 프
로그램은 어떤 프로그램인지 이 유용한기능을 모두 넣어놓은 것이 바로 map.com 이다.



2-1-3 좋고 짧은 디스어셈블러 크래커

크래커라는 상당히 괜찮은 디스 어셈블러 이다.


2-1-4 소프트아이스 Win v1.1

소프트 아이스의 윈도우용 버전이다.

소프트 아이스 Win 보호모드에서 작동을 할수 있다.

 기동법은 먼저 본 프로그램을 윈도우 디렉토리내의
 임의의 디렉토리에 카피를 한후에 path를 추가한다.

 추가를 하고 나서 다시 부팅을 하셔서 winice.exe를
 실행 하시면 소아win이 win.com을 실행 시킨다.

 그다음은 도스쉘로 빠져 나와서 추적하고픈 프로그램을
 실행하고 난뒤에 CTRL+D를 누르면 된다.

 소프트-아이스 Win을 무리없이 쓰실려면 윈도우의 system.ini의
 내용을 에디트 하여 386Enh항목에 DMADRIVESIZE=044를 추가하여야 한다.







2-1-5  SOURCER

소서는 디버그(Debug)의 U(Unassemble) 명령처럼 역어셈블을  해 주는 프로그램이다.
 소서는 단번에 실행 파일이나 디바이스 드라이버, 2진 파일들을 역어셈블 소스로 바꾸어 준다.

소서는 VGA를 포함한 거의 모든 디스플레이 모드를 지원한다.
소서를 실행시킬 때에 파일 이름을 지정해 주면 파일을 로드할 수 있다.

  예) SR COMMAND.COM      ; COMMAND.COM을 로드하여 실행한다.

1) 소서의 명령어


 1. F1 (Help)

  F1 키를 누르면 Help 화면이 나오는데 이것은 소서에서 사용 가능한
  커맨드를 표시해 준다.


 2. F (file format)

  출력 형식을 LST 또는 ASM 중의 하나에서 선택할 수 있게 해 줍니다.
  LST형식으로 지정한 경우 어셈블리 소스 옆에 해당 명령어의 기계어
  코드와 함께 세그먼트의 값까지 자세하게 표시가 된다.
  어셈블리소스를 연구할 때 이와 같은 파일을 분석하면 좋다.
  ASM형식으로 지정한 경우 어셈블리의 소스 라인만 얻어진다.


 3. H (Header file)

  LST 형식으로 출력하는 경우에 각 페이지의 선두에 인쇄하는 색인을
  32바이트까지 문자로 입력한다.


 4. X (Cross referance on/off)

  데이터의 참조, 로케이션 참조, 서브루틴 참조의 세 개의 크로스
  레퍼런스 정보를 온라인코맨드로  출력하는지의 여부를 지정한다.

  ① 데이터의 참조란 데이터 영역의 변수나 정수가 참조되고 있는가를
     옵셋의 주소 표기 방식으로 지정하는 것을 말한다.

  ② 로케이션 참조란 분기선 등을 지정하는 라인이 어느 장소에서 참조
     되고 있는가를 나타내어 준다.

  ③ 서브루틴 참조란 서브루틴이 어디에서 호출되는가를 보여준다.


5. S (Segment display on/off)

  LST 파일의 형태로 출력할 때에 세그먼트 값을 붙여서 출력할 것인지의
  여부를 결정해 줍니다.


6. L (Lower or case)

  파일 내용의 영문자들을 대문자, 또는 소문자로 바꾸어 준다.


7. I (Input file)

  어셈블리하고자 하는 파일의 이름을 입력한다.


8. M (Math)

  수치 연산 프로세서의 명령을 지원할 것인지를 결정하여 준다.
  지원하는 수치 연산 프로세서는 8087/80287 이다.


9. U (up)

  만일 여러분이 특정 프로세서의 명령어 세트로 역어셈블하기를 원한다면
  이 명령으로 바꿀 수 있다. 소서는 8086~80486까지의 명령어 세트를
  지원한다. 그러나 V20/V30이 탑재되어 있을 경우에는 자동적으로
  8086모드로 된다.


10. G (Go)

  역어셈블을 시작하는 명령어이다.



2) 소서 활용하기

위의 명령어가 전부인 것은 아니지만, 위의 명령어로도 충분히 역어셈블을 할 수 있다.
그러면 이제 역어셈블을 실제로 해 보자.
소서에서 파일을 부르는 방법은 아까 보았듯이 두가지 방법이 있다.

첫째는 소서 실행시에 'SR [filename]' 이라고 하는 것이고,
둘째는 소서의 화면에서 I를 눌러 파일을 부르는 방법이다.


'SR COMMAND.COM'이라고 쳐 보자.
이 때 물론 COMMAND.COM 이 소서가  실행되는 디렉토리내에 있어야겠다.
그럼 이제 F 를 눌러 보자.
LST 파일과 ASM 파일 둘 중에 하나를   선택해서 역어셈블을 하는 것이다.
그럼 Output filename이 COMMAND.ASM으로 바뀐 것을 볼 수 있을 것이다.

T를 눌러 보면  타겟 어셈블러라는 곳의 메시지가 바뀔 것이다.
어셈블리어는 각 회사의 컴파일 프로그램에 따라 조금씩 소스 프로그램의 형식이 바뀌어질 수 있
다.
소서는 이러한 각 회사의  컴파일러에 맞추어 역어셈블을 해줌으로 역어셈블된 소스 프로그램을
다시 컴파일할 때 에러가 없이 컴파일 될 수 있도록 해 준다.

소서가 지원하는 컴파일러의 종류는 다음과 같다.

  ① MASM (MicroSoft 사의 어셈블리 컴파일러)
          Version 4.0
          Version 5.0
          Version 5.1
          Version 6.0  * 6.0은 OS/2 2.x의 응용 프로그램 생성을
                         지원한다.

  ② TASM (Borland 사의 어셈블리 컴파일러)
          Version 1.0
          Version 2.x
          Version 3.0

역어셈블한 파일을 다시 컴파일 할 때에  해당 어셈블러의  형태로 변환시키면 컴파일을 하는 데
조금이라도 보탬이 될 것이다.

   문자 U 는 지원할 수 있는 CPU의 종류를 선택할 수 있게 해 준다.
  PS/2 또는 그와 같은 기능을 하는 IBM 호환기종에는 기본적으로
  Intel사의 8086/8088 CPU가 장착되어 있거나 또는 그와 상위 호환성을
  지닌 CPU가 탑재되어 있다.

   이러한 CPU의 각각 명령어 체계는 같으나, 위로 갈수록 지원되는
  명령어의 갯수가 늘어난다. 이러한 CPU에 맞추어 역어셈블을 하면
  해당 CPU의 독특한 특성을 살릴 수 있다. 소서가 지원하는 CPU의
  형태는 다음과 같다.

   ① 8086/8088 또는 상위 호환성을 가지는 CPU
          ⅰ 80186/80188
          ⅱ 80286 Real 모드
          ⅲ 80286 Protected 모드
          ⅳ 80386 Real 모드
          ⅴ 80386 Protected 모드
          ⅵ 80486 Real모드
          ⅶ 80486 Protected 모드

   ② 기타 CPU
          ⅰ V20/30

   여러분이 CPU의 형태에 대해서 특별히 정의를 하지 않는다면 소서는
   실행시에 자동적으로 시스템에 장착되어 있는 CPU를 인식해서 세팅이
   됩니다. 특별히 지정하지 않았을 때에는 8086/8088모드로 세팅되어
   진다. 여기서 여러분이 원하는 형태의 어셈블리스트를 결정하였다면
   G 를 눌러보면 역어셈블이 될 것이다.

   그럼 역어셈블 결과를 살펴보자. 역어셈블이 끝나면 소서는 자동적
   으로 실행을 종료한다. 종료 후에 DIR 명령으로 실제로 역어셈블이
   되었는지를 확인해 보자. 파일 리스트에 COMMAND.ASM과 COMMAND.SDF
   라는 파일이 생성되었음을 확인할 수 있을 것이다



2-1-6  Windows Sorucer
이 프로그램은 Sorucer의 윈도우즈용 프로그램을 분석용이다.
분석을 할  수 있는  것은 윈도우의  EXEs,DLLs,VxDs과 OS/2의  NE등을 분석을  할 수  있다.
출력은 역시 어셈블리어이다.

2-1-7  BIOS Pre-Processor

이 프로그램은 자신이 가지고 있는 컴퓨터의 롬바이오스를 채취를 할 수 있는 프로그램이다.
이것은 씨스템용및 비디오 롬도 끄집어 내고 그밖에 다른 것도 빼낼 수 있다.
그리고 Sorucer를 이용을 하면 어셈블리어로 볼수가 있다.
이 프로그램은 추출만 할 수 있다.


2-1-8 Unpacker

로그램이 압축이 되어있을 경우 그것을 해제를 할때 사용을 한다.
참고로 말을 하자면 DBLSPACE.EXE는 압축이 되어 있다.
이것은 그냥 분석이 되지를 않는다.
이때 이것을 사용을 하면 쉽게 분석이 가능하다.
그밖에 여러가지로 이용의 가치가 있다.오락도 압축이 되어있는 경우가
있다.이것은 LZEXE나 PKLITE로 압축이 되어 있는 것도 풀지만 그밖의 IBM,Microsoft등의 압축
도 풀 수 있다.



2-1-9 Converts COM files to EXE

말그대로 COM파일을 EXE로 변환을 하는 것이다.있으면 좋지만 없어도 상관은 없는 것 같다.


2-1-10  ASM Checker

이것은 일명 Bug Finder이다.이것은 어셈블리어를 공부를 할때 필요한 프로그램이다.

2-1-11  ASMtool

Assembly Analysis Tool이라는 것으로 구조를 분석을 하는 것으로 이것
은 해커에게 꼭 필요한 프로그램이다.가격은 약간 비싸지만 꼭 있어야
한다.출력은 플로우차트로 출력을 할 수 있다.


2-1-12  Converts OBJ files to ASM

OBJ 파일을 역어셈블을 하는 것인데 OBJ를 그냥 역어셈블리어로 출력을
할 수 있다.매우 유용한 프로그램이다.Link를 하지 않고도 바로 부분별로
분석이 가능하다.


2-1-13 Turbo Debuger

각종 디버거 중의 하나로 아주 유명한 프로그램이다.

2-1-14  View-It

거대한 파일을 보거나 그 안의 내용을 검색을 할때 필요한 것이다.최소
10MByte는 가볍게 보거나 검색을 할 수 있는 프로그램이다.


2-1-15 블랙 박스

블루박스톤과 레드박스 실버박스 그린박스의 톤을 발생시키는 "블랙박스" 라는것이 있다.
블랙박스는 전화선에 특별한 전류를 흘려서 상대방이 이쪽으로 전화를 걸때 그쪽이
요금이 나오지 않고 또 추적을 안당하는 이유로 사용되고 있다.
사용시에는 사운드카드가 있어야 한다.
하지만 우리나라는 ESS(Electroic Switch System)을 쓰고 있어서 받아도 별소용이 없다.



2-1-16 에버 락

Everlock 걸린 File 을 직접 풀기 과정은 좀 복잡하니 많은 연습을 필요로 합니다.

Everlock 걸린 화일을 Debug 상에서 Load 합니다.
U 를 치면 이런 내용이 나오게 되어 있습니다.

   Mov Ax,Cs
   Mov Ds,Ax

이런 식으로 나가다가 조금 뒤에

   Nop
   Jmp 0100

이 다음의 4개의 숫자가 중요합니다.
예를들어 12,34,56,78 이라고 되어 있다고 한다면 시작번지를 구하는 방법은

Cs = Cs - 7856H , Ip = 3412
이렇게 구해서 다시 U 를 치면 이것이 원래의 프로그램입니다.
G 를 치십시오.이제는 삑삑거리던 에러가 안 나옵니다.

또한 이 방법은 Exe 화일에만 적용이 됩니다. 그리고 Everlock 버전에 상관이  없습니다.

Evmove 에 대하여 ...

요즘 Everlock 에 걸린 프로그램들이 많이 나오고 있습니다.
이 프로그램들의 원본에는 대개 Evmove.Com 이라는 File 이 있습니다.
그런데 이 Evmove.Com 을 실행시킬때 카운트를 세게 되어 있습니다.
카운트를 줄이지 않는 방법에는 여러가지가 있습니다.
그 중 하나의 방법을 소개합니다.

Evmove A: X: (원하는 드라이브)
Y 라고 치면 곧 쓰기방지가 금지되었다고 나옵니다.
그때 I (Ignore) 키를 계속 누릅니다.
약 10번 정도 누르다 보면 복사가 잘 되었다고 나옵니다.

EverLock 보다는  NeverLock 으로 바꾸는 것이 좋습니다.




팁. 등대 크랙.
크랙 방법은 pctools을 이용한 에디트입니다.
이 방법은 연구용으로 부득이하게 사용하는 것입니다.
실제 이 방법을 전파하거나 하는 행위는 우리나라 S/W 산업을 위축시키는 것이니
삼가해주시기 바랍니다.

1> setup상에서의 크랙
setup프로그램 상에는 정식 등록을 할수 있는 란이 있습니다.
거기서 정식 등록을 마치면 register.dat 라는 화일이 생성됩니다.
그 안에는 등록번호와 등록자의 이름이 저장되어있습니다.
 그러한 과정을 하기 위한 크랙 방법은  pctools상에서 setup.exe화일을 선택한후에
 find기능을 이용해 다음과 같은 코드를 찾아서 다음과 같이 고칩니다.
 3B D3 75 04 3B C1 74 20
                   ~~
                   │
                   └─ 75로 변경을 하십시요.

 그리고 또 한곳을 고쳐야 합니다.

 똑같은 방식으로
 E9 ED 00 3B C1 74 03
                ~~
                │
                └─ 75로 변경을 하십시요.

 이렇게 고치신후 setup.exe 프로그램을 실행시키고 등록메뉴에서 등록을
 하실수 있습니다. 단 등록을 하실때 많은 자리의 숫자는 나중에 다운될 염
 려가 있습니다. 그리고 영문자를 삽입하지 마십시요.

2> lhouse상에서의 크랙
   lhouse.exe프로그램은 주 실행 프로그램입니다.
   다시 말씀을 드리면
   아까와 똑같은 방법으로 다음과 같은 코드를 찾아 변경을 시키십시요.
   find기능으로 연속 찾기 하시면 그 프로그램 전체적으로 2개가 있습니다
   코드는 동일합니다.
   75 27 3B 46 F6 75 22

   이것을 다음과 같이 고칩니다.
   90 90 3B 46 F6 90 90

   이렇게 두군데를 고치면 등대는 크랙이 된것입니다.


다음의 방법도 있습니다.

크랙한 setup.exe프로그램의 크랙방법은 다음과 같이 했습니다.
정식등록을 할수 있는 란을 실행한후 덤프를 합니다.
그리고 소스를 하나씩 분석해 나갑니다. 분석하는 방법은 두가지가 있습니다.
그냥 분석하는 방법과 프로그램 실행을 하면서 하는 방법이 있습니다.
그냥 분석은 많은 시간과 노력이 필요하므로 실행하면서 분석하는 방법을 전 택하고
다른 분들도 그럴것입니다.
실행 방법도 2가지가 있습니다.
명령어 't'를 이용한 방법과 'p'를 이용하는 방법
이 두 방법의 차이점은 사용을 해보시면 금방 아실수 있습니다.
원하시는 코드를 찾으시면 그것을 변경 시키시면 됩니다.
예를 들어 setup.exe을 디스 어셈블하면...다음과 같습니다.

3BD3    CMP DX,BX
7504    JNZ 7A11
3BC1    CMP AX,CX ─┐===> 이 부분이 바로 변경을 원하는 부분의 루틴입
7420    JZ  7A31  ─┘     입니다. 위에 이에 뒷받침해줄 자료가 있지만
                           생략을 했습니다. 그것은 분석가의 재량에 맡
                           기는 수밖에 없습니다. 원하는 자료가 들어오
                           지 않으면 JA31로 점프에 잘못입력했다는 메세
                           지와 함께 BEEP를 내는 루틴으로 갑니다.
                           그럼 아무 값이나 입력 해도 통과 해야 하므로
                           다음과 같이 수정을 하는 것입니다.

3BD3    CMP DX,BX ─┐===> 원하는 곳을 찾기위한 target 코드
7504    JNZ 7A11  ─┘
3BC1    CMP AX,CX ─┐===> 변경된 루틴 이와 같이 하면 어떠한 값이들어
7520    JNZ 7A31  ─┘     와도 JA31로 점프를 하지 않습니다. 단 원하는
                           값이 들어오면 오히려 잘못 입력했다는 메세지
                           를 출력시킴..

그리고 다른 한곳도 위와 같이 하면 됩니다. 그리고 코드의 작용도 위의 상
황과 유사합니다.

3BC1    CMP AX,CX ─┐==> 원하는 코드입니다. 위와 똑같습니다.
7403    JZ  7A78  ─┘
E9E600  JMP 7B5E  ----==> 위의 코드를 찾기위한 target 코드

다음과 같이 바꾸는 것입니다.

3BC1    CMP AX,CX ─┐==> 바뀐 루틴
7503    JNZ 7A78  ─┘
E9E600  JMP 7B5E

이것말고    게임 위자드 프로로도 한번 해보시기 바랍니다.






팁. GIFLINK 1.12 크랙 입니다.
다음은 해당 영역입니다.
실제로 해보시기 바랍니다.

1) 연속 받기할때 3번째 그림부턴 흑백으로 나오던것

   00 00 01 01 00 00 00 DB
   --
   90

2) 마지막 메시지, 약간의 기다림

   74 03 E9 42 01 B8
   -- --
   90 90





팁. 다음은 나우누리의 인터넷 ROOT 영역 리스트입니다.
어떤분이 해킹한 것을 공개하셨습니다.
그냥 가볍게 보시기 바랍니다.

ls
total 11896                    4 a.out-kimgy*
   4 a.out-songjiho*          84 b.tar
   4 bash_history.jooyong      2 buf
  48 bug*                     48 bug-atrix*
   8 chk.sum                   2 deleted/
  92 du-list                  92 du-list.0403
   0 du.list                   2 du.list-sort-an-n
   8 du.list-sort-rest        30 du.list.a-n
  16 du.list.o-z               0 find.out
 176 finger                    2 go
  14 log                     128 mail*
  66 menu.hwp                  2 msg
  10 out                     124 pipdex01.jpg
 170 pipdex0=1.xb              2 pno.txt
   0 pwck.0407              9280 received
 640 received.Z                2 runaway.c-hrhur
 336 shadow                  336 shadow1
   2 shhong                    8 ss*
   2 staff.du                 90 su-success.list
   8 su.root-list             40 su.tar
   6 success.su-root           0 suid.1.23
   4 suid.print*               2 temp*
   2 va_demo/
22 sol:/home1/root>
22 sol:/home1/root>



팁.  주민등록에 관해서.

비비에스 가입시 주민등록 번호를 요구합니다. 그리고 즉각 체크하더군요.
제가 아는 바로는 주민등록 번호 체계도 국가 기밀이라고 하더군요.
그런데 다들 그 체계를 알고있고 프로그램으로 공개하고 있으니........
다음은 주민등록 체크에관한 간단한 소스 몇가지 입니다.
주민등록번호는 끝자리 숫자가 암호입니다.
즉, 앞자리 숫자의 조합을 암호화 알고리즘으로 처리하여 맨 끝자리가 나오는것이죠.
허위 기재시 앞까지는 맞았다 치더라도 끝에거 맞을확률은 10분의 1밖에 안되겠죠?
소스를 보시면 그 원리를 아실겁니다.

>>베이직 소스<<

10 CLS
100 INPUT "--> ",A$
110 A=VAL(MID$(A$,1,1))
120 B=VAL(MID$(A$,2,1))
130 C=VAL(MID$(A$,3,1))
140 D=VAL(MID$(A$,4,1))
150 E=VAL(MID$(A$,5,1))
160 F=VAL(MID$(A$,6,1))
170 G=VAL(MID$(A$,8,1))
180 H=VAL(MID$(A$,9,1))
190 I=VAL(MID$(A$,10,1))
200 J=VAL(MID$(A$,11,1))
210 K=VAL(MID$(A$,12,1))
220 L=VAL(MID$(A$,13,1))
230 M=A*2+B*3+C*4+D*5+E*6+F*7+G*8+H*9+I*2+J*3+K*4+L*5
240 N=M MOD 11
250 O=11-N
260 IF O>9 THEN O=O MOD 10
270 PRINT "*** The Last Number *** :";O
280 PRINT "*** Do You Want To Compute More ? ***"
290 A$=INPUT$(1)
300 IF (A$="N" OR A$="n") THEN 330
310 IF (A$="Y" OR A$="y") THEN 10
320 GOTO 290
330 CLS
340 END



>>파스칼 소스<<

program BIMIL;
 var
  Input  : string[13] ;
  Number : array[1..13] of byte ;
  LastNumber : byte ;
  i : byte ;
  j : word ;

 begin
  writeln('Input Number ,Please.....');
  writeln(' ex) 500123-432156 (if 500123-432156?)');
  write('Input : ');readln(Input);
  for i:=1 to 13 do val(copy(Input,i,1),Number[i],j);
  j:=Number[1]*2+Number[2]*3+Number[3]*4+Number[4]*5
     +Number[5]*6+Number[6]*7+Number[8]*8+Number[9]*9
     +Number[10]*2+Number[11]*3+Number[12]*4+Number[13]*5 ;
  j := j mod 11 ;
  LastNumber:= 11 - j ;
  if LastNumber>9 then LastNumber:=LastNumber mod 10;
  writeln('Last Number : ',LastNumber);
  writeln(' So, Right Number : ',Input,LastNumber);
 end.





>> c 소스<<

/*** a resident registration number checking program by quibbler ***/

main()
{
    char    n[14];
    int LastNo;
    printf("Enter number: 600815-201323 \(if you want 600815-201323x\)");
    printf("\n--> ");
    scanf("%s", n);
    LastNo=12-((n[0]*2+n[1]*3+n[2]*4+n[3]*5+n[4]*6+n[5]*7
           +n[7]*8+n[8]*9+n[9]*2+n[10]*3+n[11]*4+n[12]*5)%11);
    if (LastNo>9) LastNo=LastNo%10;
    printf("\nLast number is %d\n",LastNo);
}





