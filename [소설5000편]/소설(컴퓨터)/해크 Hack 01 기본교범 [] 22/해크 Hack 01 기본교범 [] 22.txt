안녕하세요.

20회 강좌입니다.


2-2 디버그의 사용

디버그는 보편적으로 쉽게 많이 사용하는 프로그램이다.
특히 DOS에서 기본적으로 제공된다는게 사용자를 많이 확보한 이유일 것이다.

2-2-1 도움말이다.

        Runs Debug, a program testing and editing tool.
        (실행 디버거,프로그램의 기능점검및 수정 프로 그램)

        DEBUG [[drive:][path]filename [testfile-parameters]]

          [drive:][path]filename  Specifies the file you want to test.
                                  (당신이 점검하고자 하는 것을 쓰는 것임)
          testfile-parameters     Specifies command-line information requir-
                                  ed by the file you want to test.
                                  (디버거의 코멘드 라인에서 실행을 바로 할
                                  코멘드의 입력)
        After Debug starts, type ? to display a list of debugging commands.
        (디버거가 실행한 후,'?'라고 치면 도움말이 화면에 나타냅니다.)

         <디버거 코멘드 쓸수 있는 명령어의 해설>

            assemble     A [address]
            어셈블          주소
               ;- 어셈블어를 직접치면 해당 번지에 번역이 되어서 바로 들어
                 간다.(해당 언어는 8086/8087/8088만임)
            compare      C range   address
             비교          비교값   주소
               ;- 비교값을 가지고 그값이 나올때 까지 비교를 하고 같은 값
                 이 있으면 멈추고 어드레스를 화면에 나타낸다.시작은 지정
                 을 해주는 주소부터 시작을 한다.
            dump         D [range]
            덤프            숫자
               ;- 숫자만큼의 HEX코드를 화면에 나타낸다.
            enter        E address [list]
            엔터           어드래스 목록
               ;- 지정된 주소에서 시작을 하는 메모리의 부분을 지정된 값으
                 로 채웁니다.
            fill         F range list
            채우기          크기  채울값(복수 허용)
               ;- 채울값을 크기 만큼 채운다.
            go           G [=address] [addresses]
            실행            주소       중단점
               ;- 현제 메모리에 있는 프로그램을 싱행합니다.
            hex          H value1 value2
            16진수          수치1  수치2
               ;- 지정한 두 매개변수 사이에 16진수 연산을 수행합니다.
            input        I port
            입력           포트
               ;- 지정한 포트에서 한바이트를 읽고 나타냅니다.
            load         L [address] [drive] [firstsector] [number]
            읽어드리기      주소      드라이브  시작위치    수치
               ;- 메모리로 파일 또는 디스크 섹터들을 읽어들입니다.
            move         M range address
            이동           범위  주소
               ;- 메모리의 블럭을 이동합니다.
            name         N [pathname] [arglist]
            이름            경로       파일이름
               ;- L(읽어드리기) 또는 W(쓰기) 명령에 대한 실행 파일이름을
                 지정하거나 수정될 실행 파일에 매개 변수를 지정합니다.
            output       O port byte
            출력                       포트 바이트값
               ;- 출력 포트에 한 바이트의 값을 보냅니다.
            proceed      P [=address] [number]
            수행            주소        수치
               ;- 루프,반복된 문자열 명령,소프트웨어 인터럽트 또는 목적
                 달성을 위한 서브루틴(Subroutine) 호출을 수행하거나 그외
                 의 다른 명령을 추적을 합니다.
            quit         Q
            종료
               ;- 현재 작업 파일을 저장하지 않고 디버그를 끝냅니다.
            register     R [register]
            레지스터        레지스터
               ;- 중앙처리장치(CPU)에서 하나 또는 그 이상의 레지스터 내
                 용을 나타내거나 바꿉니다.
            search       S range list
            찾기           범위  목록
               ;- 하나 또는 그 이상의 바이트 값의 모양을 지정된 범위에
                 서 찾습니다.
            trace        T [=address] [value]
            추적            주소        수치
               ;- 한 명령을 수행하고 모든 레지스터,플래그,해독된 명령을
                 나타냅니다.
            unassemble   U [range]
            역어셈블        범위
               ;- 바이트를 역어셈블(Disassemble)하고,주소와 바이트 값을
                 포함하여 그에 대응되는 원래의 문장을 나타냅니다.역어셈블
                 코드는 어셈블된 파일의 목록처럼 보입니다.
            write        W [address] [drive] [firstsector] [number]
            쓰기            주소      드라이브  시작위치    수치
               ;- 디스크에 수정된 파일을 기록합니다.(이 명령어는 매우 위
                 험성을 가지고 있는 것으로 사용에 주의를 요합니다.)



2-2-2 디버그(DEBUG.EXE)의 사용예이다.

디버그의 명령어와 적용 예.

    <ASSEMBLE>
      명령어 : ASSEMBLE
      기능   : 8086/8087/8088 프로세서의 니모닉 코드를 직접
              기억장치로 번역해 넣는다.
      문법   : A <Adress>

   문법적 에러가 발견되면 "^ Error"라고 표시되고 현재의 어셈블리
  번지가 다시 나타난다.  모든 수치는 16진수여야 하며 네 자리까지
  허용된다.   접두 니모닉은 그것이 가리키는 Opcode의 앞에 나타나
  있어야 하지만 다른 줄에 들어 있을 수도 있다.

  세그먼트를 변경시키는 니모닉은 CS: DS: ES: SS: 이고 Far return을
  나타내는 니모닉은 RETF이다.  또한 스트링 처리용 니모닉은 스트링
  의 길이를 반드시 명시해야 한다.  예를 들어 워드 스트링을 옮길
  때는 "MOVSW" Byte 스트링을 옮길 때는 "MOVSB"를 사용한다.

  어셈블러는 SHORT, NEAR, FAR, JUMP와 CALL명령을 만나면 지정하는
  곳이 어딘가에 따라 그 거리를 자동적으로 계산한는데 NEAR나 FAR
  와 같은 접두어를 써서 변경시킬 수 있다. 예를 들면,

     0100:0100 JMP 502  ; 2byte short jump
     0100:0102 JMPNEAR 505(JMP NEAR 505)  ; 3byte near jump
     0100:0105 JMPFAR 50A (JMP FAR 50A)   ; 5byte far jump

  NEAR는 NE로 줄여 쓸 수 있으나, FAR는 줄여 쓸 수 없다.

  DEBUG 프로그램이 오퍼랜드가 지정하는 곳의 길이가 워드인지 BYTE
  인지 알 수 없을 때는 "WORD PTR"이나 "BYTE PTR"과 같은 접두어를
  사용해서 명시해 줘야한다.  예를 들면,
        예: NEG BYTE PTR [128]
            DEC WO[SI}

   여기서 "WORD PTR" 은 "WO"로 "BYTE PTR"은 "BY"로 줄여 쓸 수
  있다. (Debug에서만 가능 합니다.)
   또한 오퍼랜드가 기억 장치를 가리키고 있는지 또는 자료
  자신인지 알 수 없을 때는 보통 사용하던 방식에 따라 괄호안에
  있는 것은 기억장치 지정으로, 그렇지 않은 것은 자료 자신으로
  구분한다.  예를 들면, 다음과 같다.

       예: mov ax, 19        ; 19를 AX 레지스터에 옮긴다.
           mov ax, [19]      ; 억장소 DS:0019에 위치하는 워드형
                               자료를 AX에 옮긴다.

  ASSEMBLE 명령어와 함께 두 개의 의사 명령어를 쓸 수 있는데,
  DB 명령어는 byte 값을 직접 기억 장치에다 넣을 때 쓰이고 DW
  명령어는 워드 값을 넣을 때 쓰인다.   예를 들면,

       예: DB 1, 9, 9, 4, 'Jin Seong Park'
           DW 1111, 2222, 3333, "BACH"

  Assemble 명령어는 모든 레지스터 간접 명령을 제공하는 데
  아래와 같이 쓰인다.

       add bx, 34[BP+2]
       pop [bp+di]
       push [bx]

  또한 모든 명령어에 대해서 그 동의어를 함께 쓸 수 있는데 다음에
  같다.

       loopz 100
       loope 100
       ja    333
       jnbe  333

  8087 프로세서용 명령어를 쓰려면, Wait나 FWait와 같은 접두 명령을
 드시 명시해야 한다.  예를 들면,

       fwait fadd st, st(3)      ; This line will assemble
                                 ; an FWAIT prefix
       ld tbyte ptr[bx]          ; This line will not assemble


    <COMPARE>
      명령어 : COMPARE
      기  능 : <Range>에 의해서 지정된 기억 장치의 일부분을
               <Address>에서부터 시작되는 같은 크기의 부분과
               비교한다.
      문  법 : C <Range> <Address>

   두 부분이 같으면 아무것도 표시되지 않고, 틀리는 부분이 있을
  경우는 아래와 같은 형식으로 내용을 보여준다.

        <Address1> <Byte1> <Byte2> <Address2>

     예: 아래의 두 명령어는 같은 결과를 보이는데 둘 다 100에서
         1FF까지의 기억장치상의 블럭과 300에서 3FF까지의 블럭을
         비교하라는 명령어이다.
             C100, 1FF 300 or C100L100 300


    <DUMP>
      명령어 : DUMP
      기  능 : <Range>에 의해서 지정된 기억장치상의 특정 부분의
               내용을 표시한다.
      문  법 : D <Range>

   <Range>가 주어져 있으면 그 부분의 내용이 표시되고, 주어져 있지
  않으면 이 전에 DUMP 명령어에 의해서 표시되었던 곳 다음 (ds:100)
  에서부터 128byte가 표   사용자 스택 포인터는 이 명령어의
  처리를 위해 적어도 6byte를 지정할 수 있게 되어 있어야 한다.
  이 GO 명령어는 iret 명령을 써서 테스트하는 프로그램으로 jump하게
  된다.   사용자 스택 포인터가 정해지고 사용자 플레그, 코드 세그먼트
  레지스터, 인스트럭션 포인터등이 사용자 스택에 저장된다.
  따라서 사용자 스택이 잘못 되어 거나 너무 좁으면 오퍼레이팅 시스템
  이 망가진다.    인터럽트 코드(0CCH)가 각 중지점에 삽입되게 되는데
  이 중지점을 나타내는 명령을 수행하게 되면, 모든 중지점이 다시 원래의
  명령으로 환원된다.   그러나 중지점에서 끝나지 않으면 원래의 명령으로
  환원되지 않는다.

    예: 다음과 같이 입력하면
       GCS:7777
    현재 기억장소내에 있는 프로그램이 CS세그먼트의 7777h로부터 수행을
    시작하게 되며 수행이 끝나면 래지스터와 플레그의 내용이 표시된다.
    중지점을 만나서 일단 프로그램 실행이 정지된 후 다시 GO 명령어를
    입력하면 다시 중지점에서 부터 실행을 한다.


   DOS의 DEBUG.EXE에 대해 완죤히 철저히 해부합니다.
   일체의 질문은 사양합니다.


    <HEX>
      명령어 : HEX
      기  능 : 주어진 두 파라미터를 가지고 16진수를 계산한다.
      문  법 : H <Value> <Value>

   먼저 두 파라미터를 더하여 그 합을 표시하고 그 다음 첫 번째
  파라미터에서 두 번째 것을 뺀 후 그 차를 같은 줄에 표시한다.

    예: 아래와 같이 입력하면
        H 0 1
        결과값 --> 0001 FFFF


    <INPUT>
      명령어 : INPUT
      기  능 : <Value>에 의해서 지정된 포트로부터 1byte를 읽어 들여
               그 값을 표시한다.
      문  법 : I <Value>

   포트의 번지로는 16Bit숫자를 쓴다.

     예: 아래와 같이 입력하면
         I2F8
         지정된 포트에 있는 데이타 값이 55h라 하면, Debug 프로그램은
         이 값을 받아들이고
             55
         라고 표시한다.

    <LOAD>
      명령어 : LOAD
      기  능 : 파일을 읽어 들여 기억 장소내에 로드한다.
      문  법 : L <address> [<Drive> <Record> <Record>]

   BX:CX에 읽어 들일 파일의 Byte 수를 넣는다.  파일명은 Debug
  프로그램을 불러 수행시키는 명령어를 칠 때처럼 표시하거나
  N 명령어를 써서 표시할 수 있는데, 이 두 방법 모두 CS:5C에 있는
  CONTROL 블럭에서 쓰는 형식에 따라 파일명을 지정해 준다.
   파라미터 없이 L 명령어를 치게 되면 CS:0100에서부터 파일의 내용이
  로드되며 BX:CX에는 읽어 들인 Byte 수가 넣어진다.  <Address>파라미터
  는 파일을 로드하는 시작번지를 지정하며, <Drive> <Record> <Record>
  가 주어지며 파일이 아니라 디스크상의 섹터단위로 로드가 수행된다.
   <Drive>의 지정은 0=A; 1=B; 2=C와 같이 나가며 첫 번째 <Record>
  파라미터로 지정된 섹터에서부터 두 번째 <Record> 파라미터로 지정된
  갯수 만큼의 섹터가 로드된다.

    예: 아래와 같이 DEBUG 프로그램을 시작했다고 가정하면
         C:\debug
         -nfile.com
         이제 file.com이란 파일을 로드시키려면
         -L
         이라고 하면 된다. 그러면 DEBUG 프로그램에 의해서 로드가
         수행되고 다시 DEBUG 프롬프트가("-")가 나타난다.
         어떤 파일의 일부분이나 특정 레코드만을 로드하고 싶을 때의
         예를 들면,

          L0BBA:0100    0          0F             FF
           (Address) (Drive) (처음 읽을 섹터) (255개의 로드할 섹터)

         DEBUG에 의해 15번(0Fh) 레코드에서 시작해서 255개(FFh)의
         레코드가 번지 0BBA:0100에서부터 로드가 끝나면 다시 DEBUG
         프롬프트가 나타난다.   만일 주어진 파일이 .exe 확장명을 가진
         파일이라면 그 파일의 헤더에 명시된 로드 번지에 Relocation될
         것이고 <Address> 파라미터가 있다면 무시된다.  파일의 헤더
         자체도 로드될 떼는 빠지기 때문에 실제 파일의 크기와 기억
         장소에 로드된 크기와는 다르다.

         또한 주어진 파일이 .hex 파일일때에는 그 파일의 명시된 번지에
         로드되는데 <Address> 파라미터가 있는 경우는 그 값을 더해서
         로드할 번지를 결정한다.

          섹터를 직접 읽어 들여 에디트할 정도의 실력은 되지 않은 관계
         로 더 이상의 추가 설명을 못 드리겠군요.
          대 부분 이것은 그리 필요하지 않을 것 같군요.

    <MOVE>
      명령어 : MOVE
      기  능 : <Range>에 의해 주어진 기억 장소의 일부분을 <Address>
               로 부터 시작되는 곳에 옮긴다.
      문  법 : M <Range> <Address>

   옮긴 장소와 옮겨지는 장소가 중첩되는 경우에도 데이타가 손실되는
  일없이 이동이 진행되는데 중첩되어 손실될 가능성이 있는 곳부터 먼저
  이동된다.   <Range> 와 <Address>가 작은 번지에서 큰 번지로 되어
  있으면 블럭의 뒷부분부터 이동이 진행되고 반대로 큰 번지에서 작은
  번지로 되어 있으면 앞쪽에서 부터 이동이 진행된다.
   이 M 명령어를 수행할 때 옮겨지는 블럭에는 새로운 데이터를 써 넣는것
  이 아니므로 그대로 남아있게 된다.  따라서 실제적으로 한 부분의 내용을
  다른 부분에 복사해 넣는 것과 같게 된다.   그래서 이동의 순서가 중요한
  것이다.

    예:  아래와 같이 입력하면
          MCS:0100 110 CS:500

   DEBUG는 CS:0100을 CS:0510에, CS:10F를 CS:50F에 하는 식으로 데이터를
  복사해 나간다.  이러한 이동의 결과를 보고 싶으면 M 명령에 사용한
  <Address>파라미터를 가지고 D 명령어를 수행하면 된다.


    <NAME>
      명령어 : NAME
      기  능 : 파일명을 지정한다.
      문  법 : N <Filename> [<Filename>........]]

   N 명령어는 두 가지 기능을 수행한다.  첫째는 다음에 올 LOAD나
  WRITE 명령어에서 사용될 파일의 이름을 지정하는 것이다.
  그래서 파일명을 지정해 놓지 않고 DEBUG를 시작했더라도 뒤에 원하는
  파일을 쓸 수 있계 된다.  둘째는 현재 디버깅하고 있는 파일 (프로
  그램)에 파라미터로 쓰이는 파일명을 지정하는 것잿령어를 실행한다면 현재


         디버깅하고 있는 파일 qedit.exe가 file2.dat라는 이름으로
         저장된다.   이와 같은 뜻하지 않은 결과를 피하려면 N 명령어
         를 반드시 LOAD나 WRITE 명령어 직전에 사용하도록 해야 한다.

    N 명령어를 사용하면 네 군데의 기억 장소가 영향을 받게 되는데
  다음과 같다.
             CS:5C       첫 번째 파일의 FCB
             CS:6C       두 번째 파일의 FCB
             CS:80       명령어로 주어진 문자열의 수
             CS:81       명령어로 주어진 모든 문자열.

    N 명령어에 첫 번째 파라미터로 주어진 파일의 FCB(File Control
   Block)가 CS:5C에 만들어지고, 두 번째 파라미터가 주어졌으면 그
   파일의 FCB가 CS:6C에 만들어진다.  그리고 N 명령어를 칠 때 입력한
   문자 수(제일 앞에 있는 N 명령어 제외)가 CS:80에 기록되며 그때
   입력한 실제의 문자들이 CS:81에서부터 시작해서 차례로 저장된다.
    (역시 이 경우에도 N 명령어 제외)

     예:  DEBUG qedit.exe
             -Ntest.txt
             -G
             -
          위의 경우 GO 명령어는 기억 장소에 있는 파일을 다음과 같은
          명령어가 주어진것처럼 실행된다.
             qedit.exe test.txt
                 위와 같이 하면 DEBUG 프로그램은 4F값을 출력 포트 2F8로

         보낸다.

    <QUIT>
      명령어 : QUIT
      기  능 : DEBUG 프로그램의 수행을 종료
      문  법 : Q

   Q 명령어는 파라미터를 하지 않는다.  이 명령어에는  재
  디버깅하고 있던 프로그램을 디스크에 저장하지 않고 그대로 DEBUG
  프로그램의 수행을 끝낸 후 DOS로 돌아간다.


    <REGISTER>
      명령어 : REGISTER
      기  능 : 한 개 이상의 CPU 레지스터의 내용을 표시한다.
      문  법 : R <Register_name>

    <Register_name>이 주어지지 않으면 레지스터 save영역의 내용이
   덤프되고, 모든 레지스터와 플레그의 내용이 표시된다.

    한편 <Register_name>을 주게 되면 그 레지스터의 값 PE NC_

     여기서 의미있는 플레그의 값을 아무 순서로나 주게되면 DEBUG
     프로그램은 플레그의 내용을 바꾼 후 DEBUG 프롬프트인 "-"를
     표시할 것이다.

         NV UP DI NG NZ AC PE NC_OVDNDIPLZRACPECY (Return)
     이제 원하는 대로 플레그가 바뀌었는지 보려면 R 또는 RF 명령어를
     다시 사용하면 된다.

         RF
         OV DN DI PL ZR AC PE CY_





    <SEARCH>
      명령어 : SEARCH
      기  능 : 주어진 기억장소상의 <Range>에서 <List>와 같은 스트링
               이 있나 검색한다.
      문  법 : S <Range> <List>

    <List>는 하나 이상의 Byte값으로 되어 있는데 같은 Byte값은
   스페이스나 커머로 분리된다.   <List>가 두 개 이상의 Byte값으로
   이루어져 있을 때는 제일 처음에 있는 Byte의 번지만이 구해지고
   한 개의 Byte값으로 되어 있을 경우에는 <Range>상에 나타난 모든
   번지가 구해진다.

    예:  다음과 같이 입력하면
         SCS:100 110 45
         아래와 같이 디스플레이 되거나 만약 일치되는 값이없다면
         단지 DEBUG 프롬프트만을 표시할 것이다.
             04EE:0104
             04EE:010F
             -




    <TRACE>
      명령어 : TRACE
      기  능 : 한 인스트럭션을 수행한 후 모든 레지스터와 플레그의
               내용이 수행된 인스트럭션을 표시한다.
      문  법 : T [=<Address>] [<Value>]

    =<Address>가 주어지면 그 주어진 번지에서부터 TRACE가 수행되며
   <Value>가 주어지면 그 값 만큼의 단계를 Trace한다.
    이 명령어에는 8086, 8088 프로세서의 하드웨어 Trace 기능을 이용
   하므로 ROM에 들어 있는 인스트럭션도 TRACE할 수 있다.

   예:  T 라고 명령어를 입력하면 DEBUG 프로그램은 그 한 인스트럭션을
        수행한 후 레지스터와 플레그의 내용을 표시해 준다.
        현재의 위치가 04EE:0113이라 한다면

        AX=0E00 BX=09FD CX=9FDA DX=10FF SP=1000 BP=0100
        SI=0000 DI=0000 DS=04EE ES=04EE SS=04EE CS=04EE
        IP=0113 NV UP DI NG NZ AC PE NC
        04EE:0113 CD21                  INT  21

        아래와 같이 입력하면
         T=0113  10
        DEBUG 프로그램은 0113으로부터 시작해서 10h개의 인스트럭션
        을 실행하면서 각 인스트럭션이 끝날 때마다 레지스터와 플레그의
        내용을 표시한다.  인스트럭션이 진행되고 새로운 정보가 표시될
        때마다 화면은 차례대로 올라가며 중간에 정지시켜 놓고 보고
        싶으면 <CONTROL-S>를 사용한다.


    <UNASSEMBLE>
      명령어  UNASSEMBLE
      기  능 : 기억장소의 내용을 읽어 들여 그것을 다시 소스 프로그램
               으로 바꿔준다.   이때 그 번지와 메모리상의 값도
               표시된다.
      문  법 : U <Range>

    이 명령어를 수행하고 난 결과는 어셈블리어 프로그램과 비슷할
   것이다.  파라미터없이 U 명령어를 치면 전에 U 명령어에 의해 번역되던
   다음에서부터 20h byte만큼 다시 번역되며 <Range>를 지정하면 그
   <Range>에 포함되는 모든 Byte들이 번역되는데 <Range>가 <Address>
   만으로 주어지면 그 번지에서부터 20h byte 만큼만 번역된다.

     예:  다음과 같이 입력하면
          U04EE:0100 L10
          DEBUG 프로그램은 04EE:0100에서부터 16Byte를 번역한다.
          그 결과는 아래와 같은 형식일 것이다.

             04EE:0100   206472  AND [si-72],ah
             04EE:0103   69      DB  69
             04EE:0104   7665    JBE 016B
             04EE:0106   207370  AND [BP+DI-70],DH
             04EE:0109   65      DB  65
             04EE:010A   63      DB  63
             04EE:010B   69      DB  69
            04EE:010C   66      DB  66
             04EE:010D   69      DB  69
             04EE:010E   63      DB  63
             04EE:010F   61      DB  61

        아래와 같이 하면,
          U04EE:0100  0108

             04EE:0100   206472  AND [si-72],ah
             04EE:0103   69      DB  69
             04EE:0104   7665    JBE 016B
             04EE:0106   207370  AND [BP+DI-70],DH

        메모리의 내용이 바뀌면 원래의 소스 프로그램의 내용과 바뀐
        내용이 디스어셈블리한 내용과는 다를 것이다.  따라서 이 U
        명령어를 사용하면 이 변화를 쉽게 소스 프로그램에 반영시킬
        수 있다.


    <WRITE>
      명령어 : WRITE
      기  능 : 디버깅하고 있는 파일을 디스크에 저장한다.
      문  법 : W [<Address> [<Drive> <Record> <Record>]]

    파라미터없이 W 명령어를 수행하면 미리 BX:CX에다 디스크로 출력할
   파일의 Byte수를 기록해 놓아야 하며 파일은 CS:0100에서부터
   시작한다.   <Address>만을 지정하면 그 번지에서부터 파일이 시작되는
   것으로 된다.   또한 LOAD나 GO 명령어를 사용한 후 W 명령어를
   파라미터 없이 쓰려면 BX:CX의 값을 다시 정해야 한다.  어떤 파일을
   로드해서 수정을 가했다 하더라도 그 전체의 길이만 변하지 않았다면
   이름이나 시작번지는 바뀌지 않는다는 사실에 주목한다.
    파일명은 DEBUG를 부를 때 주거나 N 명령어를 사용해서 지정해야
   하는 데 이 두가지 방법에 의해서 파일을 지정하면 그 파일명이 CS:5C
   에 있는 FCB에서 쓰이는 형식과 같이 주어지게 된다.

   <Drive>는 파일이 쓰여질 디스크 드라이브를 지정하며 앞의 <Record>는
   써 넣기 시작하는 논리적 레코드의 번호를, 뒤의 <Record>는 쓰여질
   레코드 수를 나타낸다.

   ##주의:  물리적 레코드번호를 가지고 절대 섹터에다 출력하는 것은
            매:0100
            에서부터 시작되는 파일을 집어 넣는다.


      Error 메세지 ----------

    DEBUG 프로그램을 사용하는 동안 아래와 같은 에러 메세지를 받을 수
   있는데 에러 메세지가 나타나면 현재 수행 중이던 명령어는 중단되어
   버린다.   그러나 DEBUG 프로그램 자체는 끝나지 않는다.

   ______________________________________________________________
  | 에러 코드 |            정              의                    |
  |___________|__________________________________________________|
  |           |잘못된 플레그 값                                  |
  |    BF     |잘못된 값을 가지고 플레그의 값을 바꾸려고 할 때   |
  |           |발생한다.                                         |
  |___________|__________________________________________________|
  |           |너무 많은 중지점                                  |
  |           |GO 명령어에서 열 개 이상의 중지점을 지정했을 경우 |
  |    BP     |발생한다.  열 개 이하로 중지점의 갯수를 줄 여 다시|
  |           |GO 명령어를 수행한다.                             |
  |___________|__________________________________________________|
  |           |잘못된 레지스터 지정                              |
  |    BR     |허용되지 않는 레지스터 이름을 가지고 Register명령 |
  |           |어를 썼을 경우에 발생한다.                        |
  |___________|__________________________________________________|
  |           |두 개 이상의 플레그값                             |
  |           |한 개의 플레그에 서로 반대되는  두가지 플레그 값을|
  |    DF     |주었을 경우에 발생한다.   RF 명령에서는 플레그에  |
  |           |한 가지 값 만 주어야 한다.                        |
  |___________|__________________________________________________|


그럼 간단한 실습을 해보겠습니다.
만물상 2.0 데모판을 사용하면 10초동안 기다리라는 메시지가 뜹니다.
이것은 전에 말한 cshow 의 15초 메시지와 아주 유사합니다.
이것을 디버그로 잡아보겠습니다.

debug seemain.exe
l
g
하고서 Ctrl+Break키를 누르면 카운터를 세던중에 빠져 나옵니다.
밑에 보면 Cmp 비교 JZ 01AE 이런 메시지가 뜹니다.
XXXX:036B 번지입니다.
그곳을 9090(NOP)로 우면 딱 한번만 카운터를 셉니다.
간단하죠?
여기의 디버그 메뉴얼을 잘 읽어보면 쉽게 이해가 갈겁니다.




**다음은  Debug Script 파일을 이용한 패치 프로그램 작성입니다.
아래 예제는  패치 프로그램이 어떤 식으로 구성되어 지나를 알려주기 위한 것입니다.
디버그/배치만 알면 간단한 패치는 노력 여하에 따라 작성 가능합니다.

디버그 스크립트 파일을 이용하면 아주 적은 용량으로 패치시키는 프로그램을 작성할 수
있습니다.
디버그의 기본적인 명령어와 배치파일에 대한 기초지식만 알면 누구나 작성할 수 있습니다.
패치 프로그램을 작성하려면 이것 역시 어느 부분을 패치해야 할지를 먼저 알아야 합니다.
일단 디버그로 로드해서 S(찾기) 명령으로 해당 오프셋 번지를 확인하고
패치할 데이터와 함께 아래와 같이 적습니다.


E 323C 90 90
E 3B48 90 90
E 3B4D 90 90


 그 다음 배치파일 안에 명기된 파일명을 해당 파일로 고치기만 하면 됩니다.
(여기에서는 TELIX.EXE)      TELIX.EXE를 TELIX.EX_로 바꾼 것은
EXE/HEX파일은 디버그에서 저장이 되지 않기 때문입니다. 패치가 끝나면
다시 원래대로 리네임합니다.

아래는 디버그 스크립트 파일을 포함한 배치파일 형태의 패치 프로그램 소스로
파일명은 TELIX322.BAT입니다.

@echo off
goto batch
N TELIX.EX_
L
E 323C 90 90
E 3B48 90 90
E 3B4D 90 90
W
Q
:Batch
if not exist TELIX.EXE goto error
ren TELIX.EXE TELIX.EX_ > nul
debug < TELIX322.BAT > nul
echo Patched complete!
ren TELIX.EX_ TELIX.EXE > nul
goto end
:Error
echo TELIX.EXE not found!
:End


이상입니다.


위 배치파일 자세한 설명 입니다.

@echo off      <명령 진행 상황을 표시하지 않는다.>
goto batch     <레이블 batch로 점프한다.>
N TELIX.EX_  ┐<Telix.ex_파일을 디버그로 로드한다.>       ─┐
L            ┘                                             │실제 디버그에서
E 323C 90 90   <오프셋 번지 323C, 323D 번지를 90h로 대치.>  │처리되는 명령어
E 3B48 90 90   <     "      3B48, 3B49         "         >  │(윗 부분은 모두
E 3B4D 90 90   <     "      3B4D, 3B4E         "         >  │  에러 처리됨.)
W              <바뀐 메모리를 저장한다.>                    │
Q              <디버그를 빠져 나온다.>                    ─┘
:Batch
if not exist TELIX.EXE goto error   <TELIX.EXE파일이 존재하지 않으면 점프.>
ren TELIX.EXE TELIX.EX_ > nul       <TELIX.EXE를 TELIX.EX_로 리네임.>
debug < TELIX322.BAT > nul          <디버그 상의 패치로 핵심(!) 부분.>
echo Patched complete!              <패치가 완료되었다는 메시지 표시.>
ren TELIX.EX_ TELIX.EXE > nul       <다시 원래대로 리네임.>
goto end                            <레이블 end로 점프.>
:Error
echo TELIX.EXE not found!           <TELIX.EXE가 존재하지 않는다는 메시지
:End                                                               출력.>



20회강좌 까지 끝이 났습니다.
