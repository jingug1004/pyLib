
제  목: [강좌] /etc/services 파일

/etc/services 파일은 호스트에서 사용가능한 서비스의 리스트를
제공한다.

대충 그 형식을 보면..

tcpmux          1/tcp           # TCP port service multiplexer
echo            7/tcp
echo            7/udp
discard         9/tcp           sink null
discard         9/udp           sink null
systat          11/tcp          users
daytime         13/tcp
daytime         13/udp
netstat         15/tcp
qotd            17/tcp          quote
ftp             21/tcp
# 22 - unassigned
telnet          23/tcp
# 24 - private
smtp            25/tcp          mail
# 26 - unassigned
time            37/tcp          timserver
time            37/udp          timserver

-------         ------          ----------
   1              2                   3

1번 공식 서비스 명입니다.
2번은  포트 번호
       / 프로토콜 이름
3번 별칭 입니다.

여기서 중요한 것은 1번 2번 이죠..
보통 각 유닉스에는 포트라는 것이 존재합니다.
우리가 일반적으로 telnet 접속으로 하이텔이나 나우를 들어갈때
telnet home.hitel.co.kr 이라고 하죠?
하지만 이것을 좀더 자세히 보면 23번 포트로 들어가는 것입니다.
단지 그것이 디폴트 설정이 되어있기 때문이죠.
즉
telnet home.hitel.co.kr 23 이라고 하면 telnet home.hitel.co.kr 이랑 같은
역활을 하는 거죠.
이것의 정의는 위에 보다 시피.
telnet          23/tcp
이것으로 정의가 되어있죠?
이번에 ftp 로 어떤 서버로 들어갈때 디폴트 설정은 21번 포트 입니다.
ftp mud.bigtel.co.kr 와  ftp mud.bigtel.co.kr 21 과는 같은
역활입니다.
이것은
ftp             21/tcp
이렇게 정의 되어있습니다.

상당히 재미있죠?
우선은 여기까지..
/etc/services 는 건드리지 않는 것이 좋습니다.
바꿀 필요가 거의 없거든요.
해킹할때 빼고요.
나중에 고급 강좌에서 강의하겠지만 /etc/services 파일과
/etc/inetd.conf 파일을 건드려서 데몬을 제어하는 방법이 있습니다.
이것을 이용하여 백도어를 만들 수가 있습니다.

여기까지..


 제  목: [강좌] 중급 쉘 프로그램 (1) 함수편

[ 중급 쉘 프로그래밍 (1) ]

쉘 프로그래밍이라고 함수가 없을쏘냐..

있다..

아주 간단한 초 특급 함수를 만들 수 있다.

mail() {

}

위의 경우가 함수이다.
위의 함수를 호출할때는 mail 이라고만 하면 호출된다.
변수는 전역 변수처럼 모든 곳에서 쓰인다.
함수안에서만 지역 변수로 쓰인다.

ex )
$cat > a
#!/bin/sh
echo " 테스트용 프로그램입니다."
bbs() {
echo -n "시작 하겠습니까? (Y/n)"
read RE
if [ "$RE" = "n" ]
    then exit
fi
echo "계속 합니다."
}

bbs
^D
$ ./a
테스트용 프로그램입니다.
시작 하겠습니까? (Y/n)
y
계속 합니다.

이런 식의 함수 사용입니다.
상당히 쉽죠?

이것을 제대로 하면 좀더 효율적인 프로그램을 짤 수가 있습니다.

그러면 아이디와 패스워드를 맞추는 프로그램을 간단히 함수를 이용해서 만들어
봅시다.

$ cat > a
#!/bin/sh
echo "이것은 인증 프로그램입니다."
id() {
echo -n "당신의 아이디 : "
read id
if [ "$id" = "loveyou" ]
    then  passwd
fi
echo " 없는 아이디 입니다. "
}
passwd() {
echo -n "당신의 암  호 : "
read pass
if [ "$pass" = "lovelove" ]
    then echo "딩동댕~ 축하~ "
    exit
fi
echo "패스워드가 틀렸습니다."
exit
}
bbs

^D
$ ./a
이것은 인증 프로그램입니다.
당신의 아이디 : loveyoufsd^?^?^?^?^?
 없는 아이디 입니다.
$ ./a
이것은 인증 프로그램입니다.
당신의 아이디 : loveyou
당신의 암  호 : love
패스워드가 틀렸습니다.
$ ./a
이것은 인증 프로그램입니다.
당신의 아이디 : loveyou
당신의 암  호 : lovelove
딩동댕~ 축하~

이렇게 되죠.
신기하나요?

조금더 신기하게 하려면
암호를 넣기 전에 이런 문장을 넣어보세요

stty -echo
그리고 나서 암호를 다 받은 후에
stty echo
이렇게 하면 되요.

위에서 -echo 는 타이핑하는 것이 안보이게 하는 거고
echo 는 타이핑한 것이 보이도록 하는 설정이에요.

ex)
stty -echo
echo -n "당신의 암  호 : "
read pass
stty echo


제  목: [강좌] 네트웍 설정하기

우선 레드햇 리눅스에서의 설정을 보자..

아주 쉽다.
우선 랜카드를 잘 잡아주어야 한다.
랜카드를 잘 잡으려면 커널 컴파일을 다시 해야 한다.
커널 컴파일시 네트웍카드에서 잘 선택을 했다고 가정하고
네트웍 설정을 한다.
만약 ne2000 호환 랜카드가 있다면 인식하는 것은 커널 컴파일
없이 간단하게 인식시킬수 있다. 즉 초창기 설정된 상태에서 말이다.
이런 명령이면 된다.
modprobe ne irq=랜카드 irq 번호 io=자신의 io 번호
ex) 나의 랜카드 설정시..
modprove ne irq=11 io=0x340
이다..

이렇게 해서 랜카드를 인식 시켰다.

그 후에 네트웍 설정을 해야 한다.
우선..
/etc/HOSTNAME 이라는 파일안에 자신의 도메인을 넣는다.
그 다음에 /etc/hosts 라는 파일에
127.0.0.1               localhost localhost.localdomain
xxx.xxx.xxx.xxx         이름.도메인.    이름

ex) 210.123.119.13          mud.bigtel.co.kr mud

그 다음이 중요하다.

/etc/sysconfig/network 파일을 에디터로 편집해야 한다.
그 파일안에는 이런 내용이 들어가야 한다.
NETWORKING=yes
HOSTNAME=서버 도메인    (ex: mud.bigtel.co.kr )
DOMAINNAME=이름을 뺀 도메인만..  (ex: bigtel.co.kr)
GATEWAY=ip주소      ( ex: 210.123.119.254 )
GATEWAYDEV=eth0
이렇게 들어가면 된다.
그 다음에 편집할 파일은
/etc/sysconfig/network-scripts/ifcfg-eth0 을 에디터로 불러온다.
DEVICE=eth0
IPADDR=서버의 ip 를 넣는다.  ( ex: 210.123.119.13 )
NETMASK=255.255.255.0   보통이렇게 한다.
NETWORK=ip 주소.255   옆의 예를 들면 ( ex:210.123.119.255 )
앗..다시 위에꺼 정정
NETWORK=ip 주소.0   ( ex:210.123.119.0 )
BROADCAST=ip주소.255   ( ex : 210.123.119.255 )
ONBOOT=yes
이렇게 하면되요.
휘리릭.
상당히 쉽죠?
보통 슬랙 웨어 리눅스의 경우 netconfig 라는 것이 있지만
수동으로 해야 할 경우 이렇게 하면되고요.
엑스 윈도우에서 할 수도 있지만 그 이게 편합니다.

제  목: [강좌] IFS 에 대한..

쉘은 명령어의 인수를 분리하기 위해서 IFS라는 쉘변수를 이용한당.
그래서 보통 IFS는 공백 , 탭 , 개행문자 등을 사용한다.
그런데 만약에 IFS = / 라고 되어 있다면 우리가 입력한 /bin/sh 라는 파일을
실행시켜보면 sh 파일이 실행이 되는게 아니라 bin 이라는 파일이 실행되며
뒤의 sh 파일은 bin 프로그램의 인수로 인식한다.
즉, main(int argc , **argv) 에서 argv=[2]를 sh 라고 인식해버린다.

그러나 이런 문제를 과거까지는 통했지만 지금은 안통한다.
그중 해결책중 하나는
 어떤 프로그램내의 system()이나 popen() 함수를 사용하여 해결할수 있다.
system("IFS=' \t\n'; export IFS; /bin/sort /tmp/name");
popen("IFS=' \t\n'; export IFS; PATH=/bin;/usr/bin echo test");
여기서 쉘변수를 정의해주어도 export명령을 사용하지 않는이상 쉘이 이것을
받아 들이지 않는다는 것을 유념해야 한다.


 제  목: [강좌] C 언어 강좌

1부 문법편
문법과 그에 따른 간단한 예제를 선보일 예정입니다.
그리고 흔히 볼수 있는 예제, 예를 들면 풀다운 메뉴
라던지 간단한 데이터 베이스를 다룰수 있는 것 혹은
파일 입출력 예제들을 다루게 될 것입니다..

그리고 비디오 카드 처리에 관해서는 다루지 않을
생각입니다. 비디오 카드는 각 시스템 마다 다루고
또 윈도우 프로그램으로 넘어가는 시점에서 굳이
이것을 다룰 필요가 있다고 생각치 않기 때문입니다.


2. 응용편

이제까지 배운 문법들을 이용해 자료구조 부분들과
수치 해석을 하는 부분을 다루게 될 것입니다.


3. 객체지향편

C언어를 좀더 확장해서 객체지향언어 C++를 다루어
볼 예정입니?

----------------------------------------------------

============================================================
시작하기 전에

C언어를 사용하는데 있어 필요한 것은 compiler 라고 하는 것이
필요합니다. compiler는 C언어를 컴퓨터가 알아 들을수 있도록
만들어 주는 도구라고 보면 됩니다. 일반적으로 쉽게 구할수 있는
것이 Turbo-C 인데 이것은 언어가 아니고 Borland 사에서 만든
C언어 번역기 입니다.
compile 이란 말은 영어로 번역이란 뜻이 있습니다. 그리고 BASIC
같은 언어는 interpreter방식을 사용하는데 interperter와 compile의
차이는 앞의 것은 소스 코드를 하나씩 번역을 하면서 실행하는
반면에 뒤의 것은 소스 코드 전체를 번역한 후 실행코드를 만든다음
실행합니다.

일반적인 프로그램들은 대체로 compile 방식을 취하게 됩니다. 일단
comile을 하면 목적코드(.obj) 라는 것이 만들어 지죠. 그리고 링크
라는 과정을 통해 실행 파일 (.exe)가 만들어 집니다. 우리가 실행
하는 것은 마지막 단계까지 이루어 지고 난후 만들어진 *.exe 를
실행하는 것입니다.

그리고 앞으로의 모든 코드는 여러분이 어떤 컴파일러를 사용하던지
상관없이 예제 코드를 만들 생각입니다. 간혹 MS-C 라던지 VISUAL
C++로 컴파일 하셔도 상관없을 것입니다. 참고로 제가 사용하는
컴파일러는 볼랜드 C++ 3.1 입니다.

===============================================================



제 1부 문법편


가장 간단한 형태의 C program 을 만들어 보겠습니다. 이 예제는
C라는 언어를 만든 아저씨가 만들 유명한 예제이기도 하죠.. (^_^)

#include 

main()
{
  printf("Hello World\n");
}


이 코드로 compile하고 link 하면 화면에 멋있는 결과가 나타날
겁니다. 짜짠!~.. 저도 맨 처음엔 무척 신기하고 너무 즐거웠죠..
혹 컴파일 방법을 모르시는 분은 개인 메일을 주시면 됩니다.

혹 turbo-c 를 사용하신다면 ctrl+F9 하시면 모든게 해결이 되죠.

결과:

Hello World



이제부터는 위 예제를 설명하기로 하죠..

#include 

이것은 C언어에서 사용하고 있는 standard input/output 라이브러리를
위해 필요한 라인입니다. 바로 printf() 함수가 여기에 정의되어
있죠. 이렇게 여러 함수 정의나 자료의 정보가 담겨 있는
파일을 헤드 파일이라고 합니다. 일반적으로 확장자를 .h 를
사용하죠. 중요한 것은 stdio.h 는 이 컴파일러가 기본적으로
제공하는 헤드 파일이기때문에 < > 로서 감싸주어야 합니다.


main()

이 부분은 main() 함수의 정의및 선언입니다. 정의와 선언은 다음에
다루기로 하고 어쨌든 C 언어는 무조건 시작을 main()함수부터
합니다. 만약에 main() 이 없으면 에러가 생기죠..


{
  printf("Hello World\n");
}


여기서 보면 블럭 기호가 있죠. C언어는 모든 부분이 블럭단위로
구성되어 있습니다. 그래서 함수를 시작하면 먼저 함수이름을 쓰고
그런다음에 { .. } 블럭 기호를 사용해서 그 안에 여러 내용을
기술한 다음에 다시 블럭을 닫습니다. 그리고 여기에

 printf("Hello World\n");

라인이 있는데 이것을 출력을 위한 함수 입니다. C 언어 자체에는
printf() 함수가 존재하지 않습니다. 이것을 함수이죠.. C 언어는
모두 함수들로 구성되어 있습니다. 그래서 만들기도 쉽죠..
모두 필요한 기능을 원하는 위치에 만들고 불러 사용하기만 하면
되니까요..

혹 다른 문장을 출력하기 위해서는 'Hello World' 대신에 다른
문장을 넣어 주면 됩니다. 마지막에 있는 '\n' 은 출력을 끝내고
새로운 라인을 만들라는 뜻입니다. 그리고 중요한 것은 마지막의
세미콜론입니다. 이것은 한 라인이 끝났다는 것을 의미합니다.
만약에 이것을 사용하지 않는다면 무수한 에러가 생기죠. 그래서
초보자분들이 고생하는 것중에 하나이랍니다. 저도 고생한 경험이
정말 많습니다..

이상에서 컴파일 하고 링크하는 과정에서 에러가 있다면 다음을
점검해 보세여..

(1) 대소문자 구별을 제대로 했는가? (모두 소문자입니다)
(2) 문장의 마지막에 세미콜론(;)을 제대로 붙였는가?

그래도 이상이 있다 그러면 즉각 질문해 주세여..


다음은 자료형을 살펴 보기로 하죠..

C언어의 자료형은 IBM PC(16 Bit Computer)기준으로

(1) 문자형 : char
(2) 정수형 : int
(3) 실수형 : float
(4) void형 : void

의 네가지가 있습니다.

char 형

char형은 문자를 다루기 위해 사용되어지는 자료형입니다.  보통 1 Byte로
사용되죠.. 이 1 Byte는 총 8비트, 그러니까 2^8 = 256. 즉 0-255까지
사용할수 있는 자료형입니다. 0-255 이면 ASCII 코드를 표현할 수 있죠.
컴을 만든 사람들이 미국애들이다 보니 어쩔수 없이 ASCII를 사용하는데
그 코드는 0 - 255까지 만들어 있습니다. 그래서 char 형을 사용하면 그
코드들을 이용할수 있답니다. 예를 들어 65라고 하는 숫자는 ASCII 코드로
'A' 에 해당하는 문자입니다.


int 형

말 그대로 정수형입니다. 정수를 다루기 위해 만들어 진 자료형입니다.
대체로 2 Byte을 사용합니다. 총 2^16 = 65536 의 수를 표현할수 있습
니다.


float 형

실수형을 다루기 위해 만들어진 자료형이죠.. 보통 4 Byte를 사용합니다.
이것은 지수부 표현을 위해 8비트, 가수부를 위해 23비트를 사용합니다.
그리고 1비트를 부호의 표현을 위해 사용된답니다.


void 형

이것은 어떤 자료형도 아닙니다. 그냥 비어 있다는 뜻입니다. 다른 식으로
표현하면 어떤 자료형으로도 바뀔수 있다는 얘기도 되죠.. 그렇지만
변수를 이 void 형으로 선언할수는 없습니다. 함수에서 어떤 값을 되돌
리고자 할때 아무것도 되돌리지 않으려면 이것을 사용하면 됩니다.
앞으로 배워나가면서 이것에 대한 설명을 하기로 하죠.


그리고 부호를 다루기 위해 각 키워드 앞에는

signed, unsigned, long

가 붙을수 있습니다. 덧붙여 short 가 있지만 이것은 IBM-PC에서는
생략해도 별 상관없습니다. 모든 자료형은 맨앞의 비트를 (MSB) 부호
표현을 위해 사용하고 있습니다.
signed인 경우에는 MSB(Most Significant Bit, 최고 높은  bit)가 0이면
양, 1이면 음을 표현하기 때문에 그냥 char 을 사용하신다면 -128 ~ 127
까지 사용할수 있습니다. (0이 포함되므로 127까지)
unsigned는 자료가 음수가 사용되지 않을 경우에 사용됩니다. unsigned
char 를 사용한다면 0-255까지 사용할수 있습니다. 그리고 C언어에서는
그냥 char 이라고 선언하면 자동으로 signed라고 인식합니다.
그리고 long을 사용하면 현재 사용하는 바이트의 2배를 나타냅니다.
예를 들면 long (int), long double 등이 있죠.

그러면 다음의 예제를 보도록 하죠..  이번의 결과는 상당히 특이한 결과를
보일것입니다.

/* IBM-PC 16 비트 머신일 경우 */
#include 

main()
{
  char a;
  unsigned char b;

  a = -1;
  b = -10;

  printf("a = %d, b = %d \n", a, b);
}


의 프로그램의 결과는

a = 255, b = 246


위 결과는 정말 특이하죠.. 이게 왜 이런지 아시는 분은 C 언어를 상당히
하고 있다고 봐도 될것 같습니다.
그럼 분석을 해 보도록 하죠..

-1  = (1111 1110) (2진수) (255 + (-1) + 1 )
-10 = (1111 1010) (2진수) (255 + (-10) + 1)

   -3   1111 1100
   -2   1111 1101
   -1   1111 1110
    0   0000 0000
    1   0000 0001
    2   0000 0010
    3   0000 0011

왜 이런고 하니 컴은 뺄셈을 하지 않기 때문입니다. 대신 보수 계산이란 방식으로
덧셈을 하죠.. 즉 -1의 보수는 위와 같은 1111 1110 이랍니다.. 근데 printf() 함수

란 녀석은 출력할 때 오직 %d 십진수 출력으로만 하기 때문에 255 하고 246이란
결과가 나오는 것입니다.

오늘은 여기까지만..

     No.234 이름:이남철   이용자번호:nextstep 일시:11/13 17:35 총쪽수:29
제목:[강좌] C언어를 배운다/3                            검색어:강좌           
--------------------------------------------------------------------------
--



이번에는 제어구조에 대해 알아보도록 하죠.

제어문이란 프로그램의 흐름의 바꾸는 명령문을 말하죠. 그 종류는 아래와 같습니다
.


if  .. else
switch .. case
for
while
do - while
goto
break
continue


이중에서 goto 문의 거의 사용을 하지 않습니다. 아니 사용하지 말아야 하는 것중의
하나입니다. 어쨋든 사용법은 아래와 같습니다.


goto 문 ( goto label; )


goto문은 프로그램의 실행을 지정된 레이블이 있는 위치로 강제로 옮기는 명령어입
니다.
레이블명 뒤에는 반드시 :를 붙이며,goto명령과 결합된 레이블 뒤에는 :를 붙이지
않습니다.


이번에는 for 문을 보도록 하죠.

for(초기치;비교;증감치) {
  ...
  }


예제를 보면서 더 설명을 하도록 하죠.

/* 이 예제는 1부터 100까지의 합을 구하는 프로그램입니다. */

#include 
main()
{
  int n;
  int sum =0;

  for(n=1;n<=100;n++) {
     sum = sum + n;
     }

  printf("\n sum is = %d", sum);
  printf("\n n = %d", n);

}

실행 결과는

sum is = 5050
n = 101

입니다. 예제에서 볼수 있듯이 for문은 초기치 n = 1 부터 시작합니다. 그리고 n이
100과 같을
때까지 계속 반복하게 됩니다. 만약 for문 블럭안에 실행할 문장이 한 문장으로 충
분하다면
블럭 기호를 사용할 필요는 없습니다. 그리고 n이 101이 되는 이유는 간단합니다. f
or문의
실행순서를 보면 먼저 초기치를 설정한 후 그 다음 비교를 합니다. 참이면 블럭안의
문장을
실행하고 그 다음 증감을 합니다. 다시 비교하고 실행하고 증감하죠.. 이런식으로
진행되기
때문에 n은 100이 아니라 101이 되죠. n++ 는 n = n+1 과 같은 결과를 나타냅니다.
요건은
나중에 연산자가 가서 좀 더 상세하게 설명하죠..

이번에는 if .. else 문을 보도록 합시다.


if(조건) {
   ..
 }
else
{
   ..

}

간단한 구조죠.. 음..
처음에 조건을 검사한 다음에 참이면 그 처음 블럭을 아니면 else 에 있는 블럭을
실행하게
되는 구조입니다. 여기서 else문을 없어도 무방합니다. 그렇지만 앞의 경우와 다른
처리를
원한다면 꼭 필요하겠죠.. 그럼 예를 보도록 하죠.

이번에 예제는 입력받은 숫자가 홀수 인지 아니면 짝수인지 확인하는 프로그램입니
다.
준비하시고 쏘세요.. ^^;

#include 

main()
{

  int a;

  scanf("%d", &a);

  if (a % 2 == 0)
     printf("\n Input data is even...");

  else
     printf("\n InPut data is odd...");

}


아주 간단한 프로그램이죠.. 앗 그런데.. 못 보던 연산자가 있네요.. == 연산자와 %
연산자 이죠..
앞에 것은 대입연산자가 아니라 같은가를 묻는 연산자이고 뒤의 것은 나머지 연산자
입니다..
즉 어떤 수를 얼마로 나누면 생기는 나머지를 계산해 주는 연산자입니다. 만약 입력
받았던 숫자가
11이였다면 위의 결과를 아래와 같겠죠.


11

Input data is odd...


이것은 11%2 = 1 이기때문에 else 블럭이 실행되겠죠. 만약 이 연산자가 마음에 안
든다면 다른
방법을 사용할 수도 있습니다.. 자료형의 특수성을 이용하는 방법입니다. if 문의
조건을
이렇게 바꿔 보세요.

a / 2 * 2 == a


음.. 혹 이해가 가시는 분 손 드세요.. 윽.~~
이렇게 놓은 실력을 가지고 계신분이 있다니.. 이제 하산해도 되겠네요.. 이 단원만
^^;

설명을 하자면 변수 a는 정수이죠.. 그래서 먼저 나누기 2를 실행하면 소수점이하는
모두 잘려 없어지게 되는 겁니다. 만약 입력 받은 숫자가 짝수이라면 나누기 2, 곱
하기 2를
실행한다고 해도 변화가 없죠. 반면에 홀수라면 나누기 2를 하고 곱하기를 하면 영
결과가
달라지게 됩니다..

11 / 2 = 5
5 * 2 = 10

이제 완죤히 아시겠습니까?
이 코드를 좀 젬있게 바꿔보죠.. 아래처럼 if 블럭을 바꾸는 겁니다.

  if ( a % 2 )
     printf("\n Input data is odd...");

  else
     printf("\n Input data is even...");


요것이 무엇인가 하면 C언어에서 비교하는 방법을 한눈에 보여주는 겁니다. C언어에
서
참은 0 이 아닌 모든 숫자가 오면 참이 됩니다. 반대로 당연히 0 이면 거짓이 되는
거겠죠.
또 나중에 NULL 을 배우시겠지만 NULL 역시 거짓이 됩니다.

그럼 요런 예를 보시죠.

#include 

main()
{
   if ( 1 )
      printf("\n 이건 참입니다..");
   else
      printf("\n 요건 거짓이당가.. ");

}

결과는 음.. 말안해도 될 것 같네요.. 모르심 한번 해보시는 것도 괜찮습니다..

다른 예를 한번 볼께요..


#include 
{
   int a, b, c;
   int max;

   scanf("%d %d %d", a, b, c);

   if ( a > b )
   {
      if ( a > c )
         max = a;
      else
         max = c;
    }
   else if ( b > c )
           max = b;
        else
           max = c;

   printf("\n Max = %d", max);
}


이것은 세 수 중에서 제일 큰 값을 찾아내는 겁니다. 보시면 else if 문이 나오는데
별 특이한 것은 없습니다. 구문을 쓸때 베이직처럼 붙여서 사용하시면 안된다는 거
죠.


자.. 이제 while 문장을 배워봅시다.. 제가 제어문에서 가장 많이 사용하고
있는 겁니다. 어떤 분들은 do - while 이 좋다고 하시는데 전 이제 좋네요..
구문은 아래와 같습니다.


while (조건)
{
   ...
 }


조건이 참인 동안에는 블럭안을 계속 수행하게 됩니다. 아니면 블럭을 벗아나게 되
죠..

음.. 1 부터 100 까지의 합을 구하는 while 예제입니다.

#include 

main()
{
   int i=1;
   int sum = 0;

   while (i<=100)
   {
     sum = sum + i;
     i++;
    }

    printf("\n sum = %d", sum);
}


첨에 i=1 부터 시작하고 sum은 0으로 초기화, 그리고 나서 while 문에 도달하죠. 먼
저 i가
100보다 작으므로 while 블럭안을 실행.. 그러면 sum은 차례로 i 값을 더해가게 될
겁니다.
이제 i가 101이 되면 그 문장을 벗어나겠죠.. 중요한 것은 여기까지 sum은 모두 100
까지
합을 가지고 있을 겁니다. 제어구문의 제어변수는 중요하므로 얼마까지 계산되는지
정확하게
해 둘 필요가 있습니다.
그리고 출력.. 결과는 앞의 for문과 같은 sum = 5050 이 나온답니다.. ^^;


음. 그러면 위의 예를 좀 더 응용해서

/* 1+(1+2)+(1+2+3)+...+(1+2+3+...+100)의 합을 구하는 프로그램 */

 #include 

 main()
 {
   int i;
   long part_sum, total_sum;

   i = 1;
   part_sum = total_sum = 0;

   whiile (i<=100)
   {
      n = n + i;
      sum = sum + n;
      i++;
   }

   printf("합계 = %ld\n",total_sum);
}


이제 분석을 해야 할 시간이군요.
part_sum = total_sum = 0;은 total_sum에 0을 대입하고, total_sum 값을 다시
part_sum에 대입하라는 의미입니다. 이것은 연산자의 결합성에 의해 일어나는
것입니다. 연산자의 우선순위와 결합성은 프로그래밍을 할 때 아주 중요한데 일단
생략하고 그냥 간단히 대입연산자 = 는 우결합성을 가진다고 알고 있자.
다른 예를 볼까요?

 a = b = c = d = e = 1;

먼저 e에 1을 대입하고, 다시 e를 d에, d를 c에 요런 식으로 대입이 되죠..
음. 그렇지만 앞의 예에서 보다시피 변수 선언때는 연속으로 대입을 하면 안됩니다.
요렇게 말이죠.

 int i=j=0;

이제 제어 구문이 거의 막바지에 이르렀네요.. 그럼 switch - case 를 배워보죠.


switch .. case문 (선택제어문)


switch (변수 나 식)
{
  case 식1:
            .....
            break;
  case 식2:
            .....
            break;
  ....
  ....
  case 식n:
            .....
            break;
  default: ....
}

 여기서 식들은 반드시 상수나 상수식이어야 합니다. 아님 에러가 생기죠.
switch문안의 변수나 식을 처리한다음 그 결과로서 각 case문을 찾아가게
됩니다. 만약 값이 일치하는 곳이 없으면 default다음의 문장을 수행합니다.
case 다음의 문장들은 여러 개의 문장을 나열할 수 있지만 블럭은 아닙니다.
그런데 이문장들은 break문을 만나기 전까지는 빠져나가지 않고 그 아래 문장을
계속 수행하게 됩니다.

그럼 좀 그럴듯한 예제를 만들어 보죠..
음. 두개의 숫자와 연산기호를 받아들여 계산기를 만들어 보죠..
예를 들어 5 + 3 하면 8 하고 결과가 나타나게 말입니다.

 #include 

 main()
{
   int a, b;
   char operator;

   scanf("%d %c %d", &a, &operator, &b);

   switch(operator)
   {
      case '+' : printf("\n %d + %d = %d", a, b, a+b):
                 break;
      case '-' : printf("\n %d - %d = %d", a, b, a-b):
                 break;
      case '*' : printf("\n %d * %d = %d", a, b, a*b):
                 break;
      case '/' : printf("\n %d - %d = %d", a, b, (float)a/b):
                 break;
      default  : printf("\n operator is not valid..");
    }

}


프로그램을 간단히 설명하면 scanf()에서 두개의 숫자데이터와 연산자를
입력받아서 switch..case문에서 그 연산자에 맞는 case를 찾아갑니다.
그런 다음 연산자에 맞게 각 출력을 하죠..
음..


다음은 중첩된 제어구문 예를 보이고 있습니다. 제가 만든게 아니고
다른 책에서 배껴 온 겁니다. 참고 많이 하세요..


예제. 구구단을 출력시키는 프로그램

#include 
#include 

main()
{
  int i,j;

  for(i=2;i<=9;i++) {
     printf(" === %d 단 ===\n",i);

  for(j=1;j<=9;j++)
     printf("%3d * %3d = %3d\n",i,j,(i*j));

  puts("아무키나 누르시오..");
  getch();
  }
}

예제. 어떤 수까지 그 이내에 들어 있는 모든 소수를 찾는 프로그램

/* 소수 추출 프로그램(C Primer Plus에서 발췌) */
#include 

main()
{
  int number, divisor, limit;
  int count = 0;

  printf("범위를 입력하세요.(2보다 커야함) :");
  scanf("%d",&limit);

  while (limit < 2) {       /* 입력오류 검사 */
     printf("다시 입력하라: ");
     scanf("%d",&limit);
   }
  printf("1에서 %d까지의 소수들은..\n",limit);

  for (number=2;number<=limit;number++) {
      for (divisor=2;number%divisor != 0;divisor++)

      if (divisor == number) {
          printf("%5d ",number);
          count++;
          if (count % 10 == 0)  /*한줄에 10개의 소수출력*/
             printf("\n");
       }
  }
  getch();
}

제가 분석해 드릴수도 있지만 그래도 직접 짜보신다음 분석해
보시는 게 실력 향상에 도움이 될 겁니다.
마지막으로 break나 goto 문은 프로그램의 구조적인 면을 반감시키므로
되도록이면 쓰지 않도록 하시는 게 좋습니다.
끝.. 제어문을 끝내게 되서 정말 기분이 좋군요..
어젠 비가 왔는데. 혹 감기 드신 분들은 없는지.. 그럼 다음번엔
연산자와 연산우선순위에 대해서 공부해 보도록 하겠습니다..


연산자 및 우선순위

그럼 이번에는 C에서 사용되는 연산자와 그들 사이의 관계를 알아보겠습니다.

연산자란 자료조작을 하는 어떤 부호를 말하는데, 그 대상을 오퍼랜드라구 하죠.
사용되는 종류는 아래의 표와 같습니다. 아래 표는 어떤 책(임인건님의 터보C
정복)에서 내용을 가져왔습니다. 물론 다른책에도 있는 내용이구요. 너무 방대
하고 양이 많아서 기냥 가져왔습니다. 양해바랍니다.

아래표를 모두 외우라는 것은 아니니깐 걱정하지 마시고, 그냥 프로그램을 사용
하고  작성하면서 서서히 익혀나가면 됩니다.  혹 중간에 애매하다 싶으면 다시
이 표를 참조하시면 됩니다. C 언어의 연산자는 결합방식과 그 우선순위에 따라
연산을 행하게 되는 데 중요한  것은 프로그램에서 그 결합 방식과 우선 순위를
사용하는 사람이 최대한 쉽게 서술하여야 문제점이 적어진 다는 점입니다.

 아무리 좋은 코드라도 (어렵게 서술하여 이해가 어렵지만 짧은 코드) 남들이
이해가 어렵다면 그 코드는 좋은 코드라고 하기 어렵죠. 될수 있으면 쉽고 보기
좋게 만드는게 좋은 코딩방식이랍니다.


 <표1> 각 연산자들의 종류와 우선 순위
+-----------+-------+-----------------------------------+----+
| 대 분 류  |소분류 |    연        산      자           |결합|
|           |       |                                   |규칙|
+===========+=======+===================================+====+높다
| 일 차 식  |primery| ( ) [ ] -> .                      | -> |
+-----------+-------+-----------------------------------+----+
|단항 연산자| 단 항 | ! ~ ++ -- - cast연산자 * & sizeof | <- |
+-----------+-------+-----------------------------------+----+
|           | 승 제 | * / %                             | -> |
|           |-------+-----------------------------------+----+
|           | 가 감 | + -                               | -> | 우
|           |-------+-----------------------------------+----+
|           |쉬프트 | << >>                             | -> |
|           |-------+-----------------------------------+----+
|           | 비 교 | < <= > >=                         | -> | 선
|           |-------+-----------------------------------+----+
|이항 연산자| 등 가 | == !=                             | -> |
|           |-------+-----------------------------------+----+
|           |비트AND| &                                 | -> |
|           |-------+-----------------------------------+----+
|           |비트XOR| ^                                 | -> | 순
|           |-------+-----------------------------------+----+
|           |비트 OR| |                                 | -> |
|           |-------+-----------------------------------+----+
|           |논리AND| &&                                | -> | 위
|           |-------+-----------------------------------+----+
|           |논리 OR| ||                                | -> |
+-----------+-------+-----------------------------------+----+
|삼항 연산자| 조 건 | ? :                               | <- |
+-----------+-------+-----------------------------------+----+
|  치   환  |       | = += -= *= /= %=                  |    |
|           | 치 환 |-----------------------------------| <- |
| 연 산 자  |       | >>= <<= &= ^= !=                  |    |
+-----------+-------+-----------------------------------+----+
|순차 연산자| 순 차 | ,                                 | -> |낮다
+-----------+-------+-----------------------------------+----+


기본적으로 산술연산자는 일반 계산과 동일하게 사용됩니다. 증감연산자라
불리는 ++, -- 연산자는 사용법을 이미 말한바 있지만 다시 한번 그 의미를
되새겨 보도록 하죠..

 ++ : 변수의 값을 하나 증가시킨다.
 -- : 변수의 값을 하나 감소시킨다.

기억하시겠나요?
음. 기억이 안나신다구요.. 설마~~??

그럼 다음의 예제를 보면서 위 두 연산자의 묘미를 한번 돌아보겠습니다.


#include 
main()
{
        int a = 1, b;

        b = a++;
        printf("\n a = %d, b = %d", a, b);

        b = ++a;
        printf("\n a = %d, b = %d", a, b);


        b = a++ + ++a;
        printf("\n a = %d, b = %d", a, b);

}

 상당히 어렵죠.. 혹 위의 결과를 모두 정확히 예측하신 분들은 이미 연산자에
대해서 상당히 공부하신 분이라 생각이 드는군요.  그런 분들은 적어도 이번
연산자 부분을 건너 뛰어 넘어가셔도 될 거라봅니다. 음.. ^^;
프로그램의 결과입니다.

a = 2, b = 1
a = 3, b = 3
a = 4, b = 3
a = 6, b = 9

다른 것은 몰라도 마지막 부분은 맞히신 분이 있을까요? 상당히 궁금하네..


b = a++;

처음에 a를 b에 대입한 다음 a를 1만큼 증가시키고 출력하면 a = 2, b = 1

b = ++a;

a를 1만큼 먼저 증가시킨다음 b에 대입하면 a = 3, b = 3.

b = a++ + ++a;

이번 연산을 덧셈이므로 표에서 보면 알수 있듯이 연산식의 결합방향은 왼쪽에서
오른쪽입니다. 결론부터 얘기하자면 왼쪽 수식결과는 4, 오른쪽 수식 결과는 5.
그래서 b의 값은 9가 되죠. 그리고 a는 두번의 증가를 하게 되므로 6이 되구요.

먼저 b의 결과에는 왼쪽에서 증가되기전 a의 값이 사용되고 오른쪽 수식에서는
1을 증가시키고 난후의 a값이 사용되므로 합이 9가 되죠.

이런 증감연산자 형태를 앞에서 사용되면 전위형, 뒤에서 사용되면 후위형이라고
합니다. 전위형인가 후위형인가에 따라 프로그램은 완죤히 결과가 달라질수 있습
니다. 다음의 예제를 보죠.. 일부로 만든 예제가 아니라 실제 프로그램을 했을때
많이 발생하는 버그입니다.


/* 1부터 100까지의 합을 구하는 프로그램입니다. */
#include 

void main()
{
  int a = 0, sum = 0;

  while ( ++a < 100 )
        {
                sum = sum + a;
        }

        printf("\n sum = %d, a = %d", sum, a);

  sum = 0;
        a = 0;

  while ( a++ < 100 )
        {
                sum = sum + a;
        }

        printf("\n sum = %d, a = %d", sum, a);

}

상당히 코드가 길어져 버렸네요. 두 개의 프로그램으로 작성해야 하지만..
좀 귀찮아서 하나의 형태로 만들어 버렸습니다. 자 이제 결과를 얘기해도록
하죠.. 결과는 제가 말하지 않겠습니다. 여러분이 직접 이 코드를 작성해서
한 번 해보세요.. 한번 전위형으로, 다른 한번은 후위형으로 해서 해보시면
그 결과를 다르다는 것을 쉽게 알수 있을 겁니다. 왜 그런지는 이미 앞에서
말한 것과 같습니다.


다음은 저도 다른 책에서 본 것인데요.. 상당히 잼 있어서 옮겨 적습니다.

#include 

void main()
{
  int a = 10;

  printf("a = %d, a = %d\n", ++a, a++);

}

프로그램의 결과는

a = 12, a = 10

이것은 printf()함수의 특성때문입니다. 인자를 넘겨 줄때 뒤부터 넘겨 주기
때문에 생기는 현상이죠. 먼저 a를 사용하고 다시 증가, 앞의 인자에서 먼저
증가, 출력하면 12, 10이 출력된답니다. 별 중요하지 않지만, 교훈은 얻을수
있죠.  적어도 한 문장에서는 증감 연산자를 동시에 사용하면 잘못된 결과를
얻을수 있다는 것. 정말 중요한 교훈이랍니다. 다음의 예에서도 볼수 있는데
역시 잘못 사용되고 있는 방식중에 하나입니다.

#include 

void main()
{
  int a = 3;
        int result;

        result = a + 4 * ( a++ + 1);

        printf("\n result = %d, a = %d", result, a);

}

결과는

result = 20, a = 4


이것은 연산자 우선순위 문제와 관련있습니다. () 부분이 가장 연산순위가
높기 때문에 일어나는 현상입니다. 어쨌든 잘못된 연산형태중의 하나이죠.
제가 말하고 싶은 것은 증감연산자를 사용할 때는 명확한 형태의 연산에서
만 사용해야 한다는 겁니다.


다음에 설명할 연산자는 치환연산자입니다.이 연산자들은 거의 모든 연산
자과 결합을 해서 만들수 있기 때문에 자주 사용되는 몇 가지만 소개하겠
습니다.


+=, -=, *=, /=, %=, &=, |=, ^=, >>=, <<=


그럼 다음의 예제를 보면서 설명하기로 하겠습니다.


/* 치환연산자 예제입니다. */
#include 

void main()
{
        int a = 3, b = 4;

        a += b;                /* a = a + b */
        b -= a;                /* b = b - a */
        a *= 2;                /* a = a * 2 */
        b /= 3;                /* b = b / 3 */
        a %= b;                /* a = a % b */

        printf("\n a = %d, b = %d", a, b);

}

이상에서 보듯이 별 어려운 연산자들은 아닙니다.


제  목: [강좌] ftp 서버 환경 설정하?

ftp 설치하기는 상당히 쉽습니다.
대부분의 리눅스&유닉스는 기본적으로 설치가 되어있습니다.
그렇다면 이를 효율적으로 운영하려면 환경설정을 제대로 해야 합니다.
우선 anonymous 인원수 제한..

/etc/ftpaccess 파일에서 만들수 있다.
limit   anony     20   Any        /etc/msgs/msg.toomany
위에서 anony 라는 클래스명은 따로 만들어야 하지만.
그냥 all 로 바꾸어도 상관없다.
Any 는 언제나. 20명의 제한을 두고..
이를 넘길 시에는 /etc/msgs/msg.toomany 파일을 보여준다.


첫 로긴시 나오는 메세지는 어디에?
/home/ftp/welcome.msg 라는 파일을 보여준다.

디렉토리를 이동시 나오는 메세지..
각 디렉토리의 .message 파일을 보여준다.

passwd-check rfc822 enforce 라고 /etc/ftpaccess 파일에
집어 넣으면 됩니다.

여기까지..

제  목: [강좌] 레드햇 리눅스 ppp 접속하기

리눅스 상에서 ppp 접속을 하시면 일반 유닉스 계정 처럼.
엑스 윈도우나 기타 등등에서 telnet 주소 이런 형식으로
인터넷을 여행할수 있습니다.
그 일련의 과정을 아주 잘 설명하신 글이 있습니다.
글에 아무런 경고 성 글이 없는 것으로 보아 자유롭게 배포해도
되는 듯 합니다.


 제  목:[참고] 레드햇 세연,모뎀으로 PPP 접속

레드햇을 쓰신다면 X-windows 상에서 Network Configuration 을 사용하셔서 편하게

환경 설정을 하실 수 있습니다. 그렇지 않다면 직접 디렉터리를 이동해서 해당파일

을 편집해주면 됩니다. (이 경우는 밑의 참고를 확인하세요. 제가 나름대로 확인해

봤지만 혹시라도 더 편집해야할 파일이 필요한지도 모르겠습니다. 그러니 웬만하면

Network Configuration 을 이용해서 하는게 좋겠죠.)

  매우 중요한 사실 하나. 알짜 레드햇의 경우 PPP 를 이용하려면 반드시 고쳐야만

하는 파일이 있습니다. 이 파일을 수정하지 않을 경우 PPP 를 이용할 수 없습니다.

  #cd /etc/ppp/

하셔서 options 파일의 lock 앞에 #을 붙여주세요. #lock 로 말이죠.


==========================================================================
===

 알짜 레드햇 X-windows 의 제어판에서 Network Configuration



  ① Names

     Hostname : 사용하고 싶은 호스트 이름. 아무거나

     Domain : hitel.kol.co.kr

     Nameservers : 204.252.145.2

  ② Hosts

     기본적으로 127.0.0.1 의 localhost 가 있을겁니다.

     Add 버튼을 누른 후 IP : 204.252.145.2  Name : hitel.kol.co.kr

  ③ interfaces

     여기에도 기본적으로 127.0.0.1 의 localhost 가 있네요.

     역시 Add 버튼 누른 후 PPP 선택. 그러면 Phone Number, login, password 를

     물어보는데 어짜피 세연을 이용해서 할 것이므로 안 적어도 됩니다. 자,이제

     새로 생긴 ppp0 항목에 커서를 대고 Edit 를 누릅니다.

     · Hardware : 모뎀 속도 알아서 적고, 모뎀 포트는 /dev/modem

     · Communication : 그냥 넘어 갑니다.

     · Networking

      - Active interface at boot time : 부팅 때 마다 접속하겠다는 얘기인데

        세연을 이용해 필요시만 쓸 것이므로 체크 안하셔도 됩니다.

      - Set default route when making connection(defaultroute) : 체크합니다.

      - Restart PPP when connection fails : 접속이 실패했을 때 재접속을 합니다.


         MRU : 굳이 안 적어도 되겠지만 1500 정도

         Local IP address : 안 적어도 됩니다.

         Remote IP address : 204.252.145.2

  ④ Routing

     아무 설정을 안 해도 상관 없습니다.

==========================================================================
====



  이렇게만 해주면 일단 기본 설정은 끝납니다. 아마도 이 환경이 유효하려면 재부팅


해야 할겁니다. 자 이제 재부팅한 후 세연으로 하이텔 접속을 하고 go internet --->


34.가상 PPP 로 들어가신 후 Slirp Ready... 뭐 이런 비슷한 글귀가 나올때, 한텀 등


을 열거나 세연의 suspend 기능을 이용해 다음과 같은 명령을 실행합니다. 참고로 아


래 명령은 기본적으로 root 사용자만 가능합니다.

  #pppd /dev/modem  defaultroute

여기까지 성공했다면 O.K.입니다. 이제 여러분이 사용하고자 하는 프로그램들을 실행


하면 됩니다. 가장 많이 쓰시는 www 의 경우 넷스케이프, 아레나, 레드본 혹은  lynx


를 이용하시면 되겠죠. 특히 lynx 는 그림이 안 뜨므로 상당히 빠르게 쓸 수 있을 겁


니다.


[참고]

  ① #/etc/resolv.conf

       search hitel.kol.co.kr

       nameserver 204.252.145.2

  ② #/etc/hosts

       127.0.0.1      localhost

       204.252.145.2  hitel.kol.co.kr



  ③ #/etc/sysconfig/network-scripts/ifcfg-ppp0

       PHONENUM=

       PERSIST=yes

       DEFROUTE=yes

       ONBOOT=no

       DIALCMD=ATDT

       INITSTRING=ATZ

       MODEMPORT=/dev/modem

       LINESPEED=38400

       ESCAPECHARS=no

       DEFABORT=yes

       HARDFLOWCTL=yes

       DEVICE=ppp0

       REMIP=204.252.145.2

       IPADDR=

       BOOTP=no

       MRU=1500

PS. 으 웬일이지 중간에 한줄씩이 생기네요.
질문있으시면 syn3@hitel.kol.co.kr 로 해주세요.


여기 까지 입니다.
유용하게 쓰세요
이것은 레드햇 리눅스의 강좌입니다.


제  목: [강좌] 일반 리눅스의 ppp 접속하기

이것은 일반 리눅스상에서 접속하는 방법입니다.
밑과 동일하게 나우에서 퍼옴..

***************************************************************************
*** PPP에 대하여***********************************************************
***************************************************************************



1. ppp의 개요

   PPP는 Point-to-Point로써 packet을 교환하기 위한 link를 생성하는
data link층을 규정한 프로토콜이다. 복수의 프로토콜의 datagram을 운영하기
위한 표준적인 방법도 제공되어 있다. 여기서, datagram이란 IP protocol등의
network층에서 다루는 data의 단위. 이것이 capsul화 되어 data link층에 전해진다.
즉, PPP를 이용하여 한 호스트가 network에 연결되어 있는 호스트에 연결하면,
그때부터는 자신의 컴퓨터를 인터넷 호스트인 것처럼(자신의 컴퓨터를 인터넷에
바로 연결된 것처럼) 이용할 수 있는 것입니다.
   Point-to-Point 형의 접속형태를 실현하기 위한 프로토콜에
SLIP(Serial Line IP)가 있습니다. 이것은 IP protocol만 운용하고,
error등의 처리도 정의되어 있지 않다. PPP의 등장으로 지금까지 SLIP으로
접속하고 있던 조직도 PPP로 전환하고 있는 추세이다.

   다음에 PPP의 3가지 주요 구성요소가 있다.
 1) 복수의 프로토콜의 data link를 capsul화 하는 방법.
 2) data link의 접속을 확립, 설정, test하기 위한 LCP(Link Control Protocol)
 3) 서로다른 network층의 프로토콜의 전송을 실현, 설정하기 위한 NCP(Network
    Control Protocol)

   PPP는 복수의 network층 프로토콜의 통신을 실현하기 위하여 복수의 프로토콜
방법으로 실현되어져 있습니다.


 (1) link의 확립과 절단

    PPP가 link를 확립하고 통신을 개시하여 절단할 때 까지를 순서대로
   설명하고자 한다.

    1) Link Dead phase
      PPP는 이 phase로 부터 시작하여 다시 이 phase로 돌아와 종료한다.
     이 phase는 물리층의 통신준비가 정리되어 있지 않은 상태이다. 외부로
     부터 무엇인가의 event(carrier가 검출되어 진다거나, 관리자로 부터
     접속요구가 있다거나)가 일어나고, 물리층의 준비가 정리되면, Link
     Establishment phase로 천이한다.  이 때 LCP에 대하여 ''UP'' signal이
     보내진다.

    2) Link Establishment phase
      UP signale을 받은 LCP를 사용하여 Link에 관한 정보가 상호 교환되어
     링크확립의 과정이 시작된다. 이 때, LCP에 대하여 특별한 요구(링크 품질의
     감시와 인증 프로토콜의 유무등)가 없으면, 통신의 확립작업에 관해서는
     default의 조건으로 된다. 주의할 점은 LCP가 하는 작업은 모두 네트워크층의
     프로토콜에 의존하지 않는 것으로 되어 있다. network protocol에 의존하는
     부분은 4의 Network-Layer Protocol phrase에서 NCP에 의해 작업이 이루어 진다.
 네트워크층의 프로토콜에
     의존하지 않는 부분의 링크가 확립되면 LCP는 ''OPENED''라고 하는 상태가
     되고, PPP는 Authentication phrase로 천이한다.

    3) Authentication phrase
       network층의 프로토콜의 packet을 교환하기 전에 필요가 있으면 링크에
      접속한 peer간에서 인증이 일어납니다.
      "인증을 할 것인가?" 또는 "어떤 인증을 할 것인가?"는
      Link Establishment phrase에서 LCP에 의해 교환된 정보에 따른다.
      통상 인증이 일어나는 경우는 PAP, 또는 CHAP이 사용되어 진다. 인증이
      필요없거나 인증이 성공한 경우는 Network-Layer Protocol phrase로 천이한다.

    4) Network-Layer Protocol phrase
       PPP가 여기까지의 phrase에 성공하면 각 network층의 프로토콜(IP, IPX,
       AppleTalk등)에 대응한 NCP에 의해 각각 구별되는 network 이용을 위한
       정보를 교환한다.
       여기에 성공하면 이후 대응하는 프로토콜의 datagram은 자유롭게 링크상을
       다닐 수 있다. 대응하지 않는 packet이 수신된다면 그것은 제거되어 진다.
       이 phrase중에는 LCP, NCP, network층의 프로토콜등의 packet이 통과가능하다.

       또한, NCP는 언제라도 링크를 닫도록 요구할 수 있다.

     5) Link Termination phase
        carrier가 없게 되거나, 인증에 실패하거나, 링크의 품질이
        저하되거나, idle time이 오래되거나, 또는 관리자로 부터 단절요구가 오면,
        PPP는 언제라도 링크를 단절할 수 있다. 링크의 단절은 LCP의 작업에
        해당한다.
        실제에는 LCP가 단절하기 위한 정보를 ''Terminate packet''으로써
        상호교환한다.
        단절이 일어나면 PPP는 네트워크층의 프로토콜에게 그 보고를 하고,
        적절한 처리를 하게 한다. 필요하면, 물리층에 대해서도 링크 단절을
        위한 signal을 보내고, 물리적으로도 단절한다. 이 phrase에서는
        LCP이외의 packet은 모조리 제거되어 진다.  모든 작업이 종료하면
        Link Dead phrase로 천이한다.

    PPP는 이상과 같은 흐름으로 링크를 확립, 통신, 단절을 일으킨다.
 이러한 프로토콜들이 협조하여 PPP로써의 기능을 실현하고 있다. LCP가 링크를
 확립하고, NCP가 그 링크상에서 network층으로 정의되어진 프로토콜의 packet을
 통신할 수 있도록 설정한다.

  [참고]  일본 UNIX MAGAZINE 1995년 3월 p87부터..


  2.linux에서 dial-up 접속을 통한 ppp 이용

 (1) dial-up 접속과 uugetty

  * 모뎀을 통하여 pc에 접속할 때 uugetty는 다음의 화일에서 기동되고,
    초기설 되어 집니다.

     /etc/inittab                     기동
     /etc/gettydefs                   port의 초기설정
     /etc/default/uugetty.ttyS3       modem의 초기설정

   * /etc/inittab에는 감시하는 device(ttyS3)와 label(vc9600)을 인수로써
    지정한다.
    사용하는 단말의 type(vt100 등)은 옵션이다.

s1:45:respawn:/sbin/uugetty -d /etc/default/uugetty.ttyS3 ttyS3 vc9600 vt100

   RS232C port에 대응하는 스페셜 화일은 /dev/ttyS*이다. 이것은 call-in
  device이고, call-out device는 /dev/cua*이다.
   label은 /etc/gettydefs의 record의 선두에 쓰여있는 것이다.

  (2) /etc/gettydefs의 설정

    * /etc/gettydefs file의 record는 \#으로 구별되어지고, 5개의 field를
     지정한다. 제2field는 port의 초기설정, 제3field는 최종설정이다. 그리고,
     제4field는 로그인 프로세스의 설정이다. B9600이 통신속도를 설정하는
     파라미터이다.
     통신속도는 모뎀이 support하는 최고속도로 설정한다. CS8은 data length
     8bit, CRTSCTS는 modem과 PC 사이에서 RTS/CTS에 의한 하드웨어 flow를
     제어한다.  모뎀이 이 flow제어를 support하고 있으면 지정해 두는것이
     좋겠지요.

vc9600# B9600 CS8 CRTSCTS # B9600 SANE -ISTRIP CRTSCTS # @S login: #vc9600


   (3) uugetty.ttyS* 의 설정

      dial-up 접속에서는 uugetty.ttyS*의 설정이 바르게 되지 않으면,
     uugetty가 제대로 작동하지 않는다. 이 화일에서는 INIT, CONNECT,
     TIMEOUT의 지정이 특히 중요하다.

           HANGUP=YES
           DEBUG=010
           INIT="" AT\r OK ATS0=3&D0\r OK
           ALTLOCK=cua3
           ALTLINE=cua3
           WAITFOR=RING
           CONNECT="" ATs0=3\r CONNECT\s\A
           TIMEOUT=60
           LOGIN=/bin/login

   [HANGUP=YES] {uu}getty start시에 회선을 절단한다.

   [DEBUG=010]  debug 정보를 /var/adm/debug에 출력한다.

   [INIT]       {uu}getty start시에 serial port를 초기화한다. 이것은 모뎀이
                연결되어 있으면 반드시 해야한다.
                INIT에 지정하는 문자열은
                      
                에는 모뎀이 보내주는 문자열을 은
                PC가 모뎀에게 보내는 문자열을 지정한다.

    [WAITFOR=RING] modem이 보내주는 RING이라고 하는 문자를 user의 억세스라고
                  본다.

    [CONNECT]   전화가 연결된 후 반송하는 result code의 지정이다.
               위의 예와같이 지정하면 \s 후에 통신속도를 보내고,
               그리고 나서 uugetty는 그 속도를 자동 조정한다. 이 접속시의
               속도조정기능을 위해 inittab에는 모뎀이 support하고 있는
               최고속도를 초기치로써 지정할 수 있다.

               data의 전송속도에는 모뎀간의 회선속도와 단말과 모뎀간의
               단말 속도가 있다.  모뎀이 CONNECT라고 하는 문자와 함께
               반송하는 것은 회선속도이다.
               이 CONNECT에  의해 단말속도가 회선속도와 같도록 set되어 진다.

     [TIMEOUT]  보내는 신호를 수신하지 않으면 종료되는 시간. 즉 위의 경우
                login prompt가 보인 후 1분안에 login 하지 않으면 종료된다.
     [LOGIN]    login process의 지정. 이것은 default등으로 필요없을 때도
                있지만, 지정하지 않으면 로그인 프로세스가 발생하지 않는
                경우도 있다.

   (4) server로써의 set up

      (uu)getty를 이용하여 dial-up 접속을 가능하게 하는것을 보았을 것입니다.
     이 때 수신측에서 pppd deamon을 기동하면, ppp server로써 동작하게 됩니다.
     ppp전용 로그인 ID를 사용하면 됩니다. 그렇게 하면, 그 로그인명으로
     로그인을 하면 바로 pppd 데몬이 기동되는 것입니다. /etc/passwd file에서
     shell로써 /usr/sbin/pppd를 지정하기만 하면 되므로 setup은 간단합니다.
     PPP를 사용하는 사용자 전원이 ppp전용 로그인 ID와 password를 알고 있지
     않으면 안 됩니다.

     다음의 내용은 server측의 passwd file의 내용입니다.

        ppp:mZtjMMWS43oFY:512:14:PPP:/etc/ppp:/usr/sbin/pppd

     pppd 데몬은 설정을 /etc/ppp/options file에서 참조합니다.

     다음은 ppp server로써의 일반적인 설정 예입니다.

          crtscts
          passive
          38400
          modem
          proxyarp
          203.253.145.1:203.253.145.3

    [crtscts]  hardware flow를 제어
    [passive]  server(수신) 모드
    [38400]    통신속도. modem간의 속도가 아니라, 단말속도이다.
    [modem]    modem mode
    [proxyarp] 대리 ARP. client machine을 server machine이 속하는 LAN의
               일부로써 인식하게 하기 위한 것.
    [203.253.145.1:203.253.145.3] server와 client IP address. :으로 구별한다.

  (5) client로써의 setup

      pppd 기동 script를 작성한다.

    #!/bin/sh
    /usr/sbin/pppd connect '/usr/sbin/chat -f ~/.chat' /dev/cua3 \
                   38400 debug crtscts modem defaultroute

      이 기동 script에서는 chat script를 -f switch로 다른 별도의 화일을
     만들어 참조하고 있다. 여기에서는 chat script를 자신의 홈디렉토리에
     .chat라는 이름으로 두고 있다. 이 화일에는 password를 기술하게 되므로,
     chmod 600 \~/.chat 라고 실행하여 다른 유저가 읽을 수 없게 한다.

     [connect ] serial line을 setup하기 위해 실행화일이나 shell command가
                   사용되어 진다. 주로 chat 명령어가 사용되는데, 여기에서는
                   remote computer로 전화를 거는데 사용되어 진다. connect는
                   한 word만 인수로 사용하므로, 여기에서는 single quotation으로
                   묶여진 부분이 connect의 인수에 해당한다.

     [/dev/cua3]   사용하고자 하는 device설정. 여기에서 cua3은 모뎀이 com4를
                   사용하고 있음을 뜻한다.

     [38400]       속도. 접속이 안되는 경우 9600으로 한번 해보세요.

     [debug]       debug내용을 출력. 출력되는 화일은 /etc/syslog.conf에서 설정.


     [crtscts]     serial port의 data의 flow를 control하기 위해서 hardware
                   flow control을 사용하라.

     [modem]       modem control line을 사용하라. pppd는 전화를 걸기 전이나
                   건 후에 전화를 hang-up할 것이다. modem의 초기설정..
                   뭐 이런게 아닐까??

     [defaultroute] ppp link가 확립되었을 때, remote server를 gateway로
                    default routing을 한다.
