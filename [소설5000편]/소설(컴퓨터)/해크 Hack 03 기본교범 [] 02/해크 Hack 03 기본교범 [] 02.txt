해킹정보..
신출귀몰 해커도 손바닥 안에!
해킹의 최신 형태와 방지 테크닉
해킹이란 무엇인 가?
진부한 면이 있긴 하지만 hacker's dictionay를 참조하기로 하자.
Hacker: 1. A person who enjoys learning the details of computer systems and
how to stretch their capabilities - as opposed to most users of computers,
who prefer to learn only the minimum amount necessary. 2.One who programs
enthusiastically or who enjoys programming rather than just theorizing
about programming. - Guy L.Steele. et al. The Hacker's Dictionary
해커란, 컴퓨터에 정열을 가지고 열심히 몰두하는 사람들을 뜻한다.
오히려 언론에서나 일상에서 떠돌고 있는 해커라는 단어는 크래커(Cracker)나
시스템침입자(system intruder)의 뜻에 더 가깝다고 할 수 있다.
최근에는 각종 언론이나 기관에서 해킹에 상당히 민감한 반응을 보이고 있는
것이 요즘 들어 상 당히 크고 작은 해킹 사건들이 자주 일어났기 때문이다.
인터넷이 확산됨에 따라 이러한 현상은 더욱 두드러질 것으로 보인다. 해킹에
대비한 가장 무서운 방어법은 백업이 아닐까 싶다. 이는 물론 가장 기본적인
대비책이기 도 하다. "하드디스크를 밀어버리려면 밀어봐라. 우리는 날마다 백업
받는다네" "어제 지우고 갔 으면 오늘 또 살려놓으면 되지 뭐." 이렇게 된다면
해킹할 맛이 날까? 해킹 방지법을 익히기에 앞 서 간단히 국내에서 일어났었던
해킹 사례 들을 살펴보고 이전의 해킹유형 과 최신 해킹 사례들 을 자세히
살펴본다.
국내에서 발생한 해킹 사례
SERI(시스템 공학 연구소)의 슈퍼컴 센터 내 CRAY 2S에 해커가 침입, 시스템을
교란한 예. (1992)
서울대학교 전산센터에 해커들이 서울대의 LAN에 침입해 워크스테이션 6대의
모든 하드디 스크를 지워버린 예. (1993)
한국통신연구개발센터, 하나망 관리센터에서도 서울대와 유사한 사건이 발생
(1993)
원자력 연구소에 영국 소년해커가 침입(사실은 이와 이름이 비슷한 대학의
호스트에 침입한 것이지만 언론들의 허위, 과장보도로 잘못 알려진 사건)해 하드
디스크의 정보가 외부에 개 방됐던 사건 (1994)
한국 전산원, KRNIC(한국 망 정보 센터) 해킹사건:국내 네트워크 정보서버에
해커가 침입한 사건 (1994)
서강대학교의 아키서버에 침투해 디스크를 지워버린 사건 (1994)
KAIST 해킹 사건:영어권의 해커가 침투중 KUS(KAIST Unix Security task
force)멤버에 게 적 발된 예
위의 사건들은 신문지상에서 많이 접해본 것들이다. 물론 크고 작은 해킹 사건이
무수히 많이 일 어났었지만 굵직한 사건들만 나열했다. 이와 같이 많은 보안
사건이 벌어지는 상황에서 시스템의 관리자나 사용자의 입장에서 무엇을
해야만이 해커들의 침입 을 막을 수 있을까? 또한 독도는 자 기 땅이라고
우겨대는 얄미운 일본의 전산망을 무력화시키려 면 어떤 작업을 해야 할까?
하지만 독자들이 우선 이해하기 쉽도록 기초적인 내용을 먼저 적어 놓을까 한다.
해킹의 개념과 종류 대부분의 실력 있는 해커들은 다른 시스템에 침투를
하더라도 대의명분(?)이 있는 경우가 다반사 다. 자기가 관리하는 시스템에 다른
해커가 들어와서, 이를 신속히 추적하기 위해 역해킹하는 경 우의 예를 들 수
있겠다. 또한 어느 정도 실력 있는 해커들의 경 우에는 해커리즘에 관한 건전한
마인드가 형성돼 있는 사람들이 많기 때문에 이들이 혹시 자기 시스템에 피해를
입히지 않을까 걱정할 필요는 없다. 다만 걱정이 되는 것은 중고생들이 컴퓨터나
유닉스에 관한 전문적인 지식도 없으면서 막연한 공 명심과 엉뚱한 영웅심에
휩쓸려 해킹을 하게 되는 경우이다. 이들은 어쩌다 구한 해킹툴을 이용 해,
해킹을 하며 자신들이 침투를 했다는 증거도 지우고 나가지 못하는 경우가
대부분이다. 이러 한 상황에서 중고생들이 우연히 침투하게 되었다가 잡히게
되면 그들의 인생에는 어느덧 전과자 라는 기록이 남게 되는 것이다.ㅤ 해킹이란
법률적인 의미에서 보면 '시스템의 관리자가 구축해 놓은 보안망을 어떤
목적에서건 무 력화시켰을 경우 이에 따른 모 든 행동을 해킹이라고 한다.'고
돼있다. 하지만 네티즌간에는 보통 시스템 관리자의 권한을 불법 적으로 획득한
경우, 또 이를 악 용해 다른 사용자에게 피해를 준 경우를 해킹이라고 정의하고
있다. (간단한 해킹으로 어떤 사용 자의 패스워드를 추측을 통해서 건, 우연히
알게 되어서건 도용을 하게 됐을 경우를 들 수 있다.)
해킹의 3단계 절차
어떤 호스트를 해킹하기 위해서는 보통 3단계 절차를 거치게 된다.
1단계로 목표로 한 호스트 내 부에 잠입을 하여 쉘(shell)을 사용할 수 있는
유저의 권한을 얻어내는 것이다. 이를 실행하기 위 해 유저의 패스워드를 알아야
하는데, 스니프(sniff)를 이용 하는 고급방법에서부터, finger -l @targethost를
해 알아낸 사용자들의 패스워드를 추측해 로긴하는 무식한 방법까지 아주 다양
한 방법이 있다. 보통의 해커라면 외부에서 목표로 한 호스트의 패스워드 파일을
빼와서 이를 이용해 목표로 한 호스트 내부유저로 침입하는 것 이 보통이다.
그리고 이 1단계를 방어하는 것이 바로 네트워크 시큐리티이다.
2단계로 목표로 했던 호스트 내부에 잠입을 했으면 목표 호스트의
관리자(root)의 권한을 획득하 려고 시도할 것이다. 이는 호스트 내부의 OS
홀(hole)을 이용하는 경우가 많다. 또한 이 2단계를 방어하는 것이 바로 로컬
시큐리티이다.
3단계는 호스트 관리자(root)의 권한을 획득한 뒤 자신이 다음에 다시 침입할
경우에 편의성을 기 하기 위해 backdoor(뒷문)를 만 들어 놓고 나가는 단계이다.
매번 목표로 한 호스트에 잠입하기 위해 번번이 해킹을 시도한다면 증거를
언젠가 남기기 마련이고 '꼬리가 길어져서' 결국은 잡히 기 마련이다. 자신만이
사용할 수 있는 내부 버그(트로이 목마)를 남겨놓고 가는 것이 침입 때 증 거를
남기지 않는 좋은 방법이기 때문에 해커들은 이를 애용하고 있다. 해킹의 이해를
돕기 위한 유닉스 상의 기초상식 이제부터 나오는 내용들은 해킹을 이해하기
위한 유닉스상의 기초 지식이다.
패스워드는 어떻게 관리되는가?
보통 도용한 ID를 이용해 다른 시스템이나 ID의 소유주가 사용하고 있는
시스템의 관리자(root, Super user)의 자격을 얻어내기 위한 발판으로 삼는
경우가 있다.
그러므로 자신의 도용 당한 ID 때문에 피해를 본 쪽에서 조사 를 한다면 자신이
하지도 않은 일 에 의심을 사게 될 수도 있게 되는 것이다. 또한 ID를 도용
당하면 자신만의 피해로 끝나는 일이 아닌 시스템의 피해까지도 야기할 수 있기
때문에 패스워드를 검증하는 절 차를 두어 패스워드를 모르는 외부인은 사용하지
못하도록 막고 있는 것이다. 하지만 이 패스워드를 사용하고 있다 하더라도
문제는 있다. 만일 다른 사람도 충분히 추측해낼 수 있는 것으로 패스워드를
정했다면 다른 사람이 마음만 먹으면 자신의 ID를 사용할 수 있으므 로
무용지물이 되는 것이다. 그래서 자신의 패스워드를 관리하는 것에 대해
말해볼까 한다. 유닉스 시스템은 각 유저들의 패스워드 및 기타 정보를
/etc/passwd에 보관하고있다. vi나 cat을 이 용해 이 파일을 살펴보자.( 단,
보는 방법이 어떤 시스템을 쓰느냐에 따라 다르다. 위의 것은 일반 적인
경우이고 위에 나온 NIS 시스템은 NFS 시스템과 함께 같이 뒤에서 설명하고자
한다.) NIS 시스템을 이용하는 경우: cat /etc/passwd나 ypcat passwd를 한다.
NetInfo 시스템을 이용하는 경우: nidump passwd / 를 한다. 예시로 몇 줄만
들어보자.
root:##root:0:0:Supervisor:/:/bin/csh daemon:##daemon:1:1::/:
uucp:##uucp:4:8::/var/spool/uucppublic: kwlee:##kwlee:104:30:KyeongWon
Lee:/circ/kus/kwlee:/usr/local/bin/tcsh sakai:##sakai:129:30:Kim Huy
kang:/circ/kus/sakai:/usr/local/bin/tcsh hohle:##hohle:11529:410:Hoh eun
ha:/under/under/hohle:/bin/csh sungho:##sungho:13189:410:Park sung ho
:/under/under/sungho:/bin/csh
위와 같이 : 으로 구분된 두 번째 부분이 위와 같이 돼있는 경우도 있을 것이고
또는 root:VRLoJ2QnLhRA2:0:0:Supervisor:/:/bin/csh daemon:*1:1::/::
uucp:*:4:8::/var/spool/uucppublic: kwlee:ntim9ljaUGI.A:104:30:KyeongWon
Lee:/circ/kus/kwlee:/usr/local/bin/tcsh sakai:tdtwKgRa3ZZoI:129:30:Kim Huy
kang:/circ/kus/sakai:/usr/local/bin/tcsh hohle:u2WKlqINaIP8w:11529:410:Hoh
eun ha:/under/under/hohle:/bin/csh sungho:eATMm4J0Zb4Dw:13189:410:Park sung
ho :/under/under/sungho:/bin/csh
위와 같은 경우도 있을 것이다. 두 파일을 한번 살펴보자. 첫 세 줄은
root,daemon,uucp라는 시스 템 계정(account)에 관한 정보 이고 그 다음에
나오는 줄들은 kwlee나 sakai 같은 시스템의 일반 유저들에 관한 정보이다. 각각
의 줄은 : 을 기준으로 다음과 같은 7개의 필드(field)로 나뉜다.
1 Field : 유저 이름
2 Field : 유저의 패스워드(보통 보여주지 않거나 알아보지 못하게 변형시켜
놓는다.)
3 Field : 유저의 ID number(UID)
4 Field : 유저가 속해있는 그룹의 ID number(GID)
5 Field : 유저의 실제 이름
6 Field : 유저의 홈 디렉토리
7 Field : 유저가 사용하는 Shell
그 예를 들어보자.
위에서 sakai란 사람을 살펴보면
sakai:##sakai:129:30:Kim Huy kang:/circ/kus/sakai:/usr/local/bin/tcsh
sakai:tdtwKgRa3ZZoI:129:30:Kim Huy kang:/circ/kus/sakai:/usr/local/bin/tcsh
유저이름: sakai password: ##sakai(의도적으로 패스워드 부분을 숨긴
경우->Shadowing passwd라고도 말한 다.) tdtwKgRa3ZZoI(변형시켜서 알지 못하게
한 경우. 보통 encrypt(암호화)시켰다고 말한다.)
UID : 129 GID : 30 실제 유저의 이름: Kim Huy kang 유저의
홈디렉토리:/circ/kus/sakai 유저가 사용하는 쉘: tcsh 위와 같은 정보를 얻을
수가 있다.
해킹정보..
패스워드는 어떻게 만들어지는가? 그럼 위의 변형된 부분은 어떻게 생성되는
것일까? 다음을 수행시켜보자.
% /usr/lib/makekey iakasbells lsDy0cB/5/zho>
% /usr/lib/makekey sakaixvaaa aaxuEmMgYNZz2>
두 번의 실행결과를 비교해 보자.
공통점은 입력한 글쇠 중에서 끝에서 두번째부터의 글씨는 다 음 줄의 암호화된
부분에 그대로 찍혀 나오고 나머지 부분은 알아보지 못하게 변형되어 나온 것 을
알 수 있다.
위의 예에서 입력 한 단어 iakasbells의 마지막 두 글자 ls와 다음에 변형된
단어 lsDy0cB/5/zho>의 첫 ls와 같다.
이 마지막 두 글자들을 key character(혹은 salt)라고 한다. 이런 방식으로
로그인 네임을 입력한 후 패스워드를 입력하면 맨 마지막의 두번째 글자들을
가지고 입력한 패스워드를 암호화하게 되고 이 암호화한 자료를 가지고
/etc/passwd와 내용을 비교하여 옳다면 로그인에 성공하게 되는 것이 다.
보통 패스워드는 8자를 기준으로 하기 때문에 패스워드로 입력한 글자 수와
마지막 두 글자가 중 요한 의미를 갖게 된다.
앞 절에 서도 말했지만 충분히 추측할 수 있는 패스워드를 사용하면 곤 란하다.
또 /etc/passwd 파일로부터 패스워드를 추측해 주는 툴들( Crack 이라든지
Cops)을 사용해 알아낼 수도 있다.
이 툴들은 자신들의 독특한 알고리즘을 사용하는데, 이를테면 사전에 나오는
단어들이나, ID를 뒤 집어 대입해본다든지, 패스워드 파일에서 알아낸 자료들을
대입해본다든지 하는 방법이다. 물론 대입을 할 때에는 crypt() 함수를 이용해
encrypt(암호화)한 다음 이 결과를 /etc/passwd 파일에 있는 두번째 field인
변형된 부분과 계속 비교해 맞는지를 확인 해내게 된다.
이런 이유로 인해 흔히 일상에서 쓰는 단어들은 적발될 우려가 높은데, 좋지
않은 패스워드로서 다음과 같은 사례를 들 수 있다 . 좋지 않은 패스워드의 예
ID와 같은 password 사용하는 시스템의 이름 컴퓨터 호스트의 이름 영어사전에
나오는 단어 (boss , world .... ) 전화번호 생일 키보드 위의 같은 선상에 있는
글쇠들의 연속.(qwert,asdf .....) 동일한 글자의 연속 (11111, eeeee .... )
setuid란 무엇인가?
/etc/passwd의 소유주는 분명히 호스트 관리자(root)이다.
또한 우리는 패스워드를 바꾼 다음 변경 된 내용을 /etc/passwd 파일 에 저장을
하고 있다. 이상하지 않은가? 보통의 예라면 permission denied 라는 눈에 익은
메시지 가 떠야 할 텐데 말이다. 여기 에 아주 중요한 내용이 담겨 있다. 바로
setuid라는 것이다.
다음을 수행시켜 보자.
% ls -al /bin/passwd rwsr-xr-x 2 root 512 Jan 11 12:31 passwd
앞에서 설명이 잘 됐겠지만 setuid bit로서 s가 표시돼 있음을 알 수 있다.
이는 이 프로그램이 실 행되는 동안은 루트의 권한을 가질 수 있게 되며
프로그램이 끝남과 동시에 이 권한은 사라지게 된다. 그런 이유로 패스워드 를
이용해 /etc/passwd 파일을 우 리가 바꿀 수 있는 것이다. 우리는 이런 setuid를
많이 이용하고 있다. 로그인 프롬프트가 나왔을 때 우리는 생각 없이 로그 인을
하지만 내부에서는 상당히 복잡한 구동이 이뤄지고 있다. 우선 login 이라는
메시지 다음에 들어오는 사용자의 ID를 읽어 들 인다. 그리고 패스워드를 읽어
들이는데 읽어들인 패스워드를 crypt() 함수를 이용해 암호화시킨다.
이 암호화된 패스워드를 /etc/pas sword(Shadowing passwd 인 경우는 다른 파일
이를테면 passwd.adjunct 같은 다른 파일을 참조한 다.)의 두번째 field와
비교해 같으면 올바른 패스워드를 입력했으므로 login을 허가해준다.
다시 ls /bin/login을 해보면 알겠지만 이 login도 root 소유의 setuid bit가
붙은 파일이다. 여기서 알아둬야 할 점은 패스워드를 확인할 때 /etc/passwd
파일의 두 번째 field를 풀어서 입력된 패스워드와 맞춰 보는 게 아니라는
점이다. 이런 decrypt 함수는 없으며 알고리즘도 존재치 않는 다. 이로 인해
불완전하지만 유닉스의 보안이 이뤄지고 있는 것이다. 또한 앞에서 이야기했지만
루트 소유이고 setuid가 실행되는 동안은 시스템관리자의 권한을 갖는 다고
했다.
우리는 이것을 보고 effective uid라고 한다. 해커들은 이런 루트 소유의 setuid
bit 파일 들을 실행시키는 동안 인터럽 트를 걸 수 있는 쉘 스크립트라든가 툴을
이용해 이 파일들의 실행 을 중지시킨 상태로 있게 한 다. 즉 root의 권한을
가진 채로 있도록 하는 것이다. 이런 식으로 해 root의 권한을 불법적으로
획득하는 것이 대부분의 해킹방법이다. 과거의 해킹 유형들 예전에는 주로
네트워크 상이나 로컬 호스트 상에 서 configuration이 잘못된 것을 이용해
관리자 의 권한을 얻는 초보적인 해킹이 많았다.
즉, OS를 인스톨하면 프로그램들의 퍼미션이 적절히 조 정 안돼 있는 경우가
많은데, 이를 악용해 호스트 관리자만이 보고 쓸 수 있는 파일도 마음대로
조작하는 경우가 예전의 해 킹 유형이었다. 또한 웃지 못할 얘기로 해킹시도를
해도 계속 실패하 게 되자,
기계를 들고 훔쳐 달아난 도둑해커(?) 도 있다.
               다음 페이지로..
             
